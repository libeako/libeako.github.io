<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>other, less important stuff</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="rmciseizvhdgclym.html">user interface</a></span><span class="wit-nav-item"><a href="oeyeaezscdudpssh.html">formal languages</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">software coding</a></span><span class="wit-nav-item wit-nav-current-page">other, less important stuff</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>abstractions</p><div class="wit-content"><section><p>category theory</p><div class="wit-content"><section><p>Edward Kmett : &quot;I &quot;categorically&quot; refuse to turn off the flashlight I&#39;m using to find my way around in the dark. =P &quot;</p><div class="wit-content"><section><p>https://www.reddit.com/r/haskell/comments/1o6iqs/why_i_dont_like_the_lens_library/ccpcjb0/</p><div class="wit-content" /></section></div></section><section><p>functor</p><div class="wit-content"><section><p>positive and negative position</p><div class="wit-content" /></section><section><p>representable</p><div class="wit-content"><section><p>just the indexability of the position of the elements in the functor</p><div class="wit-content" /></section><section><p>representable means representable by a function</p><div class="wit-content"><section><p>according to the definition the representation is surjective</p><div class="wit-content" /></section><section><p>hence bijective</p><div class="wit-content" /></section><section><p>that is the representable functor is also something that can represent a function</p><div class="wit-content"><section><p>like memorizing it</p><div class="wit-content" /></section></div></section></div></section><section><p>sums are not generally representable</p><div class="wit-content" /></section><section><p>product are representable</p><div class="wit-content" /></section></div></section><section><p>hom functor</p><div class="wit-content"><section><p>it is just the reader functor</p><div class="wit-content" /></section></div></section><section><p>yoneda lemma</p><div class="wit-content"><section><p>in Haskell</p><div class="wit-content"><section><p>good first intuition for programmers</p><div class="wit-content"><section><p><a href="http://blog.sigfpe.com/2006/11/yoneda-lemma.html">Reverse Engineering Machines with the Yoneda Lemma</a></p><div class="wit-content" /></section></div></section><section><p>awesome proof</p><div class="wit-content"><section><p>https://scturtle.me/posts/2015-06-16-yoneda.html</p><div class="wit-content" /></section></div></section></div></section><section><p>coyoneda is the free functor</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>lens</p><div class="wit-content"><section><p><a href="https://artyom.me/#lens-over-tea">lens over tea</a></p><div class="wit-content" /></section></div></section><section><p>monoid</p><div class="wit-content"><section><p>Notions of Computation as Monoids</p><div class="wit-content"><section><p>authors</p><div class="wit-content"><section><p>EXEQUIEL RIVAS</p><div class="wit-content" /></section><section><p>MAURO JASKELIOFF</p><div class="wit-content" /></section></div></section><section><p>description</p><div class="wit-content"><section><p>puts some important abstractions into a common framework of monoid</p><div class="wit-content" /></section><section><p>base abstractions</p><div class="wit-content"><section><p>monoid</p><div class="wit-content" /></section><section><p>applicative</p><div class="wit-content" /></section><section><p>monad</p><div class="wit-content" /></section><section><p>arrow</p><div class="wit-content" /></section></div></section><section><p>their free versions</p><div class="wit-content" /></section><section><p>their Cayley versions</p><div class="wit-content"><section><p>difference list</p><div class="wit-content" /></section><section><p>codensity monad</p><div class="wit-content" /></section></div></section><section><p><a href="https://arxiv.org/pdf/1406.4823.pdf">download here</a></p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>parser combination</p><div class="wit-content"><section><p>applicative</p><div class="wit-content" /></section><section><p>monadic</p><div class="wit-content" /></section></div></section></div></section><section><p>embedded</p><div class="wit-content"><section><p><a href="https://www.andres-loeh.de/ASGDSL/ASGDSL.pdf">Abstract Syntax Graphs for Domain Specific Languages</a></p><div class="wit-content" /></section></div></section><section><p>type size homomorphism</p><div class="wit-content"><section><p>this interesting homomorphism is extended much beyond to what i told previously</p><div class="wit-content"><section><p>you do not need to learn it at this point; and i advise you not to go deep into it because it is somewhat difficult area for someone who just started to learn about algebraic data types</p><div class="wit-content" /></section><section><p>but if you are interested then here are some links</p><div class="wit-content"><section><p><a href="http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/">by chris taylor</a></p><div class="wit-content" /></section><section><p><a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types">by joel burget</a></p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>totality</p><div class="wit-content"><section><p>the compiler can usually check automatically</p><div class="wit-content"><section><p>exmaples</p><div class="wit-content"><section><p>size l =</p><div class="wit-content"><section><p>case l of</p><div class="wit-content"><section><p>nil -&gt; 0</p><div class="wit-content" /></section><section><p>head::tail -&gt; 1 + (size tail)</p><div class="wit-content" /></section></div></section></div></section><section><p>fold f z l =</p><div class="wit-content"><section><p>case l of</p><div class="wit-content"><section><p>nil -&gt; z</p><div class="wit-content" /></section><section><p>head::tail -&gt; foldl f (f z head) tail</p><div class="wit-content" /></section></div></section></div></section></div></section></div></section></div></section></span></body></html>