<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>function</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="rmciseizvhdgclym.html">user interface</a></span><span class="wit-nav-item"><a href="oeyeaezscdudpssh.html">formal languages</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">software coding</a></span><span class="wit-nav-item"><a href="jaxbiyrfnbhaormb.html">some basic prog lang notions</a></span><span class="wit-nav-item wit-nav-current-page">function</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>syntax of the type</p><div class="wit-content"><section><p>of functions from type x to type y is </p><div class="wit-content"><section><p>x -&gt; y</p><div class="wit-content" /></section></div></section></div></section><section><p><a href="kofbgukzdvgkwkxs.html">&quot;lambda function&quot;s</a></p><div class="wit-content" /></section><section><p>syntax of function definition</p><div class="wit-content"><section><p>literal</p><div class="wit-content"><section><p>f = fun x -&gt; ... x ...</p><div class="wit-content" /></section></div></section><section><p>syntax sugar</p><div class="wit-content"><section><p>f x = ... x ...</p><div class="wit-content" /></section></div></section></div></section><section><p>function application</p><div class="wit-content"><section><p>function application is a very common kind of expression in programming, especially in functional programming languages; hence many language designers think it deserves the most simple syntax :</p><div class="wit-content" /></section><section><p>f x</p><div class="wit-content" /></section><section><p>this is the invocation of function f with argument x</p><div class="wit-content" /></section></div></section><section><p>type as parameter</p><div class="wit-content"><section><p>the input of a function can be a type too; then the output of the function is said to be &quot;parametrically polymorph&quot; in Haskell and &quot;generic&quot; in Java, C#</p><div class="wit-content" /></section><section><p>f : (t : Type) -&gt; (... t ...)</p><div class="wit-content" /></section><section><p>where (...  t ...) is a type expression depending on t</p><div class="wit-content" /></section><section><p>in some languages [notably Haskell] we just write</p><div class="wit-content" /></section><section><p>f : (... t ...)</p><div class="wit-content" /></section><section><p>and the compiler automatically infers that that t, not known for it, is an implicit type input</p><div class="wit-content" /></section></div></section><section><p>the &quot;identity&quot; function</p><div class="wit-content"><section><p>id : (t : Type) -&gt; (t -&gt; t)</p><div class="wit-content" /></section><section><p>id x = x</p><div class="wit-content" /></section><section><p>the name is from the fact that the output is &quot;identical&quot; to the input</p><div class="wit-content" /></section></div></section><section><p>implicit arguments</p><div class="wit-content"><section><p>an argument in a function application is implicit iff it is not specified by the coder explicitly, but let the compiler infer it; a formal input is implicit iff its corresponding argument in applications can be implicit; which formal inputs are implicit; in Haskell the type inputs are implicit; in Idris the coder can specify any input to be implicit, by enclosing them in curly braces, but still lets the coder to explicitly specify them in applications, in curly braces</p><div class="wit-content" /></section><section><p>for example in Idris:</p><div class="wit-content"><section><p>in declaration:</p><div class="wit-content"><section><p>f : { t : Type } -&gt; t -&gt; ...</p><div class="wit-content" /></section></div></section><section><p>in application</p><div class="wit-content"><section><p>explicitly: (f {t = Integer} 5) or implicitly: (f 5)</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>multi-input functions</p><div class="wit-content"><section><p>most functional programming languages adopt the simplicity of math: a function has exactly 1 input and exactly 1 output; still: this simplicity is enough to express multi-input functions too; let us see how:</p><div class="wit-content" /></section><section><p>the intuitive solution is to pack the multiple inputs into one, their product:</p><div class="wit-content"><section><p>(x1, x2) -&gt; y</p><div class="wit-content" /></section></div></section><section><p>an other solution is:</p><div class="wit-content" /></section><section><p><a href="rjvsfevdnztyxdlz.html">currying</a></p><div class="wit-content" /></section><section><p>flipping the order of the inputs</p><div class="wit-content"><section><p>flip : (a-&gt;b-&gt;c) -&gt; (b-&gt;a-&gt;c)</p><div class="wit-content" /></section><section><p>flip f b a = f a b</p><div class="wit-content" /></section></div></section><section><p>application of a function in this form is like &quot;(f x) y&quot;; function application is chosen to be left-associative to make us able to omit the braces: &quot;f x y&quot;</p><div class="wit-content" /></section></div></section><section><p>infix naming</p><div class="wit-content"><section><p>chaining multiple applications of the same binary function can look ugly with the regular syntax; for example here is the summation of 5 values:</p><div class="wit-content" /></section><section><p>(plus (plus (plus a b) c) d) e</p><div class="wit-content" /></section><section><p>we wish instead the following syntax:</p><div class="wit-content" /></section><section><p>a + b + c + d + e</p><div class="wit-content" /></section><section><p>to enable this: functions may have names with irregular characters and be applied by placing the arguments to both sides of them</p><div class="wit-content" /></section><section><p>because this is an irregular syntax of function application: the syntax needs to disambiguate between the application of the function and regular referencing it; for example: how should the compiler know that &quot;(x+y)&quot; is the invokation of &quot;+&quot; with &quot;x&quot; and &quot;y&quot; instead of the invokation of &quot;x&quot; with &quot;+&quot; and &#39;y&#39;; to resolve this ambiguity the language designers decided to obligate the coder to disambiguate with special syntax: the invokation is as intuitively guessed but the normal reference is with round braces, for example: &quot;x + y&quot; and &quot;(+) x y&quot; denote the same thing</p><div class="wit-content" /></section><section><p>do not overuse this syntax</p><div class="wit-content"><section><p>this irregular syntax is to make chains of binary function applications neater; but outisde of this usage: they do not have advantage; but they do always have disadvantage relative to the regular naming: it is often difficult to guess their meaning from their name, search for them on the web, pronounce them</p><div class="wit-content" /></section></div></section></div></section><section><p>function composition</p><div class="wit-content"><section><p>(&gt;&gt;&gt;) : (t1 -&gt; t2) -&gt; (t2 -&gt; t3) -&gt; (t1 -&gt; t3)</p><div class="wit-content" /></section><section><p>f &gt;&gt;&gt; g = fun x -&gt; g (f x)  (&lt;&lt;&lt;) = flip (&gt;&gt;&gt;)</p><div class="wit-content" /></section></div></section><section><p><a href="xbcsbisjcnxjnneu.html">partial function application</a></p><div class="wit-content" /></section><section><p><a href="oqmgrzzqokpkuawg.html">point-free style</a></p><div class="wit-content" /></section></span></body></html>