<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>function</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="nnsmzqwudqobukpt.html">fund</a></span><span class="wit-nav-item"><a href="znuvgowivqvqbdhr.html">language</a></span><span class="wit-nav-item"><a href="jaxbiyrfnbhaormb.html">general language</a></span><span class="wit-nav-item wit-nav-current-page">function</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>syntax of the function type from type x to type y is </p><div class="wit-content"><section><p>x -&gt; y</p><div class="wit-content" /></section></div></section><section><p><a href="kofbgukzdvgkwkxs.html">&quot;lambda function&quot;</a></p><div class="wit-content"><section><p>are just &#39;function literals</p><div class="wit-content" /></section></div></section><section><p>a syntax sugar for function implementation is </p><div class="wit-content"><section><p>instead of </p><div class="wit-content"><section><p>f = fun x -&gt; ... x ...</p><div class="wit-content" /></section></div></section><section><p>f x = ... x ...</p><div class="wit-content" /></section></div></section><section><p>function application</p><div class="wit-content"><section><p>function application is a very common kind of expression, hence many language designers think it deserves the most simple syntax: a space</p><div class="wit-content" /></section><section><p>f x</p><div class="wit-content" /></section><section><p>this is the invocation of function f with argument x</p><div class="wit-content" /></section></div></section><section><p>the input being a type</p><div class="wit-content"><section><p>in Java and C# this is known as &quot;generic&quot;</p><div class="wit-content" /></section><section><p>f : (t : Type) -&gt; (... t ...)</p><div class="wit-content"><section><p>where (...  t ...) is a type expression depending on t</p><div class="wit-content" /></section></div></section><section><p>in some languages [notably Haskell] we just write</p><div class="wit-content"><section><p>f : (... t ...)</p><div class="wit-content" /></section><section><p>and the compiler automatically infers that that t, not known for it, is an implicit type input</p><div class="wit-content" /></section></div></section></div></section><section><p>the &quot;identity&quot; function</p><div class="wit-content"><section><p>id : (t : Type) -&gt; (t -&gt; t)</p><div class="wit-content" /></section><section><p>id x = x</p><div class="wit-content" /></section><section><p>the name is from the fact that the output is &quot;identical&quot; to the input</p><div class="wit-content" /></section></div></section><section><p>implicit arguments</p><div class="wit-content"><section><p>an argument in a function application is implicit iff it is not specified by the coder explicitly, but is let for the compiler to infer it</p><div class="wit-content" /></section><section><p>an input is implicit iff its corresponding argument is implicit</p><div class="wit-content" /></section><section><p>which inputs are implicit?</p><div class="wit-content"><section><p>in Haskell the type inputs are implicit</p><div class="wit-content" /></section><section><p>in Idris, Agda the coder can specify any input to be implicit, by enclosing them in curly braces, but this still lets the coder to explicitly specify them in applications, in curly braces</p><div class="wit-content" /></section></div></section><section><p>example in Idris</p><div class="wit-content"><section><p>in the type</p><div class="wit-content"><section><p>f : { t : Type } -&gt; t -&gt; ...</p><div class="wit-content" /></section></div></section><section><p>in application</p><div class="wit-content"><section><p>implicitly:</p><div class="wit-content"><section><p>f 5</p><div class="wit-content" /></section></div></section><section><p>explicitly</p><div class="wit-content"><section><p>f {t = Integer} 5</p><div class="wit-content" /></section></div></section></div></section></div></section></div></section><section><p>multi-input functions</p><div class="wit-content"><section><p>most functional programming languages adopt the simplicity of math: a function has exactly 1 input and exactly 1 output; still: this simplicity is enough to express multi-input functions too; here follows how</p><div class="wit-content" /></section><section><p>the natural solution is to pack the multiple inputs into one, their product:</p><div class="wit-content"><section><p>(x1, x2) -&gt; y</p><div class="wit-content" /></section></div></section><section><p><a href="rjvsfevdnztyxdlz.html">currying</a></p><div class="wit-content"><section><p>is an other solution</p><div class="wit-content" /></section></div></section><section><p>flipping the order of the inputs</p><div class="wit-content"><section><p>flip : (a-&gt;b-&gt;o) -&gt; (b-&gt;a-&gt;o)</p><div class="wit-content" /></section><section><p>flip f b a = f a b</p><div class="wit-content" /></section></div></section></div></section><section><p>infix naming</p><div class="wit-content"><section><p>chaining multiple applications of the same binary function can look ugly with the regular syntax</p><div class="wit-content" /></section><section><p>for example here is the summation of 5 values</p><div class="wit-content"><section><p>(plus (plus (plus a b) c) d) e</p><div class="wit-content" /></section></div></section><section><p>we wish instead the syntax</p><div class="wit-content"><section><p>a + b + c + d + e</p><div class="wit-content" /></section></div></section><section><p>to enable this: functions may have names with irregular characters and be applied by placing the arguments to both sides of them</p><div class="wit-content" /></section><section><p>disambiguation from the regular syntax</p><div class="wit-content"><section><p>for example: how should the compiler know that &#39;(x+y)&#39; is the invokation of &#39;+&#39; with &#39;x&#39; and &#39;y&#39; instead of the invokation of &#39;x&#39; with &#39;+&#39; and &#39;y&#39;; to resolve this ambiguity many language designers decided to obligate the coder to disambiguate as follows: </p><div class="wit-content" /></section><section><p>for function names with irregular characetrs</p><div class="wit-content"><section><p>the invokation is as you would intuitively guessed</p><div class="wit-content"><section><p>example: &quot;x + y&quot;</p><div class="wit-content" /></section></div></section><section><p>the normal reference is with round braces, </p><div class="wit-content"><section><p>example: &quot;(+) x y&quot;</p><div class="wit-content" /></section></div></section></div></section><section><p>those 2 examples denote the same thing</p><div class="wit-content" /></section></div></section><section><p>do not overuse this syntax</p><div class="wit-content"><section><p>this is an irregular syntax, is to make chains of binary function applications neater; but outisde of this usage: they do not have advantage; but they do always have disadvantage relative to the regular syntax: it is often difficult to guess the meaning of the function from their irregular name, search for them on the web, pronounce them</p><div class="wit-content" /></section></div></section></div></section><section><p>function composition</p><div class="wit-content"><section><p>(&gt;&gt;&gt;) : (x -&gt; y) -&gt; (y -&gt; z) -&gt; (x -&gt; z)</p><div class="wit-content" /></section><section><p>f &gt;&gt;&gt; g = fun x -&gt; g (f x)  (&lt;&lt;&lt;) = flip (&gt;&gt;&gt;)</p><div class="wit-content" /></section></div></section><section><p><a href="xbcsbisjcnxjnneu.html">partial function application</a></p><div class="wit-content" /></section><section><p><a href="oqmgrzzqokpkuawg.html">point-free style</a></p><div class="wit-content" /></section></span></body></html>