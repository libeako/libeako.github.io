<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>category to monoid is like static type checking to dynamic</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="oibaxnylzhpktgho.html">algebra</a></span><span class="wit-nav-item"><a href="nfoegqpcgzhctwbv.html">magma</a></span><span class="wit-nav-item"><a href="eovnsnrjngyuihhx.html">semigroup</a></span><span class="wit-nav-item"><a href="cabjryjnnstdjmvb.html">monoid</a></span><span class="wit-nav-item"><a href="edsabrzmtmhnwgml.html">category</a></span><span class="wit-nav-item"><a href="hdawzncgtnabaocq.html">introduction</a></span><span class="wit-nav-item"><a href="kdrjpfoaockqycyb.html">a generalization of monoid</a></span><span class="wit-nav-item wit-nav-current-page">category to monoid is like static type checking to dynamic</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>this section introduces categories from the world of [functional] programming</p><div class="wit-content" /></section><section><p>i will investigate the structure of programs</p><div class="wit-content" /></section><section><p>i will abstract away from the domain of the program, from what the actual functions do</p><div class="wit-content" /></section><section><p>programs form a monoid</p><div class="wit-content"><section><p>a program is just a function</p><div class="wit-content" /></section><section><p>programs can be composed by function composition [which is associative]</p><div class="wit-content" /></section><section><p>the empty program is the identity function</p><div class="wit-content" /></section><section><p>this structure sounds like the monoid of functions with function composition</p><div class="wit-content" /></section></div></section><section><p>but we do not have a monoid of general functions, but only of endo-functions</p><div class="wit-content"><section><p>an endo-function is a function whose input and output type are equal</p><div class="wit-content" /></section></div></section><section><p>[dynamic] typing</p><div class="wit-content"><section><p>hence i will restrict the values of the programs to a single type &quot;t&quot;; this is equivalent to how we view dynamically typed programs in compile time</p><div class="wit-content" /></section><section><p>in the following you should draw on a paper what i say to you to draw or at least imagine doing so</p><div class="wit-content" /></section><section><p>draw a point that represents t</p><div class="wit-content"><section><p>draw a dot and label it with &quot;t&quot;</p><div class="wit-content" /></section></div></section><section><p>we are dealing with functions, so you will draw some arrows demonstrating functions</p><div class="wit-content"><section><p>these functions go from t to t, so the arrows demonstrating them will start and end in the dot representing t</p><div class="wit-content" /></section><section><p>surely : an identity function exists, whatever t is</p><div class="wit-content"><section><p> so draw a small arrow and label it with &quot;id&quot;</p><div class="wit-content" /></section></div></section><section><p>other endo-functions may also exist</p><div class="wit-content"><section><p>so draw some more arrows</p><div class="wit-content" /></section></div></section></div></section><section><p>the drawing now illustrates the monoidal structure of dynamically type-checked programs [the arrows are the programs]</p><div class="wit-content" /></section></div></section><section><p>static typing</p><div class="wit-content"><section><p>but dynamic type-checking is unsatisfactory; hence i will try to extend the picture to multiple types</p><div class="wit-content" /></section><section><p>draw some more dots to represent some other types</p><div class="wit-content"><section><p>you may want to label some of them with familiar simple types, like &quot;integer&quot;, &quot;string&quot;</p><div class="wit-content" /></section></div></section><section><p>for each type x an identity function (id : x -&gt; x) exists</p><div class="wit-content"><section><p>draw such for each new dots</p><div class="wit-content" /></section></div></section><section><p>functions may be between different types</p><div class="wit-content"><section><p>so draw some arrows between different dots</p><div class="wit-content" /></section><section><p>for example</p><div class="wit-content"><section><p>size : string -&gt; integer</p><div class="wit-content" /></section></div></section></div></section><section><p>the drawing now illustrates what a category is; it is an algebra in which the values are still the arrows [in our example : programs], but compared to the simpler monoidal version : the arrows are between mutliple objects [in our example : programs have input and output types]; in a category : for each value f : we associate a property (x ~&gt; y) indicating that f goes from x to y</p><div class="wit-content" /></section><section><p>in monoid [in our example : dynamic type checking] all values [in our example : functions] had the same &quot;type&quot;; hence composition was simple : (&gt;&gt;&gt;) : t -&gt; t -&gt; t</p><div class="wit-content" /></section><section><p>in category [in our example : static type checking] values [in our example : functions] may have different &quot;types&quot;</p><div class="wit-content"><section><p>with these more complex types of the values their composition would look like the following, at least at first try</p><div class="wit-content"><section><p>(&gt;&gt;&gt;) : (a ~&gt; b) -&gt; (c ~&gt; d) -&gt; (e ~&gt; f)</p><div class="wit-content" /></section></div></section><section><p>but the whole point of types is to constrain the composition : we will allow composition of values only of compatible &quot;type&quot;s</p><div class="wit-content"><section><p>(&gt;&gt;&gt;) : (a ~&gt; b) -&gt; (b ~&gt; c) -&gt; (a ~&gt; c)</p><div class="wit-content" /></section><section><p>(the source of the second input) must equal to (the target of the first input)</p><div class="wit-content" /></section></div></section></div></section><section><p>how is the empty element of monoid affected by the generalization ?</p><div class="wit-content"><section><p>empty must behave neutrally in the composition function; this can be expressed by these equations : </p><div class="wit-content"><section><p>for all f : </p><div class="wit-content"><section><p>empty &gt;&gt;&gt; f = f</p><div class="wit-content" /></section><section><p>f  &gt;&gt;&gt; empty= f</p><div class="wit-content" /></section></div></section></div></section><section><p>these 2 equations are symmetric and studying only one of them will suffice; let that one be (empty &gt;&gt;&gt; f = f)</p><div class="wit-content" /></section><section><p>some new notations to ease the formal work</p><div class="wit-content"><section><p>let</p><div class="wit-content"><section><p>fs = source of f</p><div class="wit-content" /></section><section><p>ft = target of f</p><div class="wit-content" /></section><section><p>es = source of empty</p><div class="wit-content" /></section><section><p>et = target of empty</p><div class="wit-content" /></section></div></section></div></section><section><p>the studied equation at the type level is (type of (empty &gt;&gt;&gt; f) = type of f); that is ((es ~&gt; ft) = (fs ~&gt; ft); hence (es = fs)</p><div class="wit-content" /></section><section><p>from the type constraint of composition : et = fs</p><div class="wit-content" /></section><section><p>hence the source and target of empty are both equal to fs and hence to each other</p><div class="wit-content" /></section><section><p>hence the generalization of empty to category theory is endo-arrow</p><div class="wit-content" /></section><section><p>in monoid empty must be composable with any other value; this constraint in category theory corresponds to the requirement that for all objects : an endo-arrow exists that behaves neutrally in arrow-composition; thus empty in a category is not necessarily a single value, but rather one for each object</p><div class="wit-content" /></section></div></section></div></section></span></body></html>