<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>maybe a solution of boolean blindness</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="nnsmzqwudqobukpt.html">fund</a></span><span class="wit-nav-item"><a href="aacixgsdjlspuizr.html">derivation system</a></span><span class="wit-nav-item"><a href="hoqxwlarqggqsrwp.html">type</a></span><span class="wit-nav-item"><a href="qkpkvuxwtzdigyud.html">parametricity</a></span><span class="wit-nav-item"><a href="iuvbupavbjmhfrxj.html">of type inputs</a></span><span class="wit-nav-item"><a href="ipmcnbqgopeplpis.html">genericity healthily constrains implementation</a></span><span class="wit-nav-item wit-nav-current-page">maybe a solution of boolean blindness</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>here i present a type-safe solution for the &quot;boolean blindness&quot; problem, via the &#39;Maybe&#39; type; it is simple and cheap but not widely used</p><div class="wit-content" /></section><section><p>it is an application of the more general (type-generalize for safety and and clarity technique)</p><div class="wit-content" /></section><section><p>the wide-spread method against boolean-blindness in 2024 is to choose descriptive, unambiguous names; it is a down-to-earth and cheap method and works well in most cases; the advantages of the method shown here is that it is type-safe and gives generalization that could become practically useful later for the client; </p><div class="wit-content" /></section><section><p>i present it not to advocate its usage but rather only as an interesting method</p><div class="wit-content" /></section><section><p>examples</p><div class="wit-content"><section><p>switch</p><div class="wit-content"><section><p>once upon a time i had a client with a task for me: write a program that prints &quot;hello world&quot;; i implemented the program and it worked perfectly, my client was satisfied; but later the client wished a new feature: write an exclamation mark after the &quot;hello world&quot;, but do so only if a certain command line flag is passed [not everyone likes exclamation marks]; how should i represent internally whether to write the exclamation mark? the usual method is to introduce a custom boolean type like</p><div class="wit-content" /></section><section><p>datatype FeatureActivity = On | Off</p><div class="wit-content" /></section><section><p>but a type-safe method is possible too, by generalization of the task: instead of an exclamation mark hard-coded let us be able to print anything after the &quot;hello world&quot; greating, let us store the postfix to print:</p><div class="wit-content" /></section><section><p>FeatureActivity := Maybe String</p><div class="wit-content" /></section></div></section><section><p>the List select function</p><div class="wit-content"><section><p>select : (x -&gt; Bool) -&gt; List x -&gt; List x</p><div class="wit-content" /></section><section><p>filter : (x -&gt; Maybe y) -&gt; List x -&gt; List y</p><div class="wit-content" /></section></div></section></div></section></span></body></html>