<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>static type checking</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">coding</a></span><span class="wit-nav-item"><a href="ftkadhwzfhvfbwnk.html">correct by construction</a></span><span class="wit-nav-item wit-nav-current-page">static type checking</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p><a href="https://youtu.be/CpQb9D_X4cM">an audio version of this topic</a></p><div class="wit-content" /></section><section><p>here i advocate that static type checking is better</p><div class="wit-content" /></section><section><p>advantages</p><div class="wit-content"><section><p>prevents many bugs</p><div class="wit-content" /></section><section><p>documents the code</p><div class="wit-content" /></section><section><p>helps the compiler in the optimization of the executable</p><div class="wit-content" /></section><section><p>helps the IDE in helping the coder</p><div class="wit-content" /></section></div></section><section><p>debunking alleged disadvantages</p><div class="wit-content"><section><p>the constrains of the static typing are bypassable</p><div class="wit-content"><section><p>static type systems do rule out some valid programs; but all practical programming languages provide a method to opt out from the static type checking [for example by dynamically checked type conversion]; so in case the concrete type system can not express something: the programmer can always write that piece of the program without static typing and still benefit form static typing where applicable</p><div class="wit-content" /></section></div></section><section><p>the verbosity that type annotations make is useful, they document the intent of the coder, which should be at least in comment anyway</p><div class="wit-content" /></section><section><p>type inference</p><div class="wit-content"><section><p>if despite all these great arguments you still prefer to not have to write type annotations then you can achieve that while still have static type-checking; by powerful type inference</p><div class="wit-content"><section><p>there are type-systems and accompanying type inference algorithms, implemented, in general purpose, industry-strong programming languages, that can infer everything, you do not have to write a single type annotation</p><div class="wit-content" /></section><section><p>for a theoretical background see &quot;hindley milner type system&quot;</p><div class="wit-content" /></section><section><p>an example for such programming language is Haskell 98; modern Haskell has a powerful type-system, and not all the features of it is covered with total type inference, but the part that is covered [98] is still stronger than the type system of the current [2019] versions of most industry languages; alternatively: you can use the advanced type features of Haskell too, but then you need to write some type annotations, mostly for top level definitions</p><div class="wit-content" /></section><section><p>if you try this then you will find that you do want to write type annotations; for code readability, type error descriptions, hole-types</p><div class="wit-content"><section><p>by the way: this [getting to use it by monotone steps] is a good proof of that type annotations and static type-checking are good</p><div class="wit-content" /></section></div></section><section><p>you still end up writing type annotations, but by your own choice only, you do not have to</p><div class="wit-content" /></section></div></section></div></section><section><p>type errors are always errors, hence you see them the earlier the better</p><div class="wit-content"><section><p>with dynamic typing you still see the type errors, in run-time; you postpone the bad news to run-time, which is usually a much worse place for an error to happen</p><div class="wit-content" /></section><section><p>even during development</p><div class="wit-content"><section><p>type errors are usually bugs; you should not normally postpone dealing with a bug to implement new functionality; as your program grows, the more difficult it will be to find the bug in it, to eliminate the bug, to do refactoring; the bug may even hurt the new functionality</p><div class="wit-content" /></section></div></section></div></section><section><p>scripting does not require dynamic typing</p><div class="wit-content"><section><p>a script is still a program, just a small one, all the arguments for general programming apply for scripts too</p><div class="wit-content" /></section></div></section><section><p>embedding statically typed languages into applications is theoretically possible</p><div class="wit-content"><section><p>almost all new high level languages and most old functional languages come with a read-eval-print loop, which is an example of such embedding</p><div class="wit-content" /></section></div></section><section><p>static type checking takes almost no time</p><div class="wit-content"><section><p>it is optimization that takes long; especially in C++ [as it compiles all instances of templates separately]; for example: in C#: even big programs are compiled very quickly in debug mode, where optimization is omitted</p><div class="wit-content" /></section></div></section></div></section><section><p>unit testing</p><div class="wit-content"><section><p>unit testing is to complement static type checking, it can not replace it</p><div class="wit-content"><section><p>testing may only show the presence of bug, static typing shows the absence of bugs, only static typing can do that</p><div class="wit-content" /></section><section><p>most of the properties of a program that we want to ensure are very simple ones; in these cases the cost of type annotations is practically zero, but replacing them with tests takes much work; and that work is horrendously boring and has to be redone after changing the program, which makes changing difficult</p><div class="wit-content" /></section><section><p>executing unit tests takes a considerable amount of time, executing static type checking takes only practically 0 time</p><div class="wit-content" /></section></div></section></div></section><section><p>the human</p><div class="wit-content"><section><p>whatever you do not check with the compiler nor with unit tests: the human coder must do it</p><div class="wit-content" /></section><section><p><a href="nelvtoguoomgxthl.html">but the compiler is much better in it</a></p><div class="wit-content" /></section></div></section><section><p>conclusion</p><div class="wit-content"><section><p>the only disadvantage static type checking has is that it takes time to create a static type system, it is more difficult to design the language and it is more difficult to implement a compiler for it; but now, in 2024 this is relatively a very small cost and the advantages of static typing are many and great</p><div class="wit-content" /></section></div></section><section><p><a href="ratihdffwublrlih.html">use your static type system</a></p><div class="wit-content" /></section></span></body></html>