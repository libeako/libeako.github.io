<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>static vs dynamic typing</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="rmciseizvhdgclym.html">user interface</a></span><span class="wit-nav-item"><a href="oeyeaezscdudpssh.html">formal languages</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">software coding</a></span><span class="wit-nav-item"><a href="ftkadhwzfhvfbwnk.html">correct by construction</a></span><span class="wit-nav-item"><a href="jyulqiuyobsytqwf.html">static type checking</a></span><span class="wit-nav-item wit-nav-current-page">static vs dynamic typing</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p><a href="https://youtu.be/CpQb9D_X4cM">an audio version of this topic</a></p><div class="wit-content" /></section><section><p>here i advocate that static type systems are better</p><div class="wit-content" /></section><section><p>advantages</p><div class="wit-content"><section><p>prevents many bugs</p><div class="wit-content" /></section><section><p>documents the code</p><div class="wit-content" /></section><section><p>helps the compiler in the optimization of the executable</p><div class="wit-content" /></section><section><p>helps the IDE in helping the coder</p><div class="wit-content" /></section></div></section><section><p>debunking the alleged disadvantages</p><div class="wit-content"><section><p>it does not constrain the programmer</p><div class="wit-content"><section><p>static type systems do rule out some valid programs; but all practical programming languages provide a method to opt out from the static type checking [for example by dynamically checked type conversion]; so in case the concrete type system can not express something : the programmer can always write that piece of the program without static typing and still benefit form static typing for the rest of the program</p><div class="wit-content" /></section></div></section><section><p>the verbosity that type annotations make is useful, they document the intent of the coder, which should be at least in comment anyway</p><div class="wit-content" /></section><section><p>type inference</p><div class="wit-content"><section><p>if despite all these great arguments you still prefer to not have to write type annotations then you can achieve that while still have static type-checking; by powerful type inference</p><div class="wit-content"><section><p>there are type-systems and accompanying type inference algorithms, implemented, in general purpose, industry-strong programming languages, that can infer everything, you do not have to write a single type annotation</p><div class="wit-content" /></section><section><p>for a theoretical background see &quot;hindley milner type system&quot;</p><div class="wit-content" /></section><section><p>an example for such programming language is Haskell 98; modern Haskell has a powerful type-system, and not all the features of it is covered with total type inference, but the part that is covered [98] is still stronger than the type inference of the current [2019] versions of most industry languages; alternatively : you can use the advanced type features of Haskell too, but then you need to write some type annotations, mostly for top level definitions</p><div class="wit-content" /></section><section><p>if you try this then you will find that you do want to write type annotations; for code readability, type error descriptions, hole-types</p><div class="wit-content"><section><p>by the way : this is a good proof of that type annotations are good</p><div class="wit-content" /></section></div></section><section><p>&quot;aha&quot; you may say &quot;so you still end up writing type annotations&quot;; - yes, but by your own choice only, you do not have to</p><div class="wit-content" /></section></div></section></div></section><section><p>&quot;but i do not want to see type errors&quot; - by choosing dynamic typing you are still to see those type errors, you just postpone the bad news to run-time, which is usually a much worse place for an error to happen</p><div class="wit-content" /></section><section><p>&quot;okay, i would not let it to run-time but now i want to concentrate on functionality and later deal with type errors&quot; - type errors are usually bugs; you should not normally postpone dealing with a bug to implement new functionality; as your program grows, the more difficult it will be to find the bug in it, to eliminate the bug, to do refactoring; the bug may even hurt the new functionality; getting informed about the existence of a bug before moving on to implement new functionality is a big gift</p><div class="wit-content" /></section><section><p>&quot;but for scripting we need dynamic typing&quot; - false</p><div class="wit-content"><section><p>a script is still a program, just a small one, all the arguments for general programming apply for scripts too</p><div class="wit-content" /></section><section><p>embedding statically typed languaged languages into application is possible theoretically without any difficulty</p><div class="wit-content"><section><p>in practice : all new languages, and most old functional languages come with a read-eval-print loop, which is an example of such embedding</p><div class="wit-content" /></section></div></section></div></section><section><p>static type checking takes almost no time</p><div class="wit-content"><section><p>it is optimization that takes long; especially in C++; for example : in C# : even big programs are compiled in very short time in debug mode, where optimization is omitted</p><div class="wit-content" /></section></div></section></div></section><section><p>unit testing</p><div class="wit-content"><section><p>unit testing is to complement static type checking, it can not replace it</p><div class="wit-content"><section><p>most of the properties of a program that we want to ensure are very simple ones, and in these cases the cost of type annotations is practically zero, but replacing them with tests takes much work; and that work is horrendously boring</p><div class="wit-content" /></section><section><p>testing usually checks for not all the inputs</p><div class="wit-content" /></section><section><p>executing unit tests takes a considerable amount of time, executing static type checking takes practically 0 time</p><div class="wit-content" /></section></div></section></div></section><section><p>the human</p><div class="wit-content"><section><p>whatever you do not check with the compiler nor with unit tests : the human coder must do it</p><div class="wit-content" /></section><section><p><a href="nelvtoguoomgxthl.html">but the compiler is much better in it</a></p><div class="wit-content" /></section></div></section><section><p>conclusion</p><div class="wit-content"><section><p>the only disadvantage static type checking has is that it takes time to create a static type system, it is more difficult to design the language and it is more difficult to implement a compiler for it; but now, in 2019 this is relatively a very small price and the advantages of static type checking are many and big</p><div class="wit-content" /></section></div></section></span></body></html>