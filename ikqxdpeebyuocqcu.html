<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>how to be functional</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">information technology</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="rmciseizvhdgclym.html">user interface</a></span><span class="wit-nav-item"><a href="oeyeaezscdudpssh.html">formal languages</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">software coding</a></span><span class="wit-nav-item"><a href="ftkadhwzfhvfbwnk.html">correct by construction</a></span><span class="wit-nav-item"><a href="brqzviybtynlulwl.html">avoiding dangers</a></span><span class="wit-nav-item"><a href="zxsbxwlppaypmpnn.html">functional programming</a></span><span class="wit-nav-item"><a href="rqeeitsvmgrogdjp.html">introduction</a></span><span class="wit-nav-item wit-nav-current-page">how to be functional</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>in your imperative language</p><div class="wit-content"><section><p>simple local variables </p><div class="wit-content"><section><p>do not change them, instead make a new one for the new value</p><div class="wit-content" /></section><section><p>trust the compiler in optimization for efficiency [variable life analysis]</p><div class="wit-content" /></section><section><p>the compilers perhaps do this under the hood anyway</p><div class="wit-content"><section><p><a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">see static single assignment</a></p><div class="wit-content" /></section></div></section></div></section><section><p>loop</p><div class="wit-content"><section><p>wrap the general loop control structure into a pure function :</p><div class="wit-content" /></section><section><p>loop : (State -&gt; Bool) -&gt; (State -&gt; State) -&gt; State -&gt; State</p><div class="wit-content" /></section><section><p>loop iterate_if iter init =</p><div class="wit-content"><section><p>if cond_to_cont init</p><div class="wit-content"><section><p>then loop (iter init) iter iterate_if</p><div class="wit-content" /></section><section><p>else init</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>collection</p><div class="wit-content"><section><p>instead of traversing a collection with iterator | enumerator use a &quot;fold&quot; function :</p><div class="wit-content" /></section><section><p>fold : (initial_value : t) (combine_values : t -&gt; e -&gt; t) (collection : c e) -&gt; t</p><div class="wit-content" /></section><section><p>in the .Net base library such a function exists with name &quot;Aggregate&quot;</p><div class="wit-content" /></section></div></section><section><p>effects</p><div class="wit-content"><section><p>in functional programming effects are allowed and possible</p><div class="wit-content" /></section><section><p>just they happen not to the side, hence they are not side-effects, instead they are returned by the function as a value that represent an action; by this the function only computes the effect, does not perform it, thus remains pure</p><div class="wit-content" /></section><section><p>you can do this (delegating the performance of effects up) in java and c# too; and you should</p><div class="wit-content" /></section><section><p>how far up should the delegation continue? generally till a function swallows it [performs it but without its entirety having side-effect]</p><div class="wit-content"><section><p>escapable effects</p><div class="wit-content"><section><p>these are ones that can be performed by an ordinary function without its entirety having side-effect; example : mutation of a local variable</p><div class="wit-content" /></section></div></section><section><p>inescapable effects</p><div class="wit-content"><section><p>such effect is inherited by the calling function; example : input, output; the calling function of the main function is the runtime system, which is outside of the language semantics and hence is allowed to perform the effect as a side-effect</p><div class="wit-content" /></section></div></section></div></section></div></section></div></section><section><p>switch programming language</p><div class="wit-content"><section><p>if you are using an imperative language i encourage you to change to a functional one; at least for weekend coding; it is not a waste of time to learn a good functional language; they are going to take over the software engineering worlds anyway</p><div class="wit-content" /></section><section><p>functional languages do not keep punishing you for being functional, hence with them you are more likely to fall in love with functional programming; by the way : after that you will be more brave to embrace functional programming even in non-functional languages</p><div class="wit-content" /></section><section><p>which language?</p><div class="wit-content"><section><p>some people find it useful to start with one that does not have much capability; to avoid distractions; one such popular language is elm; its type system is weak enough to make it impossible to express advanced mathematical abstractions, hence you will not find those anywhere near elm; thus elm&#39;s type system being weak is a feature that provides you with a safe learning space for functional programming; elm is a way for those who want to step one at a time</p><div class="wit-content" /></section><section><p>but it is not necessary to start with a weak language; once i needed to write a small program; i was very noob, i even did not know what a monad is, still i managed to write the program in haskell [which is the most advanced mature general purpose language] by restraining myself to only the essential features of haskell; it was not difficult, you also can jump straight into haskell too</p><div class="wit-content" /></section></div></section></div></section><section><p>hide mutation in laziness</p><div class="wit-content"><section><p><a href="http://travis.athougies.net/posts/2018-05-05-dynamic-programming-is-recursion.html">by travis ...</a></p><div class="wit-content" /></section></div></section></span></body></html>