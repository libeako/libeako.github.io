<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>how to be functional</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">coding</a></span><span class="wit-nav-item"><a href="ftkadhwzfhvfbwnk.html">correct by construction</a></span><span class="wit-nav-item"><a href="zxsbxwlppaypmpnn.html">functional programming</a></span><span class="wit-nav-item wit-nav-current-page">how to be functional</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p><a href="nnktlttxsmtkjnnc.html">requirements are none, but some support from the language is very useful</a></p><div class="wit-content" /></section><section><p>in any language</p><div class="wit-content"><section><p>simple local variables </p><div class="wit-content"><section><p>do not change them, instead make a new one for the new value</p><div class="wit-content" /></section><section><p>trust the compiler in optimization for efficiency [variable life analysis]</p><div class="wit-content" /></section><section><p>the compilers perhaps do this under the hood anyway</p><div class="wit-content"><section><p><a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">see static single assignment</a></p><div class="wit-content" /></section></div></section></div></section><section><p>loop</p><div class="wit-content"><section><p>wrap the loop control structure into a pure function:</p><div class="wit-content"><section><p>loop : (State -&gt; Bool) -&gt; (State -&gt; State) -&gt; State -&gt; State</p><div class="wit-content" /></section><section><p>loop condition iter s =</p><div class="wit-content"><section><p>if condition s</p><div class="wit-content"><section><p>then loop condition iter (iter s)</p><div class="wit-content" /></section><section><p>else s</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>the &#39;for&#39; and similars are just specific versions of the loop, wrap them too</p><div class="wit-content" /></section></div></section><section><p>collection</p><div class="wit-content"><section><p>instead of traversing a collection with iterator | enumerator use a &quot;fold&quot; function:</p><div class="wit-content" /></section><section><p>fold : (initial_value : t) (combine_values : t -&gt; e -&gt; t) (collection : c e) -&gt; t</p><div class="wit-content" /></section><section><p>in the .Net base library such a function exists with name &quot;Aggregate&quot;</p><div class="wit-content" /></section></div></section><section><p>effects</p><div class="wit-content"><section><p>in functional programming effects are possible</p><div class="wit-content" /></section><section><p>just they happen not to the side, hence they are not side-effects; instead they are returned by the function as a value that represents an effect [perhaps by representing an action]; by this the function only computes the effect, does not perform it, thus remains pure</p><div class="wit-content" /></section><section><p>you can do this (delegating the performance of effects up) in java and c# too</p><div class="wit-content" /></section></div></section><section><p>you may want to wrap state modifications by functions such that the state becomes input and output of the functional functions</p><div class="wit-content"><section><p>then a sequence of state-changing instructions may become functions chained together with function composition</p><div class="wit-content" /></section></div></section></div></section><section><p>switch programming language</p><div class="wit-content"><section><p>if you are using an imperative language i encourage you to change to a functional one; at least for weekend coding; it is not a waste of time to learn a good functional language; they are going to take over the software engineering world anyway</p><div class="wit-content" /></section><section><p>functional languages do not punish you for being functional, hence with them you are more likely to fall in love with functional programming; after that you will be more brave to embrace functional programming even in non-functional languages</p><div class="wit-content" /></section><section><p>which language?</p><div class="wit-content"><section><p>some people find it useful to start with one that does not have much capability; to avoid distractions; one such popular language is Elm; its type system is weak enough to make it impossible to express abstract mathematics, hence you will not find those anywhere near Elm; thus Elm&#39;s type system being weak is a feature that provides you with a safe learning space for functional programming; Elm is a way for those who want to step one at a time</p><div class="wit-content" /></section><section><p>but it is not necessary to start with a weak language; once i needed to write a small static website generator program; i was very noob, i even did not know what monad is, still i managed to write the program in Haskell by restraining myself to only the essential features of it; it was not difficult, you can jump straight into Haskell too</p><div class="wit-content" /></section></div></section></div></section><section><p>advanced</p><div class="wit-content"><section><p>achieve mutation by laziness</p><div class="wit-content"><section><p><a href="http://travis.athougies.net/posts/2018-05-05-dynamic-programming-is-recursion.html">by travis ...</a></p><div class="wit-content" /></section></div></section><section><p>fix-point combinator</p><div class="wit-content"><section><p><a href="https://www.vex.net/~trebla/haskell/fix.xhtml">a very good explanation of the fixpoint combinator &quot;fix&quot; in Haskell</a></p><div class="wit-content" /></section></div></section><section><p>recursion schemes</p><div class="wit-content"><section><p><a href="https://kseo.github.io/posts/2016-12-12-unfold-and-fold.html">Kwan: unfold and fold </a></p><div class="wit-content" /></section><section><p><a href="https://twanvl.nl/blog/haskell/traversing-syntax-trees">Traversing syntax trees [Twan van Laarhoven]</a></p><div class="wit-content" /></section></div></section></div></section></span></body></html>