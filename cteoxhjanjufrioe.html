<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>equality</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="nnsmzqwudqobukpt.html">fund</a></span><span class="wit-nav-item"><a href="hoqxwlarqggqsrwp.html">type</a></span><span class="wit-nav-item"><a href="kdtdlfyrudrcnrrl.html">programming and logic</a></span><span class="wit-nav-item"><a href="huktyxsxcfntvnbj.html">representing logical constructs</a></span><span class="wit-nav-item wit-nav-current-page">equality</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>this section talks about equality propositions that are prooved in compile time, not about equality propositions that are tested at run time</p><div class="wit-content" /></section><section><p>roles of equality propositions in programming in compile time :</p><div class="wit-content"><section><p>type checking</p><div class="wit-content"><section><p>the core of type checking is checking equality between types</p><div class="wit-content" /></section></div></section><section><p>proving equational properties about the program or the domain of the program by the human programmer</p><div class="wit-content" /></section></div></section><section><p>the core task of type checking is to check if the type of the actual input of a function is what the function expects; the core task of that is checking equality between 2 types expressed by [possibly complex] terms [&quot;expressions&quot;]</p><div class="wit-content" /></section><section><p>2 types are considered equal iff all their structure and all their components [dependencies] are equal</p><div class="wit-content" /></section><section><p>modern type systems are powerful, thus their types may contain all kinds of stuff in them</p><div class="wit-content"><section><p><a href="enjlgzgdnjxyjcck.html">link to &#39;dependencies of types&#39;</a></p><div class="wit-content" /></section></div></section><section><p>hence modern compilers must have an equality testing mechanism general for all kinds of terms</p><div class="wit-content" /></section><section><p>how can the compiler test equality between general terms? a straightforward method is checking identity between them; but in practice very often the same value is denoted by different terms; thus most compilers in practice evaluate the terms so much as they can and only after that do they perform the identity test, hoping that the evaluation leads to simpler terms, which hence may become identical</p><div class="wit-content" /></section><section><p>but even this may be not enough</p><div class="wit-content"><section><p>for example: the compilers usually are not able to prove the commutativity of integer addition</p><div class="wit-content" /></section><section><p>for these cases the programming language may provide a way for the programmer to attach a missing proof constructed by herself</p><div class="wit-content" /></section></div></section><section><p>&quot;intensional&quot; equality</p><div class="wit-content"><section><p>a statement of intensional equality exists at the meta level [inside the compiler]; hence it is a &quot;judgement&quot;</p><div class="wit-content" /></section><section><p>prooving of intensional equalities is done by the compiler on its own; but the compiler on its own can not prove all the true equations; because of this : its equality test returns not { true, false }, but rather { true, unknown }; an other way to see this is that it returns real bool value, but the relation this defines is not the usually regarded mathematical equality; but is it any kind of equality? yes; it is very easy to see that this test has the usually expected properties of equality [substitutivity, equivalence]; thus the name &quot;intensional euqality&quot; is still justified</p><div class="wit-content" /></section><section><p>this type of equality is also named &quot;definitional&quot;</p><div class="wit-content" /></section></div></section><section><p>&quot;extensional&quot; equality</p><div class="wit-content"><section><p>the compiler may not prove all the mathematically true equalities, hence some remain for the human programmer; this section discusses this kind of equality</p><div class="wit-content" /></section><section><p>a statement of extensional equality is stated and proved by the programmer, they exist in the source code [this corresponds to the &quot;object level&quot; in the logical sense]; the programmer can not only prove but also refute it, by forming its negation and proving that; this altogether means that such a statement is a proposition in the logic sense</p><div class="wit-content" /></section><section><p>this type of equality is also named &quot;propositional&quot;</p><div class="wit-content" /></section><section><p>proving can be done only in compile time, that is: &quot;at the type level&quot;</p><div class="wit-content"><section><p>hence the programmer expresses equality proposition as type </p><div class="wit-content" /></section><section><p>the whole thing is done in the spirit of</p><div class="wit-content" /></section><section><p><a href="kdtdlfyrudrcnrrl.html">the programming-logic correspondence</a></p><div class="wit-content" /></section><section><p>the truth value of the statement corresponds to the inhabitation of the type</p><div class="wit-content" /></section></div></section><section><p>here i start to build the type to express equality; i will name it by &quot;Eq&quot;; equality is interpreted only on values of the same type, hence its expressing type must depend on the type of the values whose equality is proposed : Eq := Type -&gt; ...; the equality proposition is about 2 values of this type, hence the type must depend on these value</p><div class="wit-content" /></section><section><p>s : Eq := (t : Type) -&gt; (a : t) -&gt; (b : t) -&gt; ...</p><div class="wit-content"><section><p><a href="svwipwixjxnwcfer.html">link to &#39;dependent type&#39;</a></p><div class="wit-content" /></section><section><p><a href="svwipwixjxnwcfer.html">link to &#39;dependent value&#39;</a></p><div class="wit-content" /></section></div></section><section><p>for the rest we have different options</p><div class="wit-content"><section><p>inspired by logic</p><div class="wit-content"><section><p>this is just the translation of the definition of equality in logic to programming</p><div class="wit-content"><section><p><a href="dxhxiloqezsthksz.html">see equality in mathematics</a></p><div class="wit-content" /></section></div></section><section><p>EqLo := (t : Type) -&gt; (x : t) -&gt; (y : t) -&gt; (p : t -&gt; Type) -&gt; (p x -&gt; p y)</p><div class="wit-content" /></section><section><p>&quot;EqLo&quot; is short of &quot;equality from logic&quot;</p><div class="wit-content" /></section></div></section><section><p>generalized algebraic data type</p><div class="wit-content"><section><p>EqGa (t : Type) (a : t) (b : t) :=</p><div class="wit-content"><section><p>refl : EqGa t a a</p><div class="wit-content" /></section></div></section><section><p>&quot;EqGo&quot; is short of &quot;equality as gadt&quot;</p><div class="wit-content" /></section><section><p>&#39;refl&#39; is short for &quot;reflexivity&quot;; reflecting the fact that it constructs reflexive pairs</p><div class="wit-content" /></section><section><p>converting</p><div class="wit-content"><section><p>from intensional</p><div class="wit-content"><section><p>generally with generalized algebraic data types : a constructor of a gadt can be invoked iff the output type of it unifies with the type of the whole gadt</p><div class="wit-content" /></section><section><p>these types here are</p><div class="wit-content"><section><p>EqGa t a b</p><div class="wit-content"><section><p>the type of the whole gadt</p><div class="wit-content" /></section><section><p>here i omitted the types of the inputs</p><div class="wit-content" /></section></div></section><section><p>EqGa t a a</p><div class="wit-content"><section><p>the type of the output of the constructor</p><div class="wit-content" /></section></div></section><section><p>note that the difference is only in the last input; hence they unify iff (a = b); unification is done by the type checking hence it is the compiler that has to know that (a = b)</p><div class="wit-content" /></section></div></section><section><p>summing up : the type has exactly one constructor whose requirement is that (a = b) intensionally</p><div class="wit-content" /></section></div></section><section><p>to intensional</p><div class="wit-content"><section><p>this is possible by pattern matching</p><div class="wit-content"><section><p>p : EqualGa t a b ... (case p of refl  {-- here the compiler learns --} -&gt; ... ) ...</p><div class="wit-content" /></section><section><p>the compiler unifies the output type of the constructor with the type of the whole gadt, which in this case leads to the conclusion that (a = b), which intensional information can be used in the handler side of the pattern match</p><div class="wit-content" /></section></div></section></div></section></div></section></div></section></div></section><section><p>equivalence between the different representations of equality</p><div class="wit-content"><section><p>equivalence between different types expressing the same proposition can be proved by showing any pair of functions between the 2 types</p><div class="wit-content" /></section><section><p>lo_ga : EqLo t a b -&gt; EqGa t a b lo_ga lo = lo (EqGa t a)</p><div class="wit-content" /></section><section><p>refl ga_lo : EqGa t a b -&gt; EqLo t a b ga_lo ga =</p><div class="wit-content"><section><p>case ga of refl -&gt; identity</p><div class="wit-content" /></section></div></section><section><p>in lo_ga : </p><div class="wit-content"><section><p>we want to construct an EqGa t a b; the only way to do that is to invoke a constructor of it, which it has only one; the output type of the constructor is EqGa t a a, but we need to create EqGa t a b; introducing (p : = EqGa t a) : refl is a (p a) but we want a (p b); but this is exactly the kind of tranlation that the logic inspired equality can perform [check its definition]</p><div class="wit-content" /></section><section><p>in the invokation of lo : i left its first few arguments [t a b] implicit</p><div class="wit-content" /></section></div></section></div></section></div></section></span></body></html>