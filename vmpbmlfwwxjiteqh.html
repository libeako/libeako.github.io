<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>contains less dependency</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">information technology</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="rmciseizvhdgclym.html">user interface</a></span><span class="wit-nav-item"><a href="oeyeaezscdudpssh.html">formal languages</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">software coding</a></span><span class="wit-nav-item"><a href="ftkadhwzfhvfbwnk.html">correct by construction</a></span><span class="wit-nav-item"><a href="brqzviybtynlulwl.html">avoiding dangers</a></span><span class="wit-nav-item"><a href="zxsbxwlppaypmpnn.html">functional programming</a></span><span class="wit-nav-item"><a href="rqeeitsvmgrogdjp.html">introduction</a></span><span class="wit-nav-item"><a href="xaxqaihzanoadfll.html">advantages</a></span><span class="wit-nav-item wit-nav-current-page">contains less dependency</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>in functional programming the amount of dependency in the code is an order of magnitude smaller than in imperative programming</p><div class="wit-content" /></section><section><p>reason</p><div class="wit-content"><section><p>in an imperative program the positions of mutations in the execution order is significant, moving a mutation in a procedure changes the meaning of whatever it changes place with; with other words : both the code before and after a mutation depend on the mutation relatively being where it is</p><div class="wit-content" /></section></div></section><section><p>consequences</p><div class="wit-content"><section><p>readability ease</p><div class="wit-content"><section><p>imagine that at a certain point in a procedure you want to know the value of a variable</p><div class="wit-content"><section><p>in an imperative environment you need to scan the entire part of the procedure before the point of interest to be sure you do not miss a mutation of that variable [and also do this same with the variables it depends on, transitively]</p><div class="wit-content" /></section><section><p>in a functional environment you only need to jump to the definition of the symbol and you know its value, because you know nothing changes</p><div class="wit-content" /></section></div></section></div></section><section><p>bug-resilience</p><div class="wit-content"><section><p>certain kinds of bugs [like not properly initializing a variable, performing a mutation too many times or earlier or later than correct] may not happen in a functional program</p><div class="wit-content" /></section></div></section><section><p>modularity</p><div class="wit-content"><section><p>dependencies make the code difficult to change, the structure of it rigid; in a functional program : definitions can be freely reordered, with surely knowing that it will not change the meaning of the program; functional programs are very modular compared to imperative programs, pure functions can easily be built from simple other functions, even complex existing functions can be easily fragmented into several simpler ones</p><div class="wit-content" /></section><section><p>i here quote from someone</p><div class="wit-content"><section><p>I learned programming plunging right into C , C++, Java. ... Of course, i was clueless. ... learning functional programming changed it all. ... one of my most vivid recollections of that time is my discovery of the power of simplicity. ... i realised in wonder that that beautiful and powerful world was constructed out of extremely simple pieces.</p><div class="wit-content" /></section><section><p><a href="https://jaortega.wordpress.com/2006/03/17/programmers-go-bananas/">link</a></p><div class="wit-content" /></section></div></section><section><p>this makes functional programming fun, the coder feels like he|she is playing with building blocks; hence functional programming deserves the shorter name &quot;fun programming&quot;</p><div class="wit-content" /></section><section><p>modularity improves hierarchicity</p><div class="wit-content"><section><p><a href="nxwwqhqhdzpldxms.html">i wrote an example of functional programming</a></p><div class="wit-content" /></section><section><p>this discussion builds on it</p><div class="wit-content" /></section><section><p>the dotproduct function sums the component-wise results</p><div class="wit-content" /></section><section><p>summing some values consists of starting from a default value and accumulating the values one-by-one</p><div class="wit-content" /></section><section><p>the dealing with the initial value is unavoidable because we need to handle the degenerate case (n = 0)</p><div class="wit-content" /></section><section><p>i claim the conceptual closeness of these : (+), 0</p><div class="wit-content"><section><p>these are 2 of the inputs of function &#39;fold&#39;</p><div class="wit-content"><section><p>the initial value [in our example : 0]</p><div class="wit-content" /></section><section><p>the combining function [in our example : (+)]</p><div class="wit-content" /></section></div></section><section><p>to better see why : imagine a change in requirement : the mathematicians may realize that the dotproduct function by definition should not sum but multiply the per-component values; then with the change of the combining function the initial value would have to change too [to 1, because the neutral value of multiplication is 1]</p><div class="wit-content" /></section></div></section><section><p>where are the (+) and the 0 in the code ?</p><div class="wit-content"><section><p>in the imperative version they are far from each other</p><div class="wit-content"><section><p>are almost in the opposing ends visually; more importantly : share only the highest level node in the syntax tree as ancestor</p><div class="wit-content" /></section></div></section><section><p>in the functional version they are right beside each other; they share a simple function application [fold 0 (+)]</p><div class="wit-content" /></section></div></section><section><p>as shown by the previous example : by &quot;hierarchicity&quot; i mean that conceptually close pieces of the code are close to each other in the syntax tree too; this increases readability, bug-resilience, especially in the maintenance phase of software development</p><div class="wit-content"><section><p>in the imperative code it is easy to change (+) to (*) and forget to change the initial value too from 0 to 1</p><div class="wit-content" /></section></div></section></div></section></div></section></div></section></span></body></html>