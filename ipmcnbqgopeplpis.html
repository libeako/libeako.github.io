<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>genericity healthily constrains implementation</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="nnsmzqwudqobukpt.html">fund</a></span><span class="wit-nav-item"><a href="aacixgsdjlspuizr.html">derivation system</a></span><span class="wit-nav-item"><a href="hoqxwlarqggqsrwp.html">type</a></span><span class="wit-nav-item"><a href="qkpkvuxwtzdigyud.html">parametricity</a></span><span class="wit-nav-item"><a href="iuvbupavbjmhfrxj.html">of type inputs</a></span><span class="wit-nav-item wit-nav-current-page">genericity healthily constrains implementation</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>a duality exists between the interface and implementation of a thing; the more the type of the thing provides [more genericity] [more use-cases] the more difficult to implement the thing is [less ways exist to implement], and vice versa</p><div class="wit-content" /></section><section><p>a benefit of less ways to implement a function is less opportunity to make mistake in the implementation, that is: less bugs; mine and many other programmers&#39; practical experience is that genericity usually leads the implementation towards the sensible one; this implies that genericity is a tool in combating bugs; on the other side: type parameters are very cheap; hence i recommend coders to not avoid any type parameters that feel natural</p><div class="wit-content" /></section><section><p>a very simple introductory example</p><div class="wit-content"><section><p>the task is to write a function that swaps the components of a homogeneous pair</p><div class="wit-content" /></section><section><p>solution</p><div class="wit-content"><section><p>swap : t t -&gt; t t</p><div class="wit-content" /></section><section><p>swap (v1, v2) = (v2, v1)</p><div class="wit-content" /></section></div></section><section><p>some bugs are possible that the type-checker can not detect</p><div class="wit-content"><section><p>swap (v1, v2) = (v1, v2)  -- forget to swap</p><div class="wit-content" /></section><section><p>swap (v1, v2) = (v1, v1)  -- copy-paste then rewrite only a portion of the parts</p><div class="wit-content" /></section></div></section><section><p>my recommendation in this example would be to allow heterogeneous pairs</p><div class="wit-content"><section><p>swap : x y -&gt; y x</p><div class="wit-content" /></section><section><p>swap (v1, v2) = (v2, v1)</p><div class="wit-content" /></section><section><p>only the type is different, it is more general; the implementation is the same; with this type the type-checker does not let the coder make the bugs described earlier</p><div class="wit-content" /></section></div></section></div></section><section><p>a similar simple example</p><div class="wit-content"><section><p>the task is to write a function that composes 2 given functions</p><div class="wit-content" /></section><section><p>non-general solution</p><div class="wit-content"><section><p>compose : (t -&gt; t) -&gt; (t -&gt; t) -&gt; (t -&gt; t)</p><div class="wit-content" /></section><section><p>compose (a, b) = λ x -&gt; b (a x)</p><div class="wit-content" /></section><section><p>what is the order of the input functions in the output composition? it is hidden in the implementation, perhaps a comment for the function would contain this information, but that can easily be omitted or incorrect</p><div class="wit-content" /></section></div></section><section><p>general solution</p><div class="wit-content"><section><p>compose : (x -&gt; y) -&gt; (y -&gt; z) -&gt; (x -&gt; z)</p><div class="wit-content" /></section><section><p>compose (a, b) = λ x -&gt; b (a x)</p><div class="wit-content" /></section><section><p>only the type of the function is different; this more general type constrains the order of the functions in the composition, making the comment unnecessary and eliminating the possible error of mismatch between the comment and the implementation</p><div class="wit-content" /></section></div></section></div></section><section><p><a href="ogxjrjwmhpamaeme.html">&quot;maybe&quot; a solution for boolean blindness</a></p><div class="wit-content" /></section></span></body></html>