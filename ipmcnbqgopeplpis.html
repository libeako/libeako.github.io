<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>genericity as paradigm</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="nnsmzqwudqobukpt.html">fund</a></span><span class="wit-nav-item"><a href="hssphyjgxuopzugc.html">programming</a></span><span class="wit-nav-item"><a href="ojacvrgwoybrmynk.html">type system</a></span><span class="wit-nav-item"><a href="iuvbupavbjmhfrxj.html">parametric type polymorphism</a></span><span class="wit-nav-item"><a href="kmzluqnwmjudyuht.html">introduction</a></span><span class="wit-nav-item wit-nav-current-page">genericity as paradigm</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>a duality exists between the interface and implementation of a function; the more the type of a function provides [more genericity] [more use-cases] the more difficult to implement the function is [less ways exist to implement], and vice versa</p><div class="wit-content" /></section><section><p>a benefit of less ways to implement a function is less opportunity to make mistake in the implementation, that is : less bugs; mine and many other programmers&#39; practical experience is that genericity usually leads the implementation towards the sensible one; this implies that genericity is a tool in combating bugs [in addition to combating code repetition]; the current most popular view is : do not be more abstract than necessary, because abstraction has its cost [for example difficulty of understanding]; genericity as paradigm says : yes, it is more difficult to be more abstract, but this extra difficulty is spent against bugs and in that is more efficient then the replaced amount of test-debug-loop, hence the coder should aim for maximal genericity even if that amount of genericity is not promptly needed otherwise</p><div class="wit-content" /></section><section><p>a very simple introductory example</p><div class="wit-content"><section><p>the task is to write a function that swaps the components of a homogeneous pair</p><div class="wit-content" /></section><section><p>solution</p><div class="wit-content"><section><p>swap : t t -&gt; t t swap (v1, v2) = (v2, v1)</p><div class="wit-content" /></section></div></section><section><p>some bugs are possible that the compiler can not detect</p><div class="wit-content"><section><p>swap (v1, v2) = (v1, v2)  -- forget to swap</p><div class="wit-content" /></section><section><p>swap (v1, v2) = (v1, v1)  -- one of the component pushes out the other</p><div class="wit-content" /></section></div></section><section><p>genericity as paradigm says in this example to allow heterogeneous pairs</p><div class="wit-content"><section><p>swap : x y -&gt; y x swap (v1, v2) = (v2, v1)</p><div class="wit-content" /></section><section><p>only the type is different, it is more general, the implementation is the same; with this type the compiler does not let the coder make the bugs mentioned earlier</p><div class="wit-content" /></section></div></section></div></section><section><p>a similar simple example</p><div class="wit-content"><section><p>the task is to write a function that composes 2 given functions</p><div class="wit-content" /></section><section><p>non-general solution</p><div class="wit-content"><section><p>compose : (t -&gt; t) (t -&gt; t) -&gt; (t -&gt; t)</p><div class="wit-content" /></section><section><p>compose (a, b) = λ x -&gt; b (a x)</p><div class="wit-content" /></section><section><p>what is the order of the input functions in the output composition? it is hidden in the implementation, perhaps a comment for the function would contain this information</p><div class="wit-content" /></section></div></section><section><p>general solution</p><div class="wit-content"><section><p>compose : (x -&gt; y) (y -&gt; z) -&gt; (x -&gt; z)</p><div class="wit-content" /></section><section><p>compose (a, b) = λ x -&gt; b (a x)</p><div class="wit-content" /></section><section><p>only the type of the function is different; this more general type constrains the order of the functions in the composition, making the comment unnecessary and eliminating the possible error of mismatch between the comment and the implementation</p><div class="wit-content" /></section></div></section></div></section></span></body></html>