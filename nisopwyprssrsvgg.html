<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>naturality</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="oibaxnylzhpktgho.html">algebra</a></span><span class="wit-nav-item"><a href="nfoegqpcgzhctwbv.html">magma</a></span><span class="wit-nav-item"><a href="eovnsnrjngyuihhx.html">semigroup</a></span><span class="wit-nav-item"><a href="cabjryjnnstdjmvb.html">monoid</a></span><span class="wit-nav-item"><a href="edsabrzmtmhnwgml.html">category</a></span><span class="wit-nav-item"><a href="yboclzmzvuwqxcdt.html">functor</a></span><span class="wit-nav-item wit-nav-current-page">naturality</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p><a href="https://en.wikipedia.org/wiki/Natural_transformation">link to natural transformation</a></p><div class="wit-content" /></section><section><p>natural transformation and natural isomorphism are very important notions in mathematics and software coding; they are defined by many sources on the web; but intuition behind them is not well explained; this part tries to fill this gap</p><div class="wit-content" /></section><section><p>functor</p><div class="wit-content"><section><p>naturality builds on the notion of</p><div class="wit-content"><section><p><a href="yboclzmzvuwqxcdt.html">functor</a></p><div class="wit-content" /></section></div></section><section><p>a little remembering about functors</p><div class="wit-content"><section><p>mathemticians probably like to think about them as mathematical constructions; i [as a programmer] like to think about them as data structures, more concretely &quot;collection&quot; types</p><div class="wit-content" /></section><section><p>the choice of the type of data the collection holds corresponds to the choice of the object in the target category of the functor; thus a collection type can contain any type of data [&quot;content&quot;]; but the &quot;structure&quot; of it is fixed by the type of the collection, that is by the functor</p><div class="wit-content" /></section></div></section></div></section><section><p>the intuition</p><div class="wit-content"><section><p>a simple example of collection type [functor] is homogeneous pair [X X]; let us move to heterogeneous pairs [X Y]; this has 2 element-type parameters, thus it can not be a functor technically; but if we fix one of them then only one varying parameter is left and such pair data construction is a functor; thus X C is a functor in X for all constant choice of C</p><div class="wit-content" /></section><section><p>and obviously so is C X; X C and C X are not the same functors; they feel like they are the same, but they are not; they are only isomorphic to each other</p><div class="wit-content" /></section><section><p>can you think of an invertible function that witnesses this isomorphism? of course, it is trivial; here is the fun part : i know which one you think of : the one that reverses the component order in the pair structure; how do i know? it is a &quot;natural&quot; choice and in this particular example it is the only choice; you was constrained by not knowing what X and C concretely are; you only knew the structures of the collections, thus you could come up only with a solution that relates the structures, independently of what the contents are; this independence is the &quot;naturality&quot; property of the isomorphism between X*C and C*X</p><div class="wit-content" /></section><section><p>the word &quot;independence&quot; is not rigorous enough for a mathematical definition; hence i here try to make it more mathematically rigorous; a first rephrase : 2 aspects are independent if both of them can freely vary without interfering with the other; the word &quot;interfere&quot; is still far from rigor; for further development of rigor : i use a concrete example : threads in computer programs; the scheduling of threading is non-deterministic, thus from the programmer&#39;s point of view : 2 threads do not interfere with each other iff they produce correct results|effects for all possible scheduling; to decide this is a too difficult task for the programmer, hence an equivalent but much easier to decide phrasing is used : iff for any 2 atomic instructions {i1, i2}, taken from different threads : their execution order relative to each other does not matter, that is iff i1;i2 has the same behavior as i2;i1; this is the intuition, the key in this introduction of mine to natural transformations; we can translate this picture to mathematics by thinking about the [atomic] instructions as endo-functions on the state-space of the program; then the condition is : iff the [function-]composition of state-space-mutating-functions [of different threads] is commutative; and this is exactly what the definition of natural isomorphism says with its commutative diagram : 2 changes of the 2 different aspects [(transition between objects inside category | moving along an arrow between the objects) and (transition between the functors | moving along the natural transformation)], may happen in any order, the result must be the same; to further support the intuition : go back to the (functor as data structure) view; in it naturality says : it does not matter if (we change the content first and then the structure) or (we change the structure first and then the content); more concretely in my previous heterogeneous pair example : it does not matter if (we change the content of the &quot;X&quot; component of the pair first and then the order of the 2 components) or (we change the order of the 2 components first and then the content of the &quot;X&quot; component)</p><div class="wit-content" /></section></div></section><section><p>natural { transformation | isomorphism }</p><div class="wit-content"><section><p>naturality in &quot;natural transformation&quot; and &quot;natural isomorphism&quot; is the same property; the difference between the 2 notion is in the components of them : a transformation is any function, an isomorphism must be invertible</p><div class="wit-content" /></section></div></section><section><p>in software coding</p><div class="wit-content"><section><p>in programming naturality happens naturally, by which i mean : without any direct effort by the programmer; by the phenomena which in programming is named &quot; parametricity&quot;, which means that the value of a type-polymorphic value [for example the behavior of a type-polymorphic function] is uniform for all concrete instantiations of its type-variable; parametricity implies certain mathematical properties of all the values of a type; the derivation of such properties is done based on the type only, hence they are named free theorems; in particular naturality conditions in category theory are free theorems in programming</p><div class="wit-content"><section><p><a href="iuvbupavbjmhfrxj.html">link to parametricity</a></p><div class="wit-content" /></section><section><p><a href="ejqpvlbcoexibqku.html">free theorem</a></p><div class="wit-content" /></section></div></section><section><p>i will illustrate this on the example of natural transformation itself</p><div class="wit-content"><section><p>the type of a natural transformation in a haskell-like programming language is as follows </p><div class="wit-content"><section><p>NT (F : Functor) (G : Functor) = forall X . F X -&gt; G X</p><div class="wit-content" /></section><section><p>&quot;NT&quot; is short of &quot;natural transformation&quot;</p><div class="wit-content" /></section><section><p>you may be confused now, because this type seems not contain anything resebling the commutativity condition which is essential in the category theoretical definition of natural transformation; but it is in it; in &quot;forall X&quot;; the type is parametric in X; assuming parametricity : the commutativity condition is a free theorem of this type</p><div class="wit-content" /></section></div></section><section><p>derivation of the commutativity condition of natural transformation as free theorem</p><div class="wit-content"><section><p>by wadler&#39;s method we get</p><div class="wit-content" /></section><section><p>forall X1, X2 : Type</p><div class="wit-content" /></section><section><p>forall f : X1 -&gt; X2</p><div class="wit-content" /></section><section><p>forall nt1 : F X1 -&gt; G X1</p><div class="wit-content" /></section><section><p>forall nt2 : F X2 -&gt; G X2</p><div class="wit-content" /></section><section><p>forall fx1 : F X1</p><div class="wit-content" /></section><section><p>forall fx2 : F X2 </p><div class="wit-content" /></section><section><p>(related fx1 fx2) =&gt; (related (nt1 fx1) (nt2 fx2))</p><div class="wit-content" /></section><section><p>this contains relation statements about functor values; i need to translate these to relation statements on their base types; this can be done by using the logical relation corresponding to functors</p><div class="wit-content"><section><p><a href="wqbrusvmsxteurms.html">link to &#39;parametric equaivalence of functors&#39;</a></p><div class="wit-content" /></section></div></section><section><p>forall X1, X2 : Type</p><div class="wit-content" /></section><section><p>forall f : X1 -&gt; X2</p><div class="wit-content" /></section><section><p>forall nt1 : F X1 -&gt; G X1</p><div class="wit-content" /></section><section><p>forall nt2 : F X2 -&gt; G X2</p><div class="wit-content" /></section><section><p>forall fx1 : F X1</p><div class="wit-content" /></section><section><p>forall fx2 : F X2</p><div class="wit-content" /></section><section><p>(map f fx1 = fx2) =&gt; (map f (nt1 fx1) = nt2 fx2)</p><div class="wit-content" /></section><section><p>the last line is an implication</p><div class="wit-content" /></section><section><p>i choose fx2 := map f fx1</p><div class="wit-content" /></section><section><p>this makes the premise of the implication true; hence i can drop it</p><div class="wit-content" /></section><section><p>forall X1, X2 : Type</p><div class="wit-content" /></section><section><p>forall f : X1 -&gt; X2</p><div class="wit-content" /></section><section><p>forall nt1 : F X1 -&gt; G X1</p><div class="wit-content" /></section><section><p>forall nt2 : F X2 -&gt; G X2</p><div class="wit-content" /></section><section><p>forall fx1 : F X1</p><div class="wit-content" /></section><section><p>map f (nt1 fx1) = nt2 (map f fx1)</p><div class="wit-content" /></section><section><p>making it point-free:</p><div class="wit-content" /></section><section><p>forall X1, X2 : Type</p><div class="wit-content" /></section><section><p>forall f : X1 -&gt; X2</p><div class="wit-content" /></section><section><p>forall nt1 : F X1 -&gt; G X1</p><div class="wit-content" /></section><section><p>forall nt2 : F X2 -&gt; G X2</p><div class="wit-content" /></section><section><p>(map f &lt;&lt;&lt; nt1) = (nt2 &lt;&lt;&lt; map f)</p><div class="wit-content" /></section><section><p>unifying with the choice nt1 = nt2 [= nt]:</p><div class="wit-content" /></section><section><p>forall X1, X2 : Type</p><div class="wit-content" /></section><section><p>forall f : X1 -&gt; X2</p><div class="wit-content" /></section><section><p>forall nt : F X1 -&gt; G X1</p><div class="wit-content" /></section><section><p>(map f &lt;&lt;&lt; nt) = (nt &lt;&lt;&lt; map f)</p><div class="wit-content" /></section><section><p>this is the commutativity property i wanted to prove</p><div class="wit-content" /></section></div></section><section><p>this theorem can be used for automatic runtime-efficiency improvement</p><div class="wit-content" /></section></div></section></div></section></span></body></html>