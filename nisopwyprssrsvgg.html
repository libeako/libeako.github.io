<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>naturality</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="oibaxnylzhpktgho.html">algebra</a></span><span class="wit-nav-item"><a href="nfoegqpcgzhctwbv.html">magma</a></span><span class="wit-nav-item"><a href="eovnsnrjngyuihhx.html">semigroup</a></span><span class="wit-nav-item"><a href="cabjryjnnstdjmvb.html">monoid</a></span><span class="wit-nav-item"><a href="edsabrzmtmhnwgml.html">category</a></span><span class="wit-nav-item"><a href="yboclzmzvuwqxcdt.html">functor</a></span><span class="wit-nav-item wit-nav-current-page">naturality</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p><a href="https://en.wikipedia.org/wiki/Natural_transformation">on Wikipedia</a></p><div class="wit-content" /></section><section><p>natural transformation and natural isomorphism are important notions in mathematics; many pages on the web define it, but do not give intuition; this part tries to do that</p><div class="wit-content" /></section><section><p>the intuition from functor as data structure</p><div class="wit-content"><section><p>the type of natural transformations in code is</p><div class="wit-content"><section><p>(Functor f, Functor g) =&gt; forall x . f x -&gt; g x</p><div class="wit-content" /></section></div></section><section><p>a simple example of functor is pairs with one of the component type fixed [X*C, C*X]</p><div class="wit-content" /></section><section><p>X*C and C*X are not the same functors; but they are isomorphic</p><div class="wit-content" /></section><section><p>can you think of an invertible function that witnesses this isomorphism? of course, it is trivial; here is the fun part: i know which one you think of: the one that reverses the component order in the pair structure; how do i know? in this particular example this is the only natural choice; a &quot;natural&quot; solution does not inspect the type variable [X] and does not branch on it, but works the same way for all values of it</p><div class="wit-content" /></section><section><p>this &#39;does not branch on the type&#39; in type theory is known as </p><div class="wit-content"><section><p><a href="ejqpvlbcoexibqku.html">parametricity</a></p><div class="wit-content" /></section></div></section><section><p>also the content of a functor can be changed with keeping the structure</p><div class="wit-content"><section><p><a href="yboclzmzvuwqxcdt.html">see explanation</a></p><div class="wit-content" /></section></div></section><section><p>both the structure and the content of a functor can be changed without disturbing the other; this is equivalent to the order of such transformations not mattering; it does not matter if (we change the content of the &quot;X&quot; component of the pair first and then the order of the 2 components) or (we change the order of the 2 components first and then the content of the &quot;X&quot; component)</p><div class="wit-content" /></section><section><p>more generally: naturality says: it does not matter if (we change the content first and then the structure) or (we change the structure first and then the content)</p><div class="wit-content" /></section><section><p>this is exactly what the definition of natural isomorphism says with its commuting: </p><div class="wit-content" /></section><section><p>2 changes of the 2 different aspects</p><div class="wit-content"><section><p>transition between objects inside category [moving along an arrow between the objects]</p><div class="wit-content" /></section><section><p>transition between the functors [moving along the natural transformation]</p><div class="wit-content" /></section></div></section><section><p>may happen in any order, the result is the same</p><div class="wit-content" /></section></div></section><section><p>natural { transformation | isomorphism }</p><div class="wit-content"><section><p>naturality in &quot;natural transformation&quot; and &quot;natural isomorphism&quot; is the same property; the difference between the 2 notion is in the components of them: a transformation is any function, an isomorphism must be invertible</p><div class="wit-content" /></section></div></section><section><p>parametricity of the content type implies naturality of transformations between functors</p><div class="wit-content"><section><p>functions with the type</p><div class="wit-content"><section><p>(Functor F, Functor G) =&gt; forall x . F x -&gt; G x</p><div class="wit-content" /></section></div></section><section><p>are parametric in x, hence are natural transformations</p><div class="wit-content" /></section><section><p>vague proof</p><div class="wit-content"><section><p>by Wadler&#39;s method we get</p><div class="wit-content"><section><p>forall X1, X2 : Type</p><div class="wit-content"><section><p>forall f : X1 -&gt; X2</p><div class="wit-content" /></section><section><p>forall nt1 : F X1 -&gt; G X1</p><div class="wit-content" /></section><section><p>forall nt2 : F X2 -&gt; G X2</p><div class="wit-content" /></section><section><p>forall fx1 : F X1</p><div class="wit-content" /></section><section><p>forall fx2 : F X2 </p><div class="wit-content"><section><p>(related fx1 fx2) =&gt; (related (nt1 fx1) (nt2 fx2))</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>this contains relation statements about functor values; i need to translate these to relation statements on their content types; this can be done by using</p><div class="wit-content"><section><p><a href="wqbrusvmsxteurms.html">the parametricity relation corresponding to functors</a></p><div class="wit-content" /></section><section><p>forall X1, X2 : Type</p><div class="wit-content"><section><p>forall f : X1 -&gt; X2</p><div class="wit-content" /></section><section><p>forall nt1 : F X1 -&gt; G X1</p><div class="wit-content" /></section><section><p>forall nt2 : F X2 -&gt; G X2</p><div class="wit-content" /></section><section><p>forall fx1 : F X1</p><div class="wit-content" /></section><section><p>forall fx2 : F X2</p><div class="wit-content"><section><p>(map f fx1 = fx2) =&gt; (map f (nt1 fx1) = nt2 fx2)</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>the last line is an implication</p><div class="wit-content" /></section><section><p>i choose</p><div class="wit-content"><section><p>fx2 := map f fx1</p><div class="wit-content" /></section></div></section><section><p>this makes the premise of the implication true; hence i can drop it</p><div class="wit-content"><section><p>forall X1, X2 : Type</p><div class="wit-content"><section><p>forall f : X1 -&gt; X2</p><div class="wit-content" /></section><section><p>forall nt1 : F X1 -&gt; G X1</p><div class="wit-content" /></section><section><p>forall nt2 : F X2 -&gt; G X2</p><div class="wit-content" /></section><section><p>forall fx1 : F X1</p><div class="wit-content"><section><p>map f (nt1 fx1) = nt2 (map f fx1)</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>making it point-free</p><div class="wit-content"><section><p>forall X1, X2 : Type</p><div class="wit-content"><section><p>forall f : X1 -&gt; X2</p><div class="wit-content" /></section><section><p>forall nt1 : F X1 -&gt; G X1</p><div class="wit-content" /></section><section><p>forall nt2 : F X2 -&gt; G X2</p><div class="wit-content"><section><p>(map f &lt;&lt;&lt; nt1) = (nt2 &lt;&lt;&lt; map f)</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>unifying with the choice nt1 = nt2 [= nt]</p><div class="wit-content"><section><p>forall X1, X2 : Type</p><div class="wit-content"><section><p>forall f : X1 -&gt; X2</p><div class="wit-content" /></section><section><p>forall nt : F X1 -&gt; G X1</p><div class="wit-content"><section><p>(map f &lt;&lt;&lt; nt) = (nt &lt;&lt;&lt; map f)</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>this is the commutativity property i wanted to prove</p><div class="wit-content" /></section></div></section></div></section></span></body></html>