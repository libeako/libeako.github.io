<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>type classes</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="nnsmzqwudqobukpt.html">fund</a></span><span class="wit-nav-item"><a href="znuvgowivqvqbdhr.html">language</a></span><span class="wit-nav-item"><a href="jaxbiyrfnbhaormb.html">general language</a></span><span class="wit-nav-item wit-nav-current-page">type classes</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>type classes are type interfaces that use static method dispatch</p><div class="wit-content"><section><p>this is the difference from the object-oriented type-interface solution</p><div class="wit-content" /></section></div></section><section><p>type classes is a langauge feature that does not make any additional type of abstractions possible but they give extra convenience</p><div class="wit-content" /></section><section><p>type classes are very popular and it looks that in the future they will be part of most languages</p><div class="wit-content" /></section><section><p>type classes were introduced by the Haskell language and Haskell always remained to be the testbed for new research in this topic and to have the best current implementation</p><div class="wit-content" /></section><section><p>the name can be &quot;type class&quot; or &quot;type interface&quot;, depending on the mood of the language designer</p><div class="wit-content"><section><p>Haskell chose &quot;class&quot;, Idris chose &quot;interface&quot;</p><div class="wit-content" /></section></div></section><section><p>basics of type interface definition</p><div class="wit-content"><section><p>interface Equatable t where </p><div class="wit-content"><section><p>(==) : t -&gt; t -&gt; Bool</p><div class="wit-content" /></section></div></section><section><p>&quot;interface&quot; is a keyword here</p><div class="wit-content"><section><p>Haskell uses the &quot;class&quot; keyword</p><div class="wit-content" /></section><section><p>Idris uses the &quot;interface&quot; keyword</p><div class="wit-content" /></section></div></section><section><p>&quot;Equatable&quot; is the name of the defined type interface</p><div class="wit-content" /></section><section><p>&quot;where&quot; is a keyword separating the header from the rest of the code</p><div class="wit-content" /></section><section><p>the rest of the lines lists the methods of the interface</p><div class="wit-content" /></section><section><p>in static type interfacing we do not have the implicit input story; all the inputs are explicit and we must declare their types too</p><div class="wit-content" /></section><section><p>the language specification could fix the name of the type that is to implement the interface being defined [to &quot;This&quot; or &quot;Self&quot;, for example], but Haskell-like languages usually choose to let the coder choose a custom name instead; this syntax design decision makes us able</p><div class="wit-content"><section><p>to use short, usually 1-letter names, to make the structures of the types of the methods more readable</p><div class="wit-content" /></section><section><p>to have multi-type interfaces [where the interface is not of a single type but a combination of multiple types]</p><div class="wit-content"><section><p>the usefulness of this ability is doubtful</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>multiple methods in an interface:</p><div class="wit-content"><section><p>interface Equatable t</p><div class="wit-content"><section><p>(==) : t -&gt; t -&gt; bool</p><div class="wit-content" /></section><section><p>(/=) : t -&gt; t -&gt; bool</p><div class="wit-content" /></section></div></section></div></section><section><p>default method implementations</p><div class="wit-content"><section><p>interface Equatable t</p><div class="wit-content"><section><p>(==) : t -&gt; t -&gt; bool</p><div class="wit-content" /></section><section><p>(/=) : t -&gt; t -&gt; bool</p><div class="wit-content" /></section><section><p>x == y = not (x /= y)</p><div class="wit-content" /></section><section><p>x /= y = not (x == y)</p><div class="wit-content" /></section></div></section><section><p>even mutually recursively</p><div class="wit-content" /></section></div></section><section><p>an &quot;instance&quot; of a type interface is an implementation of a type interface for a given type</p><div class="wit-content"><section><p>a simple example:</p><div class="wit-content"><section><p>implements Equatable Int</p><div class="wit-content"><section><p>(==) = Integer.equality</p><div class="wit-content" /></section></div></section><section><p>&quot;instance&quot; is a keyword here</p><div class="wit-content" /></section><section><p>(==) of &#39;Equatable&#39; is defined by this implementation as the equation test provided by module &#39;Integer&#39;</p><div class="wit-content" /></section><section><p>(/=) [not equal] does not have to be implemented, because the &#39;Equatable&#39; class contains a suitable default implementation of it</p><div class="wit-content" /></section></div></section><section><p>the independence of the instance</p><div class="wit-content"><section><p>the code of the instance can be either in the module of the class or in the module of the type; hence new instances can be introduced both for types and for classes whose code can not be modified</p><div class="wit-content" /></section><section><p>when the code of both the class and the type is not modifiable then an instance for them can not be defined directly; in such case the solution is to wrap the type with a new type</p><div class="wit-content" /></section></div></section><section><p>instance conditioning</p><div class="wit-content"><section><p>example</p><div class="wit-content"><section><p>instance (Equatable a, Equatable b) =&gt; Equatable (a b) where</p><div class="wit-content"><section><p>(x1, y1) == (x2, y2) = x1 == x2 &amp;&amp; y1 == y2</p><div class="wit-content" /></section></div></section></div></section><section><p>at the source side of the fat arrow is the condition</p><div class="wit-content" /></section></div></section></div></section><section><p>usage</p><div class="wit-content"><section><p>functions may take instances as implicit inputs</p><div class="wit-content" /></section><section><p>example</p><div class="wit-content"><section><p>minimum : Ordered e =&gt; List e -&gt; Maybe e</p><div class="wit-content"><section><p>takes an implicit parameter specifying how interface &#39;Ordered&#39; is implemented for type &#39;e&#39;</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>laws</p><div class="wit-content"><section><p>&quot;laws&quot; are requirements that the instances must obey; additional to what the types of the methods of the interface impose; it is generally better to state requirements in types, but sometimes (because of the weakness of the type system) it is not possible or not economical; then we state them in comment and refer to them as &quot;laws&quot;</p><div class="wit-content" /></section><section><p>example</p><div class="wit-content"><section><p>the laws of &#39;Equatable&#39; should be the usual mathematical properties of equality: substitutivity</p><div class="wit-content" /></section><section><p>interface Equatable t where</p><div class="wit-content"><section><p>(==) : t -&gt; t -&gt; Bool</p><div class="wit-content"><section><p>// law &quot;substitutivity&quot;: x == y &lt;=&gt; (for all f : f x == f y)</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>not all interfaces have to have laws</p><div class="wit-content"><section><p>some examples for interfaces that do not have laws</p><div class="wit-content"><section><p>Default</p><div class="wit-content" /></section><section><p>Foldable</p><div class="wit-content"><section><p>you may know this from .Net as &quot;Enumerable&quot;</p><div class="wit-content" /></section></div></section></div></section></div></section></div></section></span></body></html>