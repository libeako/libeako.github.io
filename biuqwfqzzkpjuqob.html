<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>type classes</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">coding</a></span><span class="wit-nav-item"><a href="jaxbiyrfnbhaormb.html">some basic prog lang notions</a></span><span class="wit-nav-item wit-nav-current-page">type classes</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>type classes are type interfaces that use static method dispatch</p><div class="wit-content" /></section><section><p>type classes do not increase the expressive power of the type system; but they still save us from some repetitions and they generally give extra convenience</p><div class="wit-content" /></section><section><p>type classes are very popular and it looks that in the future they will be part of most well designed programming languages</p><div class="wit-content" /></section><section><p>type classes were introduced by the haskell programming language and haskell always remained to be the testbed for new research in this topic; lately popular industrial languages also started to adopt it: c++&#39;s &quot;concept&quot;s and rust&#39;s &quot;traits&quot; are type classes under other names </p><div class="wit-content" /></section><section><p>the name</p><div class="wit-content"><section><p>from the name &quot;type classes&quot;: do not try to extract accurate meaning, it is just one name, that happened to be chosen but is not distinctive</p><div class="wit-content" /></section><section><p>in Idris the name &quot;type interface&quot; is used; i may also use &quot;interface&quot; instead of &quot;class&quot;</p><div class="wit-content" /></section></div></section><section><p>no dynamic dispatch language feature</p><div class="wit-content"><section><p>half of the &quot;object oriented&quot; paradigm is its type interfacing solution; the main difference between that and haskell-like type-classes is that in OO methods are dispatched in run-time [&quot;dynamically&quot;]</p><div class="wit-content" /></section><section><p>haskell-like languages do not provide dedicated support for dynamic type interfacing</p><div class="wit-content" /></section><section><p>they provide other language features [existential types] with which dynamic dispatch can be implemented, in case it is needed, with only slightly more verbosity than in OO languages</p><div class="wit-content" /></section><section><p>dynamic method dispatch is needed very rarely</p><div class="wit-content" /></section><section><p>this may surprise you, if you are used to object-oriented languages, like java and c#, which force the coder to use their type interfacing solution with dynamic dispatch machinery, even when simpler but not provided tools [like sum types or higher order functions] would suffice; when a coder gets to use a well-designed language, like haskell: then the coder quickly sees that dynamic method dispatch is needed very rarely</p><div class="wit-content" /></section></div></section><section><p>OO</p><div class="wit-content"><section><p>the type interface design in the OO paradigm is developed from the idea that the dispatch should be dynamic; dynamic dispatch queries the run-time type of the actual inputs of the invoked method to find the appropriate concrete function to invoke; the type of which inputs? so far as i know: the original OO idea was to use all the inputs for this; what happens when we do not have a method implementation matching the types of the actual inputs? run-time execution failure; that is okay for dynamically typed langauges, as the possibility of such run-time failure is normal for them anyway; but in a statically typed language it is questionable at least; hence some people did insist to try to fuse the 2: OO and static typing</p><div class="wit-content" /></section><section><p>let us walk through the way of their possible thinking; we have to ensure at compile time that dispatches are always successful; our best idea: restrict the dispatching to only 1 of the inputs; which one sould that be? for the sake of simplicity and uniformity: let it be the first one always; we do not need to know its type in compile time, as the core OO idea is to defer that to run-time; this input is always present and has special status, hence we can fix its name to &quot;this&quot; or &quot;self&quot; of it in the language specification; hence this input can be implicit - this saves the coder from some verbosity</p><div class="wit-content" /></section><section><p>it is important to see that this solution was not a conceptual desire but a compromise, accepting conceptual mismatch for the sake of type-safety; thus was the now popular [&quot;Java-like&quot;] version of OO born; as a child of the forced marriage of static typing and the inherently dynamic OO behavior; crippled from birth, it can not properly represent interface methods with multiple inputs with the same role; for example:</p><div class="wit-content" /></section><section><p>the Equatable interface in c#:</p><div class="wit-content"><section><p>interface IEquatable { bool Equals (??? other); }</p><div class="wit-content" /></section><section><p>what should go in place of &quot;???&quot;, what should the type of the &#39;other&#39; input be? OO itself does not give a type-safe answer; type-unsafety was accepted in this situation in the Java like languages for years</p><div class="wit-content" /></section><section><p>when later generics came into Java and .Net: it finally provided a type-safe solution via &quot;F-bounded quantification&quot;</p><div class="wit-content"><section><p>interface IEquatable&lt;T&gt; { bool Equals (T other); }</p><div class="wit-content" /></section><section><p>the name of the type that implements the interface is smuggled into the interface definition with type polymorphism</p><div class="wit-content" /></section><section><p>in practice this worked acceptably, but conceptually it is only a work-around</p><div class="wit-content" /></section></div></section><section><p>spend some seconds to observe that the above source-code suggests that the 2 inputs of the method are somehow differnt in their roles, which is false</p><div class="wit-content" /></section></div></section><section><p>the story is similar with the also important &#39;Comparable&#39; interface</p><div class="wit-content" /></section><section><p>i repeat: Java-like OO [distinguishing the first input of methods] is not some natural idea at the concept level; but a problematic technical necessity of integrating OO into static typing</p><div class="wit-content" /></section></div></section><section><p>fortunately: static typing may have type interfaces, without any OO too, with totally static method dispatch; not only it is possible, but it also lacks the problems of OO and has great advantages, as i will show</p><div class="wit-content" /></section><section><p>basics of type interface definition</p><div class="wit-content"><section><p>interface Equatable t where </p><div class="wit-content"><section><p>(==) : t -&gt; t -&gt; Bool</p><div class="wit-content" /></section></div></section><section><p>&quot;interface&quot; is a keyword here</p><div class="wit-content"><section><p>haskell uses the &quot;class&quot; keyword</p><div class="wit-content" /></section><section><p>idris uses the &quot;interface&quot; keyword</p><div class="wit-content" /></section></div></section><section><p>&quot;Equatable&quot; is the name of the defined type interface</p><div class="wit-content" /></section><section><p>&quot;where&quot; is a keyword separating the header from the rest of the definition</p><div class="wit-content" /></section><section><p>the rest of the lines lists the methods of the interface</p><div class="wit-content" /></section><section><p>in static type interfacing we do not have the implicit input story; all the inputs are explicit and we must declare their types too</p><div class="wit-content" /></section><section><p>the language specification could fix the name of the type that is to implement the interface being defined [to &quot;This&quot; or &quot;Self&quot;, for example], but Haskell-like languages usually choose to let the coder choose a custom name instead; this syntax design decision makes us able to use short, usually 1-letter names, to make the structures of the types of the methods more readable</p><div class="wit-content" /></section><section><p>in the above &#39;Equatable&#39; interface definition &quot;t&quot; is this name</p><div class="wit-content" /></section><section><p>having such name is not only a necessity; it also gives to us the ability to effortlessly express the fact that the 2 inputs of the equality checking method have the same type; we have type safety, naturally, without the use of parametric type-polymorphism</p><div class="wit-content" /></section><section><p>the above source-code of the &#39;Equatable&#39; interface perfectly mirrors the concept that it ought to rerpresent, including that the method&#39;s inputs have the same role</p><div class="wit-content" /></section></div></section><section><p>no run-time input to dispatch on</p><div class="wit-content"><section><p>such a situation is impossible to handle with OO, but with static dispatching it is not a problem</p><div class="wit-content" /></section><section><p>how common such situation arises? quite</p><div class="wit-content" /></section><section><p>the trivial case is when the method does not take any input at all, when it is not even a function, instead it just selects a value from the type</p><div class="wit-content" /></section><section><p>a trivial but useful example:</p><div class="wit-content" /></section><section><p>interface HasDefault t</p><div class="wit-content"><section><p>default : t</p><div class="wit-content" /></section></div></section><section><p>also: having some input does not make the method run-time dispatchable, because the input may be totally independent from the type that is to implement the interface; this is the case for example in methods of the very important Monoid, Applicative, Monad interfaces [which i am going to teach later]</p><div class="wit-content" /></section></div></section><section><p>multiple methods in an interface:</p><div class="wit-content"><section><p>interface Equatable t</p><div class="wit-content"><section><p>(==)   :   t -&gt; t -&gt; bool</p><div class="wit-content" /></section><section><p>(/=)   :   t -&gt; t -&gt; bool</p><div class="wit-content" /></section></div></section></div></section><section><p>default method implementations</p><div class="wit-content"><section><p>interface Equatable t</p><div class="wit-content"><section><p>(==)   :   t -&gt; t -&gt; bool</p><div class="wit-content" /></section><section><p>(/=)   :   t -&gt; t -&gt; bool</p><div class="wit-content" /></section><section><p>x == y   =   not (x /= y)</p><div class="wit-content" /></section><section><p>x /= y   =   not (x == y)</p><div class="wit-content" /></section></div></section><section><p>even mutually recursively</p><div class="wit-content" /></section></div></section><section><p>instances</p><div class="wit-content"><section><p>an &quot;instance&quot; of a type interface is an implementation of a type interface for a given type</p><div class="wit-content" /></section><section><p>a simple example:</p><div class="wit-content"><section><p>implements Equatable Int</p><div class="wit-content"><section><p>(==) = Integer.equality</p><div class="wit-content" /></section></div></section><section><p>&quot;instance&quot; is a keyword here</p><div class="wit-content" /></section><section><p>(==) of &#39;Equatable&#39; is defined by this implementation as the equation test provided by module &#39;Integer&#39;</p><div class="wit-content" /></section><section><p>(/=) [not equal] does not have to be implemented, because the definition of &#39;Equatable&#39; contains a suitable default implementation of it</p><div class="wit-content" /></section></div></section><section><p>independence from the type definition</p><div class="wit-content"><section><p>The definition of the instance is not fixed to the definition of the type; it can be also in the module of the interface; this makes it possible to implement new interfaces for types without modifying the definition of the type; in OO the set of interface implementations is fixed at the definition of the type</p><div class="wit-content" /></section></div></section><section><p>instance condition</p><div class="wit-content"><section><p>example</p><div class="wit-content"><section><p>instance (Equatable a, Equatable b) =&gt; Equatable (a b) where</p><div class="wit-content"><section><p>(x1, y1) == (x2, y2)   =   x1 == x2  &amp;&amp;  y1 == y2</p><div class="wit-content" /></section></div></section></div></section><section><p>at the source side of the fat arrow is the condition</p><div class="wit-content" /></section><section><p>this is a very important capability, because modifying a type by putting a container [Maybe, Either, List, newtype wrappers, ...] around it is ubiquitous in everyday software coding; OO can not do this</p><div class="wit-content" /></section></div></section></div></section><section><p>usage</p><div class="wit-content"><section><p>functions may take type interface implementations as implicit input</p><div class="wit-content" /></section><section><p>for example:</p><div class="wit-content"><section><p>minimum : Ordered e =&gt; List e -&gt; Maybe e</p><div class="wit-content" /></section><section><p>function &#39;minimum&#39; takes an implicit parameter specifying how type &#39;e&#39; implements interface &#39;Ordered&#39;</p><div class="wit-content" /></section></div></section></div></section><section><p>type methods</p><div class="wit-content"><section><p>an advantage of static dispatch is that the methods can output compile time information, including types; by this we associate types to types; in many languages such capability is known as &quot;associated types&quot;</p><div class="wit-content" /></section></div></section><section><p>run-time efficiency</p><div class="wit-content"><section><p>knowing the function to invoke in compile time makes the compiler able to inline it; this is a big gain, as inlining is a crucial optimization; OO languages force the dispatch to happen at run-time, which is in most cases not necessary; some people claim that these languages [Java, .Net] solve this run-time efficiency problem in the execution engine; but that is far from the truth; all that is in the execution engine is the prediction of which function will get the dispatch, based on previous dispatch results, and then inlining that function; this is close to being so fast as a compile time inlined invokation but works only if the dispatched result is the same in a big interval of time, which is only the simple cases</p><div class="wit-content" /></section></div></section><section><p>laws</p><div class="wit-content"><section><p>&quot;laws&quot; are often attached to type classes; they are addional requirements that the instances must obey; additional to what the types of the methods of the interface impose; it is generally better to state requirements in types, but sometimes [often because of the weakness of the type system] it is not possible or not economical; then we state them in comment and refer to them as &quot;laws&quot;</p><div class="wit-content" /></section><section><p>example:</p><div class="wit-content"><section><p>the laws of &#39;Equatable&#39; should be the usual mathematical properties of equality: substitutivity</p><div class="wit-content" /></section><section><p>interface Equatable t where</p><div class="wit-content"><section><p>(==) : t -&gt; t -&gt; Bool</p><div class="wit-content"><section><p>// law &quot;substitutivity&quot;: x == y &lt;=&gt; (for all f : f x == f y)</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>not all interfaces have to have laws</p><div class="wit-content"><section><p>some examples for interfaces that do not have laws:</p><div class="wit-content"><section><p>Default</p><div class="wit-content" /></section><section><p>Foldable</p><div class="wit-content"><section><p>you may know this as &quot;Enumerable&quot;</p><div class="wit-content" /></section></div></section></div></section></div></section></div></section></span></body></html>