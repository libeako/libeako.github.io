<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>the concrete representation</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">coding</a></span><span class="wit-nav-item"><a href="flktedmyhawaehus.html">abstractions from mathematics</a></span><span class="wit-nav-item"><a href="xmtpmaqybielrpxs.html">category theory</a></span><span class="wit-nav-item"><a href="ybwmxqdoenunvcsk.html">optics</a></span><span class="wit-nav-item"><a href="ndgkrnbojyputpec.html">introduction</a></span><span class="wit-nav-item wit-nav-current-page">the concrete representation</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>i implemented all the science in this part of the tutorial in haskell</p><div class="wit-content"><section><p><a href="https://bitbucket.org/libeako/haskell-fana/src/default/Haskell/Fana/Optic/Concreter/">link</a></p><div class="wit-content" /></section></div></section><section><p>laws</p><div class="wit-content"><section><p>i will express the laws via the accessors of the optic category under examination; for clarity : in the application of the accessor functions : i am going to omit the argument for the optic parameter [as it is the same optic value in the whole scope of the laws]</p><div class="wit-content" /></section></div></section><section><p>i will not show how composition works, because it is trivial or easy to figure out for all categories; but you should do figure them out for each category</p><div class="wit-content" /></section><section><p>subtyping</p><div class="wit-content"><section><p>i will talk about subtype relationships between optic categories; these are to be interpreted not technically, but conceptually, mathematically, as ((X is Y) = any X can be converted to an Y)</p><div class="wit-content" /></section><section><p>creating an optic for a multi-layer container is best done by creating an optic for each layer individually and compose them; however often the optics corresponding to different layers are from different optic categories and optics from different categories do not compose generally; one solution is to convert all the optics to be composed to a common supertype; hence subtype relationships between optic categories is important</p><div class="wit-content" /></section></div></section><section><p>some common categories :</p><div class="wit-content"><section><p>fold</p><div class="wit-content"><section><p>fold is a very simple optic category, it makes us able to query the elements of the container</p><div class="wit-content" /></section><section><p>let Fold e c = c -&gt; List e</p><div class="wit-content" /></section></div></section><section><p>get</p><div class="wit-content"><section><p>get is probably the simplest optic category of all; it is like fold, but the content must contain exactly 1 element</p><div class="wit-content" /></section><section><p>let Get e c = c -&gt; e</p><div class="wit-content" /></section><section><p>yepp, it is just a function</p><div class="wit-content" /></section><section><p>it supposes that the content is a single value</p><div class="wit-content" /></section><section><p>a common scenario of get is that the container is a product type and the content is the type of a certain data member of it; but the concept is more general; for example (is_negative : Integer -&gt; Bool), (length : List x -&gt; Integer) are also gets; any function can be regarded as a get</p><div class="wit-content" /></section></div></section><section><p>build</p><div class="wit-content"><section><p>build is an optic category, same as get but in the opposite direction; instead of querying the element from the container : it produces a container from an element</p><div class="wit-content" /></section><section><p>let Build e c = e -&gt; c</p><div class="wit-content" /></section><section><p>a common scenario is injecting a value in a sum type; for example (Right : r -&gt; Either l r) is a build</p><div class="wit-content" /></section><section><p>a more common name of build is &quot;review&quot;</p><div class="wit-content" /></section></div></section><section><p>pairing the directions</p><div class="wit-content"><section><p>we get certain other very useful optic categories by extending get or build with their opposite direction :</p><div class="wit-content" /></section><section><p>lens</p><div class="wit-content"><section><p>for product types :</p><div class="wit-content" /></section><section><p>let Lens e c = { get : c -&gt; e; set : e -&gt; c -&gt; c }</p><div class="wit-content" /></section><section><p>set is similar in purpose to build, but for product types; it can not build the container from an element alone, because the context is not necessarily empty; as a solution it has +1 input : an other value of the container, from which the context to be taken</p><div class="wit-content" /></section><section><p>the laws</p><div class="wit-content"><section><p>intuitively</p><div class="wit-content"><section><p>getting the content after setting it results in the same value that was set</p><div class="wit-content"><section><p>set e &gt;&gt;&gt; get = const e</p><div class="wit-content" /></section></div></section><section><p>setting the got content value results in the original container</p><div class="wit-content"><section><p>set (get c) c = c</p><div class="wit-content" /></section></div></section><section><p>setting twice is equivalent with setting the last time </p><div class="wit-content"><section><p>set something &gt;&gt;&gt; set at_last = set at_last</p><div class="wit-content" /></section></div></section></div></section><section><p>it is possible to derive the laws from the comonad concept</p><div class="wit-content"><section><p><a href="https://r6research.livejournal.com/23705.html">Lenses Are Exactly the Coalgebras for the Store Comonad </a></p><div class="wit-content" /></section></div></section></div></section><section><p>lens is a very widely used category of optic; so much that the first optic libraries for example in haskell had &quot;lens&quot; in their names and many people still use &quot;lens&quot; as a synonym of &quot;optic&quot; [ambiguously]; </p><div class="wit-content" /></section><section><p>the most straightforward scenario of lens is that it focuses from a product type to a member of that type</p><div class="wit-content"><section><p>examples</p><div class="wit-content"><section><p>second : Lens y (x y)</p><div class="wit-content" /></section><section><p>let KeyValuePair k v = { key : k, value : v } </p><div class="wit-content" /></section><section><p>key_in_kv_pair : Lens k (KeyValuePair k v)</p><div class="wit-content" /></section></div></section><section><p>such lenses are so frequent that we will often have a macro to help their creation</p><div class="wit-content" /></section></div></section></div></section><section><p>prism</p><div class="wit-content"><section><p>for sum types :</p><div class="wit-content" /></section><section><p>let Prism e c = { match : c -&gt; Maybe e; build : e -&gt; c }</p><div class="wit-content" /></section><section><p>match is the same as get, but the return value is in Maybe, because it does not necessarily exist</p><div class="wit-content" /></section><section><p>the laws</p><div class="wit-content"><section><p>if i build a container from a content and then match on that container then i get back the content from which i built the container</p><div class="wit-content"><section><p>build &gt;&gt;&gt; match = Just</p><div class="wit-content" /></section></div></section><section><p>if i match on a container and manage to get an element from it and then build a container from the found element then that new container will be the same as the old container</p><div class="wit-content"><section><p>fromMaybe c build (match c) = c</p><div class="wit-content"><section><p>where fromMaybe :: q -&gt; (p -&gt; q) -&gt; Maybe p -&gt; q</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>a more commmon name of match is &quot;preview&quot;</p><div class="wit-content" /></section></div></section></div></section><section><p>affine traversal</p><div class="wit-content"><section><p>often product and sum type constructions are mixed in a multilayer data structure; just think about algebraic datatypes and their ubiquity; hence the need to have an optic category which is a least general supertype of both lens and prism; with other words : we seek an optic category whose capability-set is the intersection of the capability-sets of lens and prism; from this specification : we can derive the representation of such an optic category by merging the representations of lens and prism so that we take the weaker one for each field</p><div class="wit-content" /></section><section><p>to recap : here are the data representations of lens and prism :</p><div class="wit-content"><section><p>datatype Lens e c = { get : c -&gt; e, set : e -&gt; c -&gt; c }</p><div class="wit-content" /></section><section><p>datatype Prism e c = { match : c -&gt; Maybe e, build : e -&gt; c }</p><div class="wit-content" /></section></div></section><section><p>the (container -&gt; content) direction is weaker in prism [it does not necessary return an existing content]; the (content -&gt; container) direction is weaker in lens [it requires an additional container]; hence</p><div class="wit-content"><section><p>let NewOpticCategory e c = { match : c -&gt; Maybe e, set : e -&gt; c -&gt; c }</p><div class="wit-content" /></section></div></section><section><p>the common name of this optic category is &quot;affine traversal&quot;</p><div class="wit-content" /></section><section><p>laws</p><div class="wit-content"><section><p>i am too lazy to think about them [for now]</p><div class="wit-content" /></section></div></section></div></section><section><p>isomorphism</p><div class="wit-content"><section><p>the technique for creating a new optic category learnt in the part about affine traversal can be used in the opposite order too : we may seek a new optic category whose capability-set is the union of the capability-sets of lens and prism</p><div class="wit-content" /></section><section><p>let NewOpticCategory e c = { get : c -&gt; e, build : e -&gt; c }</p><div class="wit-content" /></section><section><p>[supposing that these methods are inverses of each other :] this represents an isomorphism</p><div class="wit-content" /></section><section><p>an isomorphism represents the focus from some data to a possibly different representation of the same data; intuitively : we think about 2 types as isomorphic iff they represent the same information</p><div class="wit-content" /></section><section><p>laws</p><div class="wit-content"><section><p>the 2 functions in an isomorphism must be inverses of each other to represent real isomorphism between the 2 types given as parameters</p><div class="wit-content" /></section></div></section></div></section><section><p>lift</p><div class="wit-content"><section><p>the optic categories discussed till now treat the content as at most one element [with the exception of fold]; this is evidenced by their set and build functions, as they can reconstruct a container from just one element; if we want to treat the content as multiple element then what other functionality may we hope from the optic than just listing the elements? to transform the elements by a given function :</p><div class="wit-content" /></section><section><p>type NewOpticCategory e c = (e -&gt; e) -&gt; (c -&gt; c)</p><div class="wit-content" /></section><section><p>name</p><div class="wit-content"><section><p>the most common name is &quot;semantic editor combinator&quot;</p><div class="wit-content"><section><p><a href="http://conal.net/blog/posts/semantic-editor-combinators">it is coined by Conal Elliot</a></p><div class="wit-content" /></section><section><p>i think that the name &quot;semantic editor combinator&quot; is wierd and does not make sense to me</p><div class="wit-content" /></section></div></section><section><p>an other name is &quot;setter&quot;; i do not like this either because it collides with the set function of lens and they are not equivalent</p><div class="wit-content" /></section><section><p>other possible name is &quot;map&quot; or &quot;mapping&quot; or &quot;mapper&quot; or &quot;change&quot; or ... or &quot;lift&quot; or ...</p><div class="wit-content" /></section></div></section></div></section><section><p>traversal</p><div class="wit-content"><section><p>the simple lift [&quot;semantic editor combinator&quot;] can be upgraded to be able to lift effecty functions :</p><div class="wit-content" /></section><section><p>type NewOpticCategory e c = forall a . Applicative a =&gt; (e -&gt; a e) -&gt; (c -&gt; a c)</p><div class="wit-content" /></section><section><p>this is equivalent to the well known Traversable interface</p><div class="wit-content" /></section><section><p>if you do not know what interface Applicative is</p><div class="wit-content"><section><p><a href="kaxxmpbkqesnqecy.html">here is my introduction</a></p><div class="wit-content" /></section></div></section><section><p>laws</p><div class="wit-content"><section><p>same as of the Traversable interface</p><div class="wit-content"><section><p>traversal pure = pure</p><div class="wit-content" /></section><section><p>traversal f &gt;&gt;&gt; map (traversal g) = getCompose (traversal (g &gt;&gt;&gt; map f &gt;&gt;&gt; Compose))</p><div class="wit-content"><section><p>where : newtype Compose f g x = Compose { getCompose : g (f x) }</p><div class="wit-content" /></section></div></section></div></section></div></section></div></section></div></section><section><p><a href="zpvtqfvuyntejjdt.html">more about Lens</a></p><div class="wit-content" /></section></span></body></html>