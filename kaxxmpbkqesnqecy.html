<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>monoidal</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="oibaxnylzhpktgho.html">algebra</a></span><span class="wit-nav-item"><a href="nfoegqpcgzhctwbv.html">magma</a></span><span class="wit-nav-item"><a href="eovnsnrjngyuihhx.html">semigroup</a></span><span class="wit-nav-item"><a href="cabjryjnnstdjmvb.html">monoid</a></span><span class="wit-nav-item"><a href="edsabrzmtmhnwgml.html">category</a></span><span class="wit-nav-item"><a href="yboclzmzvuwqxcdt.html">functor</a></span><span class="wit-nav-item wit-nav-current-page">monoidal</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>&quot;monoidal&quot; functor in the function category is an interface of type functions; special version of functor</p><div class="wit-content" /></section><section><p>motivation</p><div class="wit-content"><section><p>the map function of functor makes us able to lift a function to the level of the functor</p><div class="wit-content"><section><p>map : (x -&gt; y) -&gt; (c x -&gt; c y)</p><div class="wit-content" /></section></div></section><section><p>what if the function i want to lift has more inputs?</p><div class="wit-content"><section><p>for example</p><div class="wit-content"><section><p>(x1 -&gt; x2 -&gt; r) -&gt; (c x1 -&gt; c x2 -&gt; c r)</p><div class="wit-content" /></section><section><p>for example to add 2 vectors by elements</p><div class="wit-content" /></section></div></section></div></section><section><p>can i implement a lift function for 2-input functions with using only the map function of functor? it is a good excercise for you to try</p><div class="wit-content" /></section><section><p>answer: no, it is impossible</p><div class="wit-content" /></section><section><p>but it feels very clear that it is desired in the same way as for 1-input functions; hence we want a generalization of functor that supports lifting functions with other arites; this interface will be named &quot;monoidal&quot;</p><div class="wit-content" /></section><section><p>to make my notation unambiguous: i will write into the name of the map functions the arity of their first input</p><div class="wit-content" /></section><section><p>map_n : (x1 -&gt; ... -&gt; xn -&gt; r) -&gt; (c x1 -&gt; ... -&gt; c xn -&gt; c r)</p><div class="wit-content" /></section><section><p>map_1 is the functorial map function</p><div class="wit-content" /></section><section><p>we want map_n functions for all n &gt; 1 too</p><div class="wit-content" /></section><section><p>thus the set of map_n functions is infinite; but it is technically impossible to put infinitely many requirements into an interface; luckily it is not necessary, because map_2 alone is enough to implement all of { map_n | n &gt; 1 }</p><div class="wit-content"><section><p>the key is this function</p><div class="wit-content"><section><p>(&lt;*&gt;) : c (x -&gt; y) -&gt; (c x -&gt; c y)</p><div class="wit-content" /></section><section><p>(&lt;*&gt;) = map_2 (\ f x -&gt; f x)</p><div class="wit-content" /></section><section><p>map_2 is enough to lift the function application function</p><div class="wit-content" /></section></div></section><section><p>(&lt;*&gt;) makes us able to implement map_n for every n inductively; by &quot;inductively&quot; i mean: implement the next map function from the previous one, that is implement map_k from map_n where k = n+1</p><div class="wit-content"><section><p>the input of map_k is a function of type (x1 -&gt; ... -&gt; xn -&gt; xk -&gt; r)</p><div class="wit-content" /></section><section><p>this can be thought of as a function with one less inputs: (x1 -&gt; ... -&gt; xn -&gt; (xk -&gt; r))</p><div class="wit-content"><section><p>this is just using the right associativity of (-&gt;)</p><div class="wit-content" /></section></div></section><section><p>to this we can apply map_n, which exists by inductive hypothesis</p><div class="wit-content" /></section><section><p>applying it we get a function with type</p><div class="wit-content"><section><p>(c x1 -&gt; ... -&gt; c xn -&gt; c (xk -&gt; r))</p><div class="wit-content" /></section></div></section><section><p>but we want (c x1 -&gt; ... -&gt; c xn -&gt; c xk -&gt; c r)</p><div class="wit-content" /></section><section><p>this conversion is implementable via the conversion f (xk -&gt; r) -&gt; (c xk -&gt; c r), which (&lt;*&gt;) does</p><div class="wit-content" /></section><section><p>finally: the implementation of map_k building on map_n and (&lt;*&gt;)</p><div class="wit-content"><section><p>map_k : (x1 -&gt; ... -&gt; xn -&gt; xk -&gt; r) -&gt; (c x1 -&gt; ... -&gt; c xn -&gt; c xk -&gt; c r)</p><div class="wit-content" /></section><section><p>map_k func cx1 cx2 ... cxn cxk = (map_n func cx1 cx2 ... cxn) &lt;*&gt; cxk</p><div class="wit-content" /></section></div></section></div></section><section><p>thus by extending the functor interface with the requirement for map_2: we achieve the ability to lift any function with arity &gt;= 1</p><div class="wit-content" /></section></div></section><section><p>but what about arity = 0? it again can not be implemented by the other map_ functions, hence we add it to interface monoidal as a separate requirement</p><div class="wit-content" /></section><section><p>this motivation leads to this signature</p><div class="wit-content"><section><p>interface Monoidal c &lt;= Functor c wehere</p><div class="wit-content"><section><p>map_0 : r -&gt; c r</p><div class="wit-content" /></section><section><p>map_2 : (x1 -&gt; x2 -&gt; r) -&gt; (c x1 -&gt; c x2 -&gt; c r)</p><div class="wit-content" /></section></div></section></div></section><section><p>but the actual signature will be a simpler, but equivalent one; i will not prove this equivalance, but and because it is a very easy and good excercise</p><div class="wit-content" /></section></div></section><section><p>the monoidal style expression</p><div class="wit-content"><section><p>interface Monoidal c &lt;= Functor c wehere</p><div class="wit-content"><section><p>(**) : c x -&gt; c y -&gt; c (x*y)</p><div class="wit-content"><section><p>-- associative up to isomorphism</p><div class="wit-content" /></section></div></section><section><p>unit : c ()</p><div class="wit-content"><section><p>-- is neutral in ** up to isomorphism</p><div class="wit-content" /></section></div></section></div></section><section><p>the methods behave like the operations of monoid [hence the name &quot;monoidal&quot;] with the slight loosening that instead of equality, only isomorphism [&quot;≅&quot;] is required</p><div class="wit-content"><section><p>commutativity of **</p><div class="wit-content"><section><p>x ** (x ** y) z ≅ x ** (y ** z)</p><div class="wit-content" /></section></div></section><section><p>neutrality of unit</p><div class="wit-content"><section><p>unit ** x ≅ x</p><div class="wit-content" /></section><section><p>x ** unit ≅ x</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>the laws</p><div class="wit-content"><section><p>the naturality law</p><div class="wit-content"><section><p>in general category theory: monoidal also contains a naturality law</p><div class="wit-content"><section><p>map (x *** y) (x&#39; ** y&#39;) = map x x&#39; ** map y y&#39;</p><div class="wit-content" /></section><section><p>where *** creates a function from 2 input functions that applies the 2 input functions by-component to a pair of inputs</p><div class="wit-content" /></section></div></section><section><p>as generally: in coding naturality is given by parametricity</p><div class="wit-content"><section><p><a href="nisopwyprssrsvgg.html">link to &#39;naturality&#39;</a></p><div class="wit-content" /></section><section><p><a href="iuvbupavbjmhfrxj.html">link to &#39;parametricity&#39;</a></p><div class="wit-content" /></section><section><p><a href="ejqpvlbcoexibqku.html">link to &#39;free theorems&#39;</a></p><div class="wit-content" /></section></div></section><section><p><a href="thfnzywxpqkcvtdh.html">my derivation of the free theorem</a></p><div class="wit-content" /></section></div></section></div></section><section><p>applicative</p><div class="wit-content"><section><p>in practice often an equivalent alternative expression is used, and is named &quot;applicative&quot;</p><div class="wit-content" /></section><section><p>interface Applicative c where</p><div class="wit-content"><section><p>pure : x -&gt; c x</p><div class="wit-content" /></section><section><p>(&lt;*&gt;) : c (x -&gt; y) -&gt; (c x -&gt; c y)</p><div class="wit-content" /></section></div></section><section><p>the laws for this expression are less intuitive, hence i omit them here</p><div class="wit-content" /></section></div></section><section><p><a href="uatqvzoqdjbcizxw.html">traversable</a></p><div class="wit-content" /></section><section><p>more sources</p><div class="wit-content"><section><p><a href="https://coot.me/posts/monoidal-functors.html">Marcin Szamotulski: Monoidal and Applicative Functors</a></p><div class="wit-content" /></section></div></section><section><p><a href="mtcrpjujemznyvue.html">monad</a></p><div class="wit-content" /></section></span></body></html>