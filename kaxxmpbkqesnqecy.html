<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>monoidal in programming</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">information technology</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="oibaxnylzhpktgho.html">algebra</a></span><span class="wit-nav-item"><a href="cabjryjnnstdjmvb.html">monoid</a></span><span class="wit-nav-item"><a href="edsabrzmtmhnwgml.html">category</a></span><span class="wit-nav-item"><a href="yboclzmzvuwqxcdt.html">functor</a></span><span class="wit-nav-item wit-nav-current-page">monoidal in programming</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>monoidal is an interface of type functions; special version of functor</p><div class="wit-content" /></section><section><p>motivation</p><div class="wit-content"><section><p>the map function of functor makes us able to lift a function to the level of the functor</p><div class="wit-content"><section><p>map : (x -&gt; y) -&gt; (c x -&gt; c y)</p><div class="wit-content" /></section></div></section><section><p>what if the function i want to lift has more inputs ?</p><div class="wit-content"><section><p>for example</p><div class="wit-content"><section><p>(x1 -&gt; x2 -&gt; r) -&gt; (c x1 -&gt; c x2 -&gt; c r)</p><div class="wit-content" /></section><section><p>for example to add 2 lists of numbers by elements</p><div class="wit-content" /></section></div></section></div></section><section><p>can i implement a lift function for 2-input functions with using only the map function of functor? it is a good excercise for you to try</p><div class="wit-content" /></section><section><p>answer : no, it is impossible</p><div class="wit-content" /></section><section><p>but it feels very clear that it is desired in the same way as for 1-input functions; hence we want a generalization of functor that supports lifting functions with other arity [number of inputs]; this interface will be named &quot;monoidal&quot;</p><div class="wit-content" /></section><section><p>to make my notation unambiguous : i will write into the name of the map functions the arity of their first input; thus the unambiguous name of the map function from functor will be map_1</p><div class="wit-content" /></section><section><p>map_n : (x1 -&gt; ... -&gt; xn -&gt; r) -&gt; (c x1 -&gt; ... -&gt; c xn -&gt; c r)</p><div class="wit-content" /></section><section><p>map_1 is the functorial map function</p><div class="wit-content" /></section><section><p>we want map_n functions for all n &gt; 1 too</p><div class="wit-content" /></section><section><p>thus the set of map_n functions is infinite; but it is technically impossible to put infinitely many requirements into an interface; luckily it is not necessary, because map_2 alone is enough to implement all of { map_n | n &gt; 1 }</p><div class="wit-content"><section><p>the key is this function</p><div class="wit-content"><section><p>(&lt;*&gt;) : c (x -&gt; y) -&gt; (c x -&gt; c y)</p><div class="wit-content" /></section><section><p>(&lt;*&gt;) = map_2 (\ f x -&gt; f x)</p><div class="wit-content" /></section><section><p>with natural words : map_2 is enough to lift the function application function</p><div class="wit-content" /></section></div></section><section><p>(&lt;*&gt;) makes me able to implement map_n for every desired n inductively; by &quot;inductively&quot; i mean : implement the next map function from the previous one, that is implement map_k from map_n where k = n+1</p><div class="wit-content"><section><p>the input of map_k is a function of type (x1 -&gt; ... -&gt; xn -&gt; xk -&gt; r)</p><div class="wit-content" /></section><section><p>this can be thought of as a function with one less inputs : (x1 -&gt; ... -&gt; xn -&gt; (xk -&gt; r))</p><div class="wit-content"><section><p>this is just using the right associativity of (-&gt;)</p><div class="wit-content" /></section></div></section><section><p>to this we can apply map_n, which exists by inductive hypothesis</p><div class="wit-content" /></section><section><p>applying it we get a function with type</p><div class="wit-content"><section><p>(c x1 -&gt; ... -&gt; c xn -&gt; c (xk -&gt; r))</p><div class="wit-content" /></section></div></section><section><p>but we want (c x1 -&gt; ... -&gt; c xn -&gt; c xk -&gt; c r)</p><div class="wit-content" /></section><section><p>this conversion is implementable via the conversion f (xk -&gt; r) -&gt; (c xk -&gt; c r), which (&lt;*&gt;) does</p><div class="wit-content" /></section><section><p>finally : the implementation of map_k building on map_n and (&lt;*&gt;)</p><div class="wit-content"><section><p>map_k : (x1 -&gt; ... -&gt; xn -&gt; xk -&gt; r) -&gt; (c x1 -&gt; ... -&gt; c xn -&gt; c xk -&gt; c r)</p><div class="wit-content" /></section><section><p>map_k func cx1 cx2 ... cxn cxk = (map_n func cx1 cx2 ... cxn) &lt;*&gt; cxk</p><div class="wit-content" /></section></div></section></div></section><section><p>thus by extending the functor interface with the requirement for map_2 : we achieve the ability to lift any function with arity &gt;= 1</p><div class="wit-content" /></section></div></section><section><p>but what about arity = 0 ? i did not mention this case till now for simplicity, but it is now time to think about it; and it can be felt that we desire it the same way as the others; unluckily the other map_n functions where n &gt;=1 are not enough to implement map_0, hence we choose to just add it to interface monoidal as a separate requirement</p><div class="wit-content" /></section><section><p>this motivation leads to this signature</p><div class="wit-content"><section><p>interface Monoidal c &lt;= Functor c wehere</p><div class="wit-content"><section><p>map_0 : r -&gt; c r</p><div class="wit-content" /></section><section><p>map_2 : (x1 -&gt; x2 -&gt; r) -&gt; (c x1 -&gt; c x2 -&gt; c r)</p><div class="wit-content" /></section></div></section></div></section><section><p>but the actual signature will be a simpler, but equivalent one; i will not prove this equivalance, but and because it is a very easy and good excercise</p><div class="wit-content" /></section></div></section><section><p>the signature</p><div class="wit-content"><section><p>interface Monoidal c &lt;= Functor c wehere</p><div class="wit-content"><section><p>unit : c ()</p><div class="wit-content"><section><p>-- empty</p><div class="wit-content" /></section></div></section><section><p>(**) : c x -&gt; c y -&gt; c (x*y)</p><div class="wit-content"><section><p>-- associative</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>the laws</p><div class="wit-content"><section><p>the methods behave like the operations of monoid [hence the name &quot;monoidal&quot;] with the slight loosening that instead of equality, only isomorphism [&quot;≅&quot;] is required</p><div class="wit-content" /></section><section><p>unit x ≅ x x unit ≅ x (x y) z ≅ x (y z)</p><div class="wit-content" /></section><section><p>the naturality law</p><div class="wit-content"><section><p>in category theory the monoidal also contains a naturality law</p><div class="wit-content"><section><p>map (x y) (x&#39; y&#39;) = map x x&#39; map y y&#39;</p><div class="wit-content" /></section><section><p>where creates a function from 2 input functions that applies the 2 input functions by-component to a pair of inputs</p><div class="wit-content" /></section></div></section><section><p>as generally : in programming naturality is given by parametricity as a free theorem</p><div class="wit-content"><section><p><a href="nisopwyprssrsvgg.html">link to &#39;naturality&#39;</a></p><div class="wit-content" /></section><section><p><a href="iuvbupavbjmhfrxj.html">link to &#39;parametricity&#39;</a></p><div class="wit-content" /></section><section><p><a href="ejqpvlbcoexibqku.html">link to &#39;free theorems&#39;</a></p><div class="wit-content" /></section></div></section><section><p><a href="thfnzywxpqkcvtdh.html">my derivation of the free theorem</a></p><div class="wit-content" /></section></div></section></div></section><section><p>applicative</p><div class="wit-content"><section><p>in practice often an equivalent alternative formation is used, and is named &quot;applicative&quot;</p><div class="wit-content" /></section><section><p>interface Applicative c where</p><div class="wit-content"><section><p>pure : x -&gt; c x</p><div class="wit-content" /></section><section><p>(&lt;*&gt;) : c (x -&gt; y) -&gt; (c x -&gt; c y)</p><div class="wit-content" /></section></div></section><section><p>in this formation the laws are chosen to be equivalent with monoidal; this formation of the laws is less intuitive, hence i omit them here</p><div class="wit-content" /></section><section><p>this alternative formation does not take Functor as requirement, because its methods are powerful enough to implement Functor</p><div class="wit-content" /></section></div></section><section><p>monoidal-generic programs</p><div class="wit-content"><section><p>a good example:</p><div class="wit-content"><section><p><a href="nuckddbslvpvzupy.html">the sequence function that swaps container layers</a></p><div class="wit-content" /></section></div></section></div></section><section><p>more sources</p><div class="wit-content"><section><p><a href="https://coot.me/posts/monoidal-functors.html">Marcin Szamotulski : Monoidal and Applicative Functors</a></p><div class="wit-content" /></section></div></section><section><p><a href="mtcrpjujemznyvue.html">monad</a></p><div class="wit-content" /></section></span></body></html>