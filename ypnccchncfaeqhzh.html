<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>a convincing real-world example</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">information technology</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="rmciseizvhdgclym.html">user interface</a></span><span class="wit-nav-item"><a href="oeyeaezscdudpssh.html">formal languages</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">software coding</a></span><span class="wit-nav-item"><a href="flktedmyhawaehus.html">abstractions from mathematics</a></span><span class="wit-nav-item"><a href="xmtpmaqybielrpxs.html">category theory</a></span><span class="wit-nav-item"><a href="ybwmxqdoenunvcsk.html">optics</a></span><span class="wit-nav-item"><a href="ndgkrnbojyputpec.html">introduction</a></span><span class="wit-nav-item"><a href="okbqwsokzocmyuul.html">intuitive introduction</a></span><span class="wit-nav-item wit-nav-current-page">a convincing real-world example</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>as mentioned in the part about the abstractness of the lens concept : we can manage the getting, setting, transforming, inserting, deleting of values in the map via lenses; instead of implementing these functionalities separately [and hence redundantly] : the following simple single Lens will do :</p><div class="wit-content"><section><p>lens_value_at : Lens (Maybe v) (Map k v)</p><div class="wit-content" /></section></div></section><section><p>by doing so we save some implementation time, possibly avoid some bugs and make the code and the API smaller and cleaner; we also make the API more uniform, familiar, as it builds on the lens API; this amount of advantage is already significant, but optics can do more, by their composability property, as i will demonstrate next :</p><div class="wit-content" /></section><section><p>think about the ordinary map data structure, which stores a set of (key, value) elements; in the general scenario it is implemented with a search tree; in the case when the key type is string : a specialization is possible that improves the runtime properties asymptotically; the trick is to merge subtrees whose key prefix equal; for example : instead of { &quot;hell&quot; -&gt; x, &quot;hello&quot; -&gt; y } it would store { &quot;hell&quot; -&gt; { &quot;&quot; -&gt; x, &quot;o&quot; -&gt; y } }; i will name my implementation of this data structure with &quot;StringyMap&quot;</p><div class="wit-content" /></section><section><p>-- | Maps strings of c-s to v-s. -- &quot;c&quot; is the type of character in the key string.</p><div class="wit-content" /></section><section><p>-- &quot;v&quot; is element value of the container;</p><div class="wit-content" /></section><section><p>-- &#39;Base.Map&#39; is the ordinary map data structure from a &#39;base&#39; library assumed to be available in the programming environment;</p><div class="wit-content" /></section><section><p>-- one can think about the right side of the definition as a bucket</p><div class="wit-content" /></section><section><p>-- that belongs to a certain key prefix;</p><div class="wit-content" /></section><section><p>-- the &#39;immediate_value&#39; in the bucket is a value of the StringyMap</p><div class="wit-content" /></section><section><p>-- that belongs to the corresponding key prefix as a whole key;</p><div class="wit-content" /></section><section><p>-- the &#39;children&#39; in the bucket stores the associations of the StringyMap</p><div class="wit-content" /></section><section><p>-- with the continuations of the keys as keys</p><div class="wit-content" /></section><section><p>let StringyMap c v = { immediate_value : Maybe v, children : Base.Map c (StringyMap c v) }</p><div class="wit-content"><section><p>deriving (Functor, Foldable, Traversable)</p><div class="wit-content" /></section></div></section><section><p>some utilities as a preparation for the core of the example :</p><div class="wit-content"><section><p>about emptiness</p><div class="wit-content"><section><p>empty : Map c v</p><div class="wit-content" /></section><section><p>empty = StringyMap Nothing Base.empty</p><div class="wit-content"><section><p>-- a StringyMap is empty iff</p><div class="wit-content" /></section><section><p>-- (&#39;immediate_value&#39; is Nothing) and</p><div class="wit-content" /></section><section><p>-- (the container at the &#39;children&#39; field is empty)</p><div class="wit-content" /></section></div></section><section><p>is_empty : StringyMap c e -&gt; Bool</p><div class="wit-content" /></section><section><p>is_empty = liftA2 (&amp;&amp;) (immediate_value &gt;&gt;&gt; Base.isNothing) (children &gt;&gt;&gt; Base.null)</p><div class="wit-content" /></section></div></section><section><p>lenses that focuses from a bucket to its data members</p><div class="wit-content"><section><p>lens_immediate_value : Lens (Maybe v)) (StringyMap c v)</p><div class="wit-content" /></section><section><p>lens_immediate_value = &lt;boilerplate&gt;</p><div class="wit-content" /></section><section><p>lens_children : Lens (Base.Map c (StringyMap c v)) (StringyMap c v)</p><div class="wit-content" /></section><section><p>lens_children = &lt;boilerplate&gt;</p><div class="wit-content" /></section></div></section><section><p>i also assume that the ordinary &#39;Map&#39; module in the base library provides lenses to its values</p><div class="wit-content"><section><p>Base.lens_value : List c -&gt; Lens (Maybe v) (Map c v)</p><div class="wit-content" /></section><section><p>explanation : (List c) is the type of the key [it is string]</p><div class="wit-content" /></section></div></section></div></section><section><p>and then finally here is the implementation of the value lens of the StringyMap data structure :</p><div class="wit-content"><section><p>before you start digesting the following code : i want you to know that you do not need to understand all the details, i will extract the main idea</p><div class="wit-content" /></section><section><p>import qualified Data.Map as Base</p><div class="wit-content" /></section><section><p>-- i will refer to the ordinary Map stuff from the base library with the &#39;Base&#39; qualifier</p><div class="wit-content" /></section><section><p>lens_value_at : Ord c =&gt; List c -&gt; Lens&#39; (Maybe v) (StringyMap c v)</p><div class="wit-content" /></section><section><p>lens_value_at = </p><div class="wit-content"><section><p>\ case</p><div class="wit-content"><section><p>[] -&gt; lens_immediate_value</p><div class="wit-content" /></section><section><p>c : rest -&gt;</p><div class="wit-content"><section><p>let</p><div class="wit-content"><section><p>-- | if a map is empty</p><div class="wit-content"><section><p>-- then it as element should be deleted from its container</p><div class="wit-content" /></section><section><p>-- to save running time and memory.</p><div class="wit-content" /></section><section><p>optimize :: Map c v -&gt; Maybe (Map c v)</p><div class="wit-content" /></section><section><p>optimize m = if is_empty m then Nothing else Just m</p><div class="wit-content" /></section><section><p>-- this is a Lens that does technical plumbing;</p><div class="wit-content" /></section><section><p>-- it focuses the value in a (Maybe (StringyMap c v));</p><div class="wit-content" /></section><section><p>-- returning an empty StringyMap when Nothing is queried;</p><div class="wit-content" /></section><section><p>-- in addition its set method returns Nothing when the given StringyMap is empty</p><div class="wit-content" /></section><section><p>-- to delete empty subtrees as optimization;</p><div class="wit-content" /></section><section><p>maybeize : Lens (StringyMap c v) (Maybe (StringyMap c v))</p><div class="wit-content" /></section><section><p>maybeize f = Lens.from_get_set (Maybe.fromMaybe empty) (optimize &gt;&gt;&gt; const)</p><div class="wit-content" /></section><section><p>in lens_children &lt;&lt;&lt; Base.lens_value_at c &lt;&lt;&lt; maybeize &lt;&lt;&lt; lens_value_at rest</p><div class="wit-content" /></section></div></section></div></section></div></section></div></section></div></section><section><p>in the outermost level the function is a branching on the key structure [whether it is empty]; the implementation of the empty case is trivially just a simple lens, the other is challenging, but lenses and their composability tames the task</p><div class="wit-content" /></section><section><p>the core of the code is the composition of 3 lenses :</p><div class="wit-content"><section><p>&#39;lens_children&#39; - focuses from the bucket [a StringyMap] to its &#39;children&#39; data member</p><div class="wit-content" /></section><section><p>&#39;Base.lens_value_at&#39; - the &#39;children&#39; data member stores an ordinary map that maps the next character in the key to the rest of the StringyMap; for the ordinary map i have a &#39;Base.lens_value_at&#39; lens provided by the base library, this lens focuses from the ordinary map to a value in it, which is of type (Maybe (StringyMap c v))</p><div class="wit-content" /></section><section><p>&#39;lens_value_at&#39; - is a recursive reference to the lens that i am defining</p><div class="wit-content"><section><p>its type is (Lens (Maybe v) (StringyMap c v)); this type slightly differs from what the composition chain dictates [the difference is one &#39;Maybe&#39; layer], that is why i have to &quot;maybeize&quot;</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>thus the power of lens enabled me to implement getting, setting, efficiently transforming, inserting, deleting of elements in my new custom map data structure with very little code, without any redundancy, without error-prone algorithmic parts</p><div class="wit-content" /></section></span></body></html>