<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>rum-time efficiency</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">coding</a></span><span class="wit-nav-item"><a href="ftkadhwzfhvfbwnk.html">correct by construction</a></span><span class="wit-nav-item"><a href="zxsbxwlppaypmpnn.html">functional programming</a></span><span class="wit-nav-item wit-nav-current-page">rum-time efficiency</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>runtime-efficiency optimization is program transformation; the transformed program must semantically be equivalent to the original program; the possibility of side effects often makes this false or at least difficult to prove, which is enough to prevent the transformation to be applied; hence side-effects make optimization more difficult, both at low and high levels; for both the compiler, the runtime system and the human coder</p><div class="wit-content" /></section><section><p>level of optimizations </p><div class="wit-content"><section><p>low</p><div class="wit-content"><section><p>efficient c++ code contains lot of &quot;const&quot; declaration, to enable more micro-optimization by the compiler</p><div class="wit-content" /></section><section><p>a garbage collection algorithm can have competitive efficiency only if it is generational; the idea behind the generational ones is that old references are not frequently changed; if this assumption is false then the generational collector can suffer</p><div class="wit-content" /></section></div></section><section><p>high</p><div class="wit-content"><section><p>example</p><div class="wit-content"><section><p>function &#39;map&#39; lifts the given function to the level of a collection</p><div class="wit-content" /></section><section><p>in absence of side-effects: ((map f) &gt;&gt;&gt; (map g)) is semantically equivalent to (map (f &gt;&gt;&gt; g)); but the later one is more efficient, because it iterates the collection once [with the function (f &gt;&gt;&gt; g)] while the former one iterates the collection twice [first with function f then with function g]</p><div class="wit-content" /></section><section><p>if side-effects may be present in f or g then the 2 versions are not necessarily equivalent semantically</p><div class="wit-content"><section><p>for example</p><div class="wit-content"><section><p>imagine that both f and g logs its name; then</p><div class="wit-content"><section><p>((map f) &gt;&gt;&gt; (map g)) logs ff...fgg...g</p><div class="wit-content" /></section><section><p>(map (f &gt;&gt;&gt; g)) logs fgfg...fg</p><div class="wit-content" /></section></div></section><section><p>so their logs are different, thus they are not equivalent</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>in haskell such optimization transformations can be specified by the coder, to then be automatically performed by the compiler</p><div class="wit-content" /></section></div></section></div></section><section><p>level of the code</p><div class="wit-content"><section><p>lower level of the code does not make it more efficiency, it is just differently optimized</p><div class="wit-content"><section><p><a href="yjnweovfnkfncnhp.html">link to explanation</a></p><div class="wit-content" /></section></div></section><section><p>functional programming often can be low level</p><div class="wit-content"><section><p>example</p><div class="wit-content"><section><p>imperative version</p><div class="wit-content"><section><p>c := 0</p><div class="wit-content" /></section><section><p>for (int i = 0; i &lt; n; ++n)</p><div class="wit-content"><section><p>c := c + a[i] * b[i]</p><div class="wit-content" /></section></div></section></div></section><section><p>it can be rewritten to low level functional</p><div class="wit-content"><section><p>let</p><div class="wit-content"><section><p>dp m acc =</p><div class="wit-content"><section><p>if m == 0</p><div class="wit-content"><section><p>then 0</p><div class="wit-content" /></section><section><p>else dp (m-1) (acc + a[m] * b[m])</p><div class="wit-content" /></section></div></section></div></section><section><p>in dp n 0</p><div class="wit-content" /></section></div></section><section><p>this version</p><div class="wit-content"><section><p>does not create temporary vertors</p><div class="wit-content" /></section><section><p>is monomorphic [though an optimizing compiler automatically monomorphises in the background too anyway]</p><div class="wit-content" /></section><section><p>the recursion occurs in a tail call</p><div class="wit-content"><section><p>hence the compiler will reuse the execution stack frame for the recursive function call, turn the recursion into a loop using only constant memory</p><div class="wit-content" /></section></div></section></div></section></div></section></div></section></div></section></div></section></span></body></html>