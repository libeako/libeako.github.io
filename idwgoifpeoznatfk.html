<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>short overview about the content</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">coding</a></span><span class="wit-nav-item"><a href="wdfyijgzinmnmzpn.html">your journey</a></span><span class="wit-nav-item wit-nav-current-page">short overview about the content</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>history of programming methodologies</p><div class="wit-content"><section><p>both industrial and academic and their relation</p><div class="wit-content" /></section></div></section><section><p>then i move to the real professional topics</p><div class="wit-content" /></section><section><p>i start them with basic stuff and leave some advanced topics to later</p><div class="wit-content" /></section><section><p>static type checking</p><div class="wit-content"><section><p>i claim that dynamic type checking does not have any legitimacy; all programming languages should be statically type checked</p><div class="wit-content" /></section></div></section><section><p>utilizing the static type checking</p><div class="wit-content"><section><p>once we use a language with static type checking : we should make out the max of it</p><div class="wit-content" /></section><section><p>some important examples : </p><div class="wit-content"><section><p>do not use null values; use a Maybe type instead</p><div class="wit-content" /></section><section><p>do not use exceptions; use a Result type instead</p><div class="wit-content" /></section></div></section></div></section><section><p>basic programming notions from the academic world</p><div class="wit-content"><section><p>both concepts and syntax</p><div class="wit-content" /></section><section><p>i present them to prepare the audience to understand my future examples; but they are worth to know anyway because they are to overtake the programming world by popularity</p><div class="wit-content" /></section></div></section><section><p>functional programing</p><div class="wit-content"><section><p>this is an easy and beautiful topic; also probably the most bang for the buck during the whole course; [though not equally well but still] can be used in any programming language right from now</p><div class="wit-content" /></section></div></section><section><p>structural polymorphism</p><div class="wit-content"><section><p>a feature in some programming languages [for example Haskell] that lets the programmer abstract via the shape of the data type</p><div class="wit-content" /></section></div></section><section><p>from here on the content is mathematically related</p><div class="wit-content"><section><p>do not worry, the course is self-contained, you do not need any math knowledge</p><div class="wit-content" /></section></div></section><section><p>parametricity</p><div class="wit-content"><section><p>i present a programming paradigm of generality [by parametric type polymorphism], a simple, very cheap technique to improve software-correctness and source-readability</p><div class="wit-content" /></section></div></section><section><p>compositionality</p><div class="wit-content"><section><p>&quot;design patterns&quot; done well</p><div class="wit-content" /></section><section><p>the supoer-power of compositionality, taken from the well-established mathematical field abstract algebra, especially category theory; i explain only the very basic, but very useful concepts : monoid, functor, applicative, monad</p><div class="wit-content" /></section><section><p>this stuff is not only not misguiding as object-oriented programming is, but they increase the economy of code by magnitudes</p><div class="wit-content" /></section></div></section><section><p>dependent typing</p><div class="wit-content"><section><p>parameterizing our types with more stuff : type functions, custom algebraic data types, runtime values [&quot;dependent typing&quot;]</p><div class="wit-content" /></section><section><p>the more our type system can express - the more properties of our programs we can ensure</p><div class="wit-content" /></section></div></section><section><p>proposition as type</p><div class="wit-content"><section><p>strong connection is between programming and logic - the &quot;proposition as type correspondence&quot;</p><div class="wit-content" /></section><section><p>this is a beautiful topic; the most interesting thing i ever learned in programming; it shows how programming and logic are the same thing at a certain level, via a surprisingly simple connection; this connection makes us able to use a single simple programming language to not only implement software but also : </p><div class="wit-content"><section><p>model its domain</p><div class="wit-content" /></section><section><p>state mathematical theorems about the domain</p><div class="wit-content" /></section><section><p>prove those theorems and have the compiler verify the proofs</p><div class="wit-content" /></section><section><p>specify the software and have the compiler verify the correctness of the implementation according to the specification</p><div class="wit-content" /></section></div></section></div></section></span></body></html>