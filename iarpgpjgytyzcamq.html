<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>sum type</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="rmciseizvhdgclym.html">user interface</a></span><span class="wit-nav-item"><a href="oeyeaezscdudpssh.html">formal languages</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">software coding</a></span><span class="wit-nav-item"><a href="jaxbiyrfnbhaormb.html">some basic prog lang notions</a></span><span class="wit-nav-item wit-nav-current-page">sum type</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>sum types are generalization of enum types, as they can store additional values, of different types for each case; in the definition of the sum type: in each case: we just list the types of values that to be stored</p><div class="wit-content" /></section><section><p>example:</p><div class="wit-content" /></section><section><p>datatype Maybe (e : Type) = none | just e</p><div class="wit-content" /></section><section><p>&#39;Maybe&#39; is a container type that maybe contains a single element or nothing; it is often used as the return type of functions which can fail</p><div class="wit-content" /></section><section><p>the syntax allows us to list zero or multiple values to store in any case, but mathematically we can think that each case stores exactly 1 value, because 0 and multiple values are mathematically equivalent of their single tuple</p><div class="wit-content" /></section><section><p>the &#39;Either&#39; type</p><div class="wit-content"><section><p>the most simple sum type that can be used to construct equivalent type with any sum type is</p><div class="wit-content" /></section><section><p>datatype Either (l : Type) (r : Type) = left  l | right r</p><div class="wit-content" /></section><section><p>hence it is known as the &quot;canonical&quot; sum type</p><div class="wit-content" /></section><section><p>it is a generalization of &#39;Maybe&#39;, as (Either ()) is equivalent to Maybe</p><div class="wit-content" /></section><section><p>naming</p><div class="wit-content"><section><p>because of the equivalance to &#39;Maybe&#39;: it is also usable to represent result of computation, even more cleverly, as it can store information about [perhaps the reason of] failure too; in the case of Maybe it is obvious which case corresponds to success and which case corresponds to failure of computation, as no reason to successfully compute a nothing; but with &#39;Either&#39; it is not obvious, as its cases are mathematically equivalent; this is an ergonomic problem; which to solve it is tempting to change the naming:</p><div class="wit-content" /></section><section><p>datatype Result (a : Type) (b : Type) = error a | success b</p><div class="wit-content" /></section><section><p>but this is a design mistake, because though the most notable usage of &#39;Either&#39; is to represent result of computation: its full usage is significantly broader</p><div class="wit-content" /></section><section><p>the communities of Haskell and similar languages chose to use &#39;Either&#39; always; they are satisfied with this choice after tens of years of practice; important cause of this is that to disambiguate the cases for representing result is not so difficult as one usually thinks at first</p><div class="wit-content" /></section><section><p>we have luck from the english language; &quot;right&quot; means not only a side, but also means &#39;correct&#39; and a success is obviouosly more correct than a failure</p><div class="wit-content" /></section><section><p>if representing a result then we think about &#39;Either&#39; as a container containing the successul result; for this fit: we need the last type parameter to correspond to the succesful case, as partial application of the &#39;Either&#39; type function [&quot;Either l&quot;] then is a container type</p><div class="wit-content" /></section></div></section></div></section><section><p>duality with product</p><div class="wit-content"><section><p>product and sum type construction is essentially the same thing; surprising but true; they both are well defined by mathematics, in an exact and very abstract manner; as categories; you can think of categories as directed graphs, with certain properties, which i do not want to present here; product and sum type constructions are defined by graphs that have the same structure with opposite edges; that is the only difference: all the edge directions are opposite; otherwise they have the same structure; with this in mind it is not surprising that we observe dualities between them; here are some:</p><div class="wit-content" /></section><section><p>if x is a value of a { product  | sum } type t then the members of t list the possible datas that we can { project x down to | build x up to from }</p><div class="wit-content" /></section><section><p>the compiler automatically generates { projection | construction } functions from the members of the { product | sum } type</p><div class="wit-content" /></section><section><p>the number of values of a { product | sum } type equals the { product | sum } of the numbers of values of the member types; this is the origin of the { &quot;product&quot; | &quot;sum&quot; } names for these type constructions</p><div class="wit-content" /></section><section><p>from a logic perspective: a value of a { product | sum } type contains a value of its member 1 type { and | or } a value of its member 2 type { and | or } ... { and | or } a value of its member n type</p><div class="wit-content" /></section><section><p>a value of a { product | sum } type contains a value for { each | exactly one } member; this is also true for value with exactly zero members, vacously</p><div class="wit-content" /></section></div></section><section><p>sum-typing - sub-typing</p><div class="wit-content"><section><p>sum type construction and subtyping is opposite to each other in the following manner:</p><div class="wit-content" /></section><section><p>the set of cases in a sum type can be edited only with write access to the definiton of the sum type but anyone can write new methods working with the given sum type</p><div class="wit-content" /></section><section><p>the set of methods in a supertype [type interface] can be edited only with write access to the definition of the supertype but anyone can write new subtypes of the given supertype</p><div class="wit-content" /></section></div></section></span></body></html>