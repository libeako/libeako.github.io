<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>design patterns</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">coding</a></span><span class="wit-nav-item"><a href="sltupaghfpuaijff.html">programming language</a></span><span class="wit-nav-item"><a href="sgdgrgstvwioqtwb.html">bad language features</a></span><span class="wit-nav-item"><a href="kgmqzsduacpzvbxy.html">object oriented programming</a></span><span class="wit-nav-item wit-nav-current-page">design patterns</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p><a href="https://www.oodesign.com/proxy-pattern.html">a website listing many of them</a></p><div class="wit-content" /></section><section><p>i worked through all of them, here are my quick impressions about them</p><div class="wit-content"><section><p>&quot;decorator&quot;</p><div class="wit-content"><section><p>= let us decrease the inheritance hierarchy, by replacing some inheritance with aggregation</p><div class="wit-content" /></section><section><p>but: realizing that a more basic language construct [product type] is more adequate than a more involved one [inheritance] is not a &quot;design pattern&quot;; because to apply the more heavy-weight language construct is not a task to be solved</p><div class="wit-content" /></section></div></section><section><p>&quot;flyweight&quot;</p><div class="wit-content"><section><p>= data reference :-) [&quot;pointer&quot; if you like]; yes: some people think it needs a different name and articles</p><div class="wit-content" /></section></div></section><section><p>&quot;factory&quot;</p><div class="wit-content"><section><p>= stream</p><div class="wit-content" /></section></div></section><section><p>&quot;composite&quot;</p><div class="wit-content"><section><p>= tree</p><div class="wit-content" /></section></div></section><section><p>&quot;strategy&quot;</p><div class="wit-content"><section><p>= second order function, which is just function with function input : (x -&gt; y) -&gt; z</p><div class="wit-content" /></section></div></section><section><p>&quot;command&quot;</p><div class="wit-content"><section><p>= special case of &quot;strategy&quot;, where the input function is an action</p><div class="wit-content" /></section></div></section><section><p>&quot;builder&quot;</p><div class="wit-content"><section><p>= special case of strategy, where the input function produces something instead of performing an action</p><div class="wit-content" /></section></div></section><section><p>&quot;singleton&quot;</p><div class="wit-content"><section><p>= lazy initialization + mutable global state</p><div class="wit-content" /></section></div></section><section><p>&quot;state&quot;</p><div class="wit-content"><section><p>= access control + mutable state</p><div class="wit-content" /></section></div></section><section><p>&quot;null object&quot;</p><div class="wit-content"><section><p><a href="cabjryjnnstdjmvb.html">monoid</a></p><div class="wit-content" /></section></div></section><section><p>&quot;template method&quot;</p><div class="wit-content"><section><p>= &quot;strategy&quot;</p><div class="wit-content" /></section></div></section><section><p>&quot;prototype&quot;</p><div class="wit-content"><section><p>= changing things slightly = optics</p><div class="wit-content" /></section></div></section><section><p>&quot;interpretation&quot;</p><div class="wit-content"><section><p>= denotational semantics</p><div class="wit-content" /></section><section><p>in this role sum types work better because in a language the constructs [the production rules] are usually not extensible</p><div class="wit-content" /></section></div></section><section><p>&quot;iterator&quot;</p><div class="wit-content"><section><p>= imperative traversable</p><div class="wit-content"><section><p><a href="http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator">see (Jeremy Gibbons and Bruno Oliveira: &quot;The essence of the Iterator pattern&quot;)</a></p><div class="wit-content" /></section></div></section><section><p>this is an example of the rare situation that the OO style is easier to understand, more intuitive</p><div class="wit-content" /></section></div></section><section><p>&quot;visitor&quot;</p><div class="wit-content"><section><p>the action performed by the &quot;iterator&quot;; &quot;iterator&quot; and &quot;visitor&quot; are 2 components of a single design pattern</p><div class="wit-content" /></section></div></section><section><p>&quot;memento&quot;</p><div class="wit-content"><section><p>= cloning, which is not needed with the absence of mutation</p><div class="wit-content" /></section></div></section><section><p>&quot;observer&quot;</p><div class="wit-content"><section><p>is an inherently OO solution; because it extends updating [an imperative thing] and designates a central object through which to drive the update; a perfect example for domain is user interface; i am not knowledgable in the UI domain but i know that functional UI exist and its practitioners like it</p><div class="wit-content" /></section></div></section><section><p>&quot;bridge&quot;</p><div class="wit-content"><section><p>i did not understand this one in the 10 minutes i was willing to spend on it</p><div class="wit-content" /></section></div></section><section><p>not OO specific</p><div class="wit-content"><section><p>&quot;resource pool&quot;</p><div class="wit-content" /></section><section><p>no real relation to OO</p><div class="wit-content"><section><p>&quot;proxy&quot;</p><div class="wit-content"><section><p>= layering</p><div class="wit-content" /></section></div></section><section><p>&quot;mediator&quot;</p><div class="wit-content"><section><p>seems to be equivalent to a 2-input function</p><div class="wit-content" /></section></div></section><section><p>&quot;adapter&quot;</p><div class="wit-content" /></section><section><p>&quot;chain of responsibility&quot;</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>i hope i understood most of them correctly</p><div class="wit-content" /></section><section><p>note that for most of them at least one of the following statements is true</p><div class="wit-content"><section><p>just renames some very simple notion</p><div class="wit-content" /></section><section><p>unnecessarily overcomplicates some very simple notion with OO clothing</p><div class="wit-content" /></section><section><p>no real relation to OO [its categorization into &quot;OO design patter&quot; is incorrect]</p><div class="wit-content" /></section><section><p>involves state mutation</p><div class="wit-content"><section><p>though in a few cases the functional equivalent is less intuitive: altogether the functional [controlled] state handling is almost always a better solution because of the enormous advantages of the functional paradigm</p><div class="wit-content" /></section></div></section></div></section></span></body></html>