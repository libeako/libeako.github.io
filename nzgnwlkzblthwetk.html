<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>bifunctor</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="oibaxnylzhpktgho.html">algebra</a></span><span class="wit-nav-item"><a href="nfoegqpcgzhctwbv.html">magma</a></span><span class="wit-nav-item"><a href="eovnsnrjngyuihhx.html">semigroup</a></span><span class="wit-nav-item"><a href="cabjryjnnstdjmvb.html">monoid</a></span><span class="wit-nav-item"><a href="edsabrzmtmhnwgml.html">category</a></span><span class="wit-nav-item"><a href="yboclzmzvuwqxcdt.html">functor</a></span><span class="wit-nav-item wit-nav-current-page">bifunctor</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>a bifunctor is a functor whose source is a product category</p><div class="wit-content"><section><p><a href="oibaxnylzhpktgho.html">see &#39;product of algebras&#39;</a></p><div class="wit-content" /></section></div></section><section><p>i will use programmers&#39; language in this part</p><div class="wit-content" /></section><section><p>i will name the curried version of the map function of a bifunctor with &quot;bimap&quot;</p><div class="wit-content" /></section><section><p>components</p><div class="wit-content"><section><p>by fixing a component of the source product category : we get a functor on the other component :</p><div class="wit-content" /></section><section><p>map_1 f = bimap f id map_2 f = bimap id f</p><div class="wit-content" /></section><section><p>in haskell folklore the naming is &quot;first&quot; = &#39;map_1&#39;, &quot;second&quot; = &#39;map_2&#39;</p><div class="wit-content" /></section></div></section><section><p>playing with the composition law :</p><div class="wit-content"><section><p>writing the arrows as pairs of arrows in the source categories :</p><div class="wit-content"><section><p>map ((f1, f2) &gt;&gt;&gt; (g1, g2)) = map (f1, f2) &gt;&gt;&gt; map (g1, g2)</p><div class="wit-content" /></section></div></section><section><p>the left side of this rewritten by the definition of product category : :</p><div class="wit-content"><section><p>map (f1 &gt;&gt;&gt; g1, f2 &gt;&gt;&gt; g2) = map (f1, f2) &gt;&gt;&gt; map (g1, g2)</p><div class="wit-content" /></section></div></section><section><p>with the curried map function :</p><div class="wit-content"><section><p>bimap (f1 &gt;&gt;&gt; g1) (f2 &gt;&gt;&gt; g2) = bimap f1 f2 &gt;&gt;&gt; bimap g1 g2</p><div class="wit-content" /></section></div></section><section><p>because a bifunctor is also a functor : this composition law is ensured by parametricity</p><div class="wit-content" /></section><section><p>by choosing</p><div class="wit-content"><section><p>g1 = f2 = id :</p><div class="wit-content"><section><p>we have :</p><div class="wit-content"><section><p>bimap (f1 &gt;&gt;&gt; id) (id &gt;&gt;&gt; g2) = bimap f1 id &gt;&gt;&gt; bimap id g2</p><div class="wit-content" /></section></div></section><section><p>which is :</p><div class="wit-content"><section><p>bimap f1 g2 = map_1 f1 &gt;&gt;&gt; map_2 g2</p><div class="wit-content" /></section></div></section><section><p>by rename :</p><div class="wit-content"><section><p>bimap h1 h2 = map_1 h1 &gt;&gt;&gt; map_2 h2</p><div class="wit-content" /></section></div></section></div></section><section><p>f1 = g2 = id :</p><div class="wit-content"><section><p>we have :</p><div class="wit-content"><section><p>bimap (id &gt;&gt;&gt; g1) (f2 &gt;&gt;&gt; id) = bimap id f2 &gt;&gt;&gt; bimap g1 id</p><div class="wit-content" /></section></div></section><section><p>which is :</p><div class="wit-content"><section><p>bimap g1 f2 = map_2 f2 &gt;&gt;&gt; map_1 g1</p><div class="wit-content" /></section></div></section><section><p>by rename :</p><div class="wit-content"><section><p>bimap h1 h2 = map_2 h2 &gt;&gt;&gt; map_1 h1</p><div class="wit-content" /></section></div></section></div></section><section><p>these resultant equations have the same left side, hence their right side must equal too : map_1 and map_2 commute : </p><div class="wit-content"><section><p>(map_1 h1 &gt;&gt;&gt; map_2 h2) = (map_2 h2 &gt;&gt;&gt; map_1 h1)</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>bimap from map_1 and map_2</p><div class="wit-content"><section><p>the (bimap f g = map_1 f &gt;&gt;&gt; map_2 g) equality gives a way to derive bimap from map_1 and map_2</p><div class="wit-content" /></section><section><p>for some bifunctors : it is easier to specify map_1 and map_2 instead of bimap; if we do so then of course we have to make sure that the identity law holds for map_1 and map_2; the composition law is ensured by parametricity; from the identity laws of map_1 and map_2 the identity law of bimap follows and then the composition law of bimap from parametricity</p><div class="wit-content" /></section></div></section></span></body></html>