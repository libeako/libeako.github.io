<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>high level</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="rmciseizvhdgclym.html">user interface</a></span><span class="wit-nav-item"><a href="oeyeaezscdudpssh.html">formal languages</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">software coding</a></span><span class="wit-nav-item"><a href="ftkadhwzfhvfbwnk.html">correct by construction</a></span><span class="wit-nav-item"><a href="brqzviybtynlulwl.html">avoiding dangers</a></span><span class="wit-nav-item"><a href="zxsbxwlppaypmpnn.html">functional programming</a></span><span class="wit-nav-item"><a href="rqeeitsvmgrogdjp.html">introduction</a></span><span class="wit-nav-item"><a href="xaxqaihzanoadfll.html">advantages</a></span><span class="wit-nav-item"><a href="nmzlpnpnrsfmunrf.html">increases rum-time efficiency</a></span><span class="wit-nav-item wit-nav-current-page">high level</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>equational reasoning in functional programming enables high level program transformations for runtime efficiency increase</p><div class="wit-content" /></section><section><p>example</p><div class="wit-content"><section><p>in absence of side effects : ((map f) &gt;&gt;&gt; (map g)) is semantically equivalent to (map (f &gt;&gt;&gt; g)); but the later one is more runtime-efficient, because it iterates the collection once [with the function (f &gt;&gt;&gt; g)] while the former one iterates the collection twice [first with function f then with function g]; hence it is worth to perform the transformation</p><div class="wit-content" /></section><section><p>but if side-effects may be present in f or g then the 2 versions are not necessarily equivalent</p><div class="wit-content"><section><p>for example</p><div class="wit-content"><section><p>imagine that both f and g logs its name; then</p><div class="wit-content"><section><p>((map f) &gt;&gt;&gt; (map g)) logs ff...fgg...g</p><div class="wit-content" /></section><section><p>(map (f &gt;&gt;&gt; g)) logs fgfg...fg</p><div class="wit-content" /></section></div></section><section><p>so their logs are different, thus they are not equivalent</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>in haskell such optimization transformations can be specified by the coder, to then be automatically performed by the compiler</p><div class="wit-content"><section><p>library authors often write such rewrite rules for their functions</p><div class="wit-content" /></section><section><p>the best thing about such automatic transformation compared to manual ones is that the automatic one is performed by the compiler, hence it is performed across function- and library-boundaries too</p><div class="wit-content" /></section></div></section></span></body></html>