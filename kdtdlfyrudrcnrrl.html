<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>programming and logic</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="nnsmzqwudqobukpt.html">fund</a></span><span class="wit-nav-item"><a href="hssphyjgxuopzugc.html">programming</a></span><span class="wit-nav-item wit-nav-current-page">programming and logic</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>this section presents the famous and very important correspondence between programming and logic</p><div class="wit-content" /></section><section><p>it has been one of the greatest piece of knowledge i have ever learned in programming</p><div class="wit-content" /></section><section><p>this correspondence is known by several names</p><div class="wit-content"><section><p>the most popular ones are</p><div class="wit-content"><section><p>&quot;propositions-as-types&quot;</p><div class="wit-content" /></section><section><p>&quot;curry-howard correspondence&quot;</p><div class="wit-content" /></section></div></section></div></section><section><p>i want to present it by not immediately telling it to you, but leading you to it on a path step-by-step; my derivation will resemble how one could get to it on his|her own; my goal with choosing this approach is to show that it is not some lucky arbitrary correspondence, but a deep, strong, natural connection</p><div class="wit-content" /></section><section><p><a href="oirlocgmsfwjamli.html">the derivation</a></p><div class="wit-content" /></section><section><p>i stop using category theory from here</p><div class="wit-content"><section><p>programming --- logic</p><div class="wit-content" /></section><section><p>type --- statement</p><div class="wit-content" /></section><section><p>function between types --- proof of implication between statements</p><div class="wit-content" /></section><section><p>inhabited type --- constant true</p><div class="wit-content" /></section><section><p>empty type --- constant false</p><div class="wit-content" /></section></div></section><section><p>so far coders thought that they can use their programming language mainly for  implementing programs only; but with the programming-logic correspondence we gain the ability to use the same programming language for logic tasks too</p><div class="wit-content" /></section><section><p>in the following i will use</p><div class="wit-content"><section><p>function (rep : Statement -&gt; Type) that outputs the type representing the input statement; answering the questions which statements can be represented [the domain of this function] and how [the implementation of this function] is postponed</p><div class="wit-content" /></section><section><p>function (derep : Type -&gt; Set Statement)</p><div class="wit-content"><section><p>is the inverse of rep [as a relation]</p><div class="wit-content" /></section><section><p>it returns a collection of statements</p><div class="wit-content" /></section></div></section></div></section><section><p>proving</p><div class="wit-content"><section><p>completing the definition (x : T = ...) proves that a value of T exists, but then [by the programming-logic correspondence] (derep T) is true; so one can prove statement S by showing up a value of (rep S); so values of (rep S) act like witnesses of S</p><div class="wit-content" /></section><section><p>expressions [&quot;programs&quot;] that produce a witness are proofs</p><div class="wit-content" /></section><section><p>static type checking verifies the proof; proving do not require runtime work from the program that the proof is in</p><div class="wit-content" /></section><section><p>what about (x : Empty = x) ?</p><div class="wit-content"><section><p>the problem</p><div class="wit-content"><section><p>this x witnesses that the Empty type has a value, thus it proves falsity and in turn falsity implies every statement; thus we can prove everything; however it feels like a logic does not have any value if it can prove everything; it looks like i contradicted my derivation, the whole programming-logic correspondence is buggy; fortunately : that is false, the programming-logic correspondence is not buggy; so (x : Empty = x) must be wrong; it smells anyway, because we know for sure that Empty does not have any value; but it passes static type-checking !</p><div class="wit-content" /></section></div></section><section><p>the solution</p><div class="wit-content"><section><p>remember that the programming-logic correspondence is a mathematical phenomena, so it needs to be true only for real mathematical objects; but (x : Empty = x) does not define a real mathematical object, because its evaluation recurses forever; the lesson learned : the programming-logic correspondence to be sound requires totality</p><div class="wit-content" /></section></div></section><section><p>this is the big reason why the importance of totality checking in the future will grow [as the practice of proving grows]; preferably the programming language and the compiler will do much of the totality checking</p><div class="wit-content" /></section></div></section></div></section><section><p><a href="huktyxsxcfntvnbj.html">representing logical constructs</a></p><div class="wit-content" /></section><section><p>modern type systems [for example the calculus of constructions] are powerful enough to express higher order logical statements and their proofs, and also are simple and intuitive; hence we can expect that future programming languages will build on them; the idris programming language is already an example of this; in these simple but powerful languages we can do all of the following activities</p><div class="wit-content"><section><p>creata a data type model of the domain of the program</p><div class="wit-content" /></section><section><p>state mathematical theorems about the domain of the program</p><div class="wit-content" /></section><section><p>proove those theorems</p><div class="wit-content" /></section><section><p>specify the task of the program</p><div class="wit-content" /></section><section><p>implement the program</p><div class="wit-content" /></section><section><p>verify that the program complies to the specification</p><div class="wit-content" /></section></div></section><section><p>it is worth to stress again : all these activities can be performed in the same, simple programming language; one does not need to learn a new language for the logic tasks, but can use the same programming language as he|she is accustomed to from program implementation; also : all the tools of coding invented to construct programs can be used to construct statements and proofs</p><div class="wit-content" /></section><section><p>additional source</p><div class="wit-content"><section><p>philip wadler is a researcher in computer science and did much of his work around the programming-logic correspondence; he produced good introductory material; i highly recommend to you to watch and read them</p><div class="wit-content"><section><p><a href="https://www.youtube.com/watch?v=aeRVdYN6fE8">talk from 2016</a></p><div class="wit-content" /></section><section><p>article</p><div class="wit-content"><section><p><a href="http://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf">Propositions as Types</a></p><div class="wit-content" /></section><section><p>this text is a masterpiece</p><div class="wit-content" /></section><section><p>i read it twice</p><div class="wit-content"><section><p>once when i was very noobish, i hardly knew anything about this or related subjects; the text was still understandable somewhat</p><div class="wit-content" /></section><section><p>but when i already knew some lambda calculus, type theory and logic then it struck me how well phil wadler could explain the topic; the text is structured very well, it is compact, precise, deep, understandable, interesting</p><div class="wit-content" /></section></div></section></div></section></div></section></div></section></span></body></html>