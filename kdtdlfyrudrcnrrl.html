<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>proposition as type</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="nnsmzqwudqobukpt.html">fund</a></span><span class="wit-nav-item"><a href="aacixgsdjlspuizr.html">derivation system</a></span><span class="wit-nav-item"><a href="hoqxwlarqggqsrwp.html">type</a></span><span class="wit-nav-item wit-nav-current-page">proposition as type</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>logic emerges from type theory; logical concepts can be represented by the most basic type theoretical concepts; logical propsitions can be represented by types, logical proofs can be represented by constructed objects; the importance of this simple and natural idea is fundamental and huge</p><div class="wit-content"><section><p>it is not overstatement that this is a most fundamental development science in the 20th century</p><div class="wit-content" /></section></div></section><section><p>this idea can be used both in mathematics and in programming and gives a simple, natural and powerful theoretical foundation for both of them</p><div class="wit-content"><section><p>the similarities between math and programming is not a coincidence, the outer-most layer of programming is math, as both of them are just about construction of mathematial objects, programs are mathematical objects, even if their use case of the program is not specially mathematical</p><div class="wit-content" /></section></div></section><section><p>it is one of the greatest piece of knowledge i have ever learned in programming</p><div class="wit-content" /></section><section><p>the name of this idea is &quot;propositions as types&quot; or sometimes &quot;Curry Howard correspondence&quot;</p><div class="wit-content" /></section><section><p>this idea connects the logical and the constructive worlds, by expressing logics with type-theory; what are these 2 worlds? the constructive world lets us construct mathematical objects, like lambda calculus; the logical world is the propositions and their proofs; of course the constructive world can and always could express anything generally, including logical concepts, but before &#39;propositions as types&#39; the logical part existed above the constructive world, treated separately, had a separate dedicated language and separate rules [of validity]; with &#39;props as types&#39; the logical world exists inside the constructive world [same level], does not need a separate language (other than the language of construction) and can be about the objects of the constructive world</p><div class="wit-content" /></section><section><p>this idea is not tricky, it is not only a human invention; instead it has a deep and simple and natural theoretical foundation; here is the </p><div class="wit-content" /></section><section><p><a href="ekondytrrodzxtui.html">derivation of the core idea</a></p><div class="wit-content" /></section><section><p>the core idea</p><div class="wit-content"><section><p>the proposition represented by a type is true if and only if the type is inhabitedthe proposition represented by a type is true if and only if the type is inhabited</p><div class="wit-content" /></section></div></section><section><p>how can we prove a proposition? the question translates to types as follows: how can we prove that a type is inhabited? the answer is trivial: we show an instance of the type; by &#39;show&#39; i mean we declare it to have that type and give a definition to it; the static type-checking is the verification of the proof</p><div class="wit-content" /></section><section><p>examples of representing simple statements</p><div class="wit-content"><section><p><a href="cteoxhjanjufrioe.html">equality</a></p><div class="wit-content" /></section></div></section><section><p>the proposition as type idea can be proved to be correct by a simple structural induction - induction on the structure of the statements; statements can be either primitive or composite</p><div class="wit-content"><section><p>among [the types representing] the primitive statements no relation exists, hence no consistency problems may be</p><div class="wit-content" /></section><section><p>hence all is needed is to prove the consistency of the representation of composite statements, which can be done individually per type of logical construct</p><div class="wit-content" /></section></div></section><section><p>notation for the work that follows</p><div class="wit-content"><section><p>multiple names are used to refer to empty types: &quot;()&quot; [- the empty tuple type], &quot;Empty&quot;, &quot;False&quot;, &quot;Absurd&quot;</p><div class="wit-content" /></section><section><p>representation correspondence</p><div class="wit-content"><section><p>rep : Proposition -&gt; Type</p><div class="wit-content"><section><p>outputs the type representing the input proposition</p><div class="wit-content" /></section></div></section><section><p>derep : Type -&gt; Proposition</p><div class="wit-content"><section><p>inverse of rep</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p><a href="huktyxsxcfntvnbj.html">representing logical constructs</a></p><div class="wit-content" /></section><section><p><a href="tucpuipfoxmuftxd.html">representing logical axioms</a></p><div class="wit-content" /></section><section><p>appreciation</p><div class="wit-content"><section><p>it is remarkable that now we can use a single simple functional programming language to model the world [domain of the client], propose statements about the world, prove those statements, specify the task of a program, implement the program, verify that the program fulfills the specification</p><div class="wit-content" /></section></div></section><section><p><a href="ekondytrrodzxtui.html">additional sources</a></p><div class="wit-content" /></section></span></body></html>