<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>generalized sum type</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="nnsmzqwudqobukpt.html">fund</a></span><span class="wit-nav-item"><a href="znuvgowivqvqbdhr.html">language</a></span><span class="wit-nav-item"><a href="jaxbiyrfnbhaormb.html">general language</a></span><span class="wit-nav-item wit-nav-current-page">generalized sum type</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>an other name for these is &quot;generalized algebraic datatypes [GADTs]&quot;</p><div class="wit-content" /></section><section><p>the generalization is that the constructors [the members] of the sum type specify their exact return type; of course: all constructors have to return a value that is of the sum type the constructor is a member of; but the generalized version allows more precise specification of the return type; how can it be more precise? remember that types [as type functions], including sum types, can have inputs too; constructors of generalized sum types can specify those too</p><div class="wit-content" /></section><section><p>an example:</p><div class="wit-content" /></section><section><p>datatype Expression =</p><div class="wit-content"><section><p>| I Int</p><div class="wit-content" /></section><section><p>| B Bool</p><div class="wit-content" /></section><section><p>| Plus Expression Expression</p><div class="wit-content" /></section><section><p>| And Expression Expression</p><div class="wit-content" /></section></div></section><section><p>we can construct values of this datatype:</p><div class="wit-content"><section><p>Plus (I 3) (I 5)</p><div class="wit-content" /></section><section><p>And (B True) (B False)</p><div class="wit-content" /></section></div></section><section><p>these are valid expressions</p><div class="wit-content" /></section><section><p>but our current datatype also contain invalid values</p><div class="wit-content"><section><p>example</p><div class="wit-content"><section><p>Plus (I 5) (B True)</p><div class="wit-content" /></section></div></section><section><p>the addition of an integer and a boolean is non-sense</p><div class="wit-content" /></section></div></section><section><p>how to make such non-sense expressions ill-typed? the natural solution: we need to constrain &#39;Plus&#39; to accept only integer expressions and &#39;And&#39; to accept only boolean expressions; hence we need to distinguish between &#39;Expression&#39;s; the solution is to introduce a type input for &#39;Expression&#39;, indicating the type of its value:</p><div class="wit-content" /></section><section><p>datatype Expression v =</p><div class="wit-content"><section><p>| I Int</p><div class="wit-content" /></section><section><p>| B Bool</p><div class="wit-content" /></section><section><p>| Plus (Expression Int) (Expression Int)</p><div class="wit-content" /></section><section><p>| And (Expression Bool) (Expression Bool)</p><div class="wit-content" /></section></div></section><section><p>obviously: each constructor, only by being a member of &#39;Expression&#39;, returns a value with type &#39;Expression&#39;; but with what &#39;v&#39;? the answer is that they themselves do not care, as by them: &#39;v&#39; can be anything, they do not impose any constraint on &#39;v&#39;</p><div class="wit-content" /></section><section><p>we wanted the &#39;Plus (I 5) (B True)&#39; expression to become ill-typed; did it?</p><div class="wit-content" /></section><section><p>&#39;Plus&#39; constrains its input types; from this the type checker infers that both &quot;I 5&quot; and &quot;B True&quot; must have type &#39;Expression Int&#39;; because the constructor &#39;I&#39; and &#39;B&#39; both return an &#39;Expression v&#39;, not caring about &#39;v&#39;: these constructors just return what their application context requires from them, which in this case is &#39;Expression Int&#39;, includeing constructor &#39;B&#39;, hence no type-conflict arises; we understand that &#39;B True&#39; should have type &#39;Expression Bool&#39;, but simple sum type construction does not allow us to specify that</p><div class="wit-content" /></section><section><p>this is why we need to add this language feature: let the constructors specify their exact return types</p><div class="wit-content" /></section><section><p>the usual syntax for this langauge feature is to let the constructors specify their types as of functions:</p><div class="wit-content" /></section><section><p>datatype Expression v =</p><div class="wit-content"><section><p>I : Int -&gt; Expression Int</p><div class="wit-content" /></section><section><p>B : Bool -&gt; Expression Bool</p><div class="wit-content" /></section><section><p>Plus : Expression Int -&gt; Expression Int -&gt; Expression Int</p><div class="wit-content" /></section><section><p>And : Expression Bool -&gt; Expression Bool -&gt; Expression Bool</p><div class="wit-content" /></section></div></section><section><p>with this type definition: &#39;B True&#39; has type &#39;Expression Bool&#39; [v = Bool fixed], hence the expression &#39;Plus (I 5) (B True)&#39; contains a type conflict about v: &#39;Plus&#39; implies it to be &#39;Int&#39;, B implies it to be &#39;Bool&#39; =&gt; this conflict makes this invalid expression ill-typed</p><div class="wit-content" /></section><section><p>generalized sum types provide for us much additional type-safety and are a very natural and simple language feature, easy to understand, use and implement</p><div class="wit-content" /></section></span></body></html>