<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>generalized algebraic datatypes</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="rmciseizvhdgclym.html">user interface</a></span><span class="wit-nav-item"><a href="oeyeaezscdudpssh.html">formal languages</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">software coding</a></span><span class="wit-nav-item"><a href="jaxbiyrfnbhaormb.html">some basic prog lang notions</a></span><span class="wit-nav-item wit-nav-current-page">generalized algebraic datatypes</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>these are a generalization of sum types; the generalization is that the constructors [the members] of the sum type specify their exact return type; of course: all constructors have to return a value that is of the sum type the constructor is a member of; but GADTs allow more precise specification of the return type; how can it be more precise? remember that types [as type functions], including sum types, can have inputs too; constructors of GADTs can fix those</p><div class="wit-content" /></section><section><p>an example:</p><div class="wit-content" /></section><section><p>datatype Expression =</p><div class="wit-content"><section><p>| I Int</p><div class="wit-content" /></section><section><p>| B Bool</p><div class="wit-content" /></section><section><p>| Plus Expression Expression</p><div class="wit-content" /></section><section><p>| And Expression Expression</p><div class="wit-content" /></section></div></section><section><p>we can construct values of this datatype: &quot;Plus (I 3) (I 5)&quot;, &quot;And (B True) (B False)&quot;; these are valid expressions; but our current datatype also contain invalid values, for example &quot;Plus (I 5) (B True)&quot;</p><div class="wit-content" /></section><section><p>the natural solution: we need to constrain &#39;Plus&#39; to accept only integer expressions and &#39;And&#39; to accept only boolean expressions; hence we need to distinguish bettween &#39;Expression&#39;s; the solution is to introduce a type input for &#39;Expression&#39;, indicating the type of the its value:</p><div class="wit-content" /></section><section><p>datatype Expression v =</p><div class="wit-content"><section><p>| I Int</p><div class="wit-content" /></section><section><p>| B Bool</p><div class="wit-content" /></section><section><p>| Plus (Expression Int) (Expression Int)</p><div class="wit-content" /></section><section><p>| And (Expression Bool) (Expression Bool)</p><div class="wit-content" /></section></div></section><section><p>obviously: each constructor, only by being a member of &#39;Expression&#39;, return a value with type &#39;Expression&#39;; but with what &#39;v&#39;? the answer is that they themselves do not care, as by them: &#39;v&#39; can be anything, they do not impose any constraint on &#39;v&#39;</p><div class="wit-content" /></section><section><p>we wanted the &quot;Plus (I 5) (B True)&quot; expression to become ill-typed; did it? &#39;Plus&#39; constrains its input types; from this the type checker infers that both &quot;I 5&quot; and &quot;B True&quot; must have type &#39;Expression Int&#39;; because the constructor &#39;I&#39; and &#39;B&#39; both return an &#39;Expression v&#39;, not caring about &#39;v&#39;: no conflict arises, hence the type cheker accepts the whole expresson; &quot;B True&quot; should have type &quot;Expression Bool&quot;, but simple sum type construction does not allow us to specify that</p><div class="wit-content" /></section><section><p>this is why we need to add this language feature: let the constructors specify their exact return types</p><div class="wit-content" /></section><section><p>the usual syntax for this langauge feature is to let the constructors specify their types as functions:</p><div class="wit-content" /></section><section><p>datatype Expression v =</p><div class="wit-content"><section><p>I : Int -&gt; Expression Int</p><div class="wit-content" /></section><section><p>B : Bool -&gt; Expression Bool</p><div class="wit-content" /></section><section><p>Plus : Expression Int -&gt; Expression Int -&gt; Expression Int</p><div class="wit-content" /></section><section><p>And : Expression Bool -&gt; Expression Bool -&gt; Expression Bool</p><div class="wit-content" /></section></div></section><section><p>with this type definition: &quot;B True&quot; has type exactly &quot;Expression Bool&quot;, hence the expression &quot;Plus (I 5) (B True)&quot; contains a type conflict about v: &#39;Plus&#39; implies it to be &#39;Int&#39;, B implies it to be &#39;Bool&#39; =&gt; the invalid expression became ill-typed</p><div class="wit-content" /></section><section><p>thus generalized algebraic data types provide us much more type-safety, while being a very natural and simple language feature, easy to understand, use and implement</p><div class="wit-content" /></section></span></body></html>