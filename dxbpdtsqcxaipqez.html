<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>definition</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="oibaxnylzhpktgho.html">algebra</a></span><span class="wit-nav-item"><a href="cabjryjnnstdjmvb.html">monoid</a></span><span class="wit-nav-item"><a href="edsabrzmtmhnwgml.html">category</a></span><span class="wit-nav-item"><a href="yboclzmzvuwqxcdt.html">functor</a></span><span class="wit-nav-item"><a href="dkrtqrqtctaagtrx.html">functor in software coding</a></span><span class="wit-nav-item wit-nav-current-page">definition</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>the function pair that functor consists of is usually coded as a type-function interface :</p><div class="wit-content" /></section><section><p>interface Functor c where   map : (x -&gt; y) -&gt; (c x -&gt; c y)</p><div class="wit-content" /></section><section><p>in this code fragment :</p><div class="wit-content"><section><p>the mapping of types is &#39;c&#39;</p><div class="wit-content" /></section><section><p>the mapping of functions is &#39;map&#39;</p><div class="wit-content" /></section></div></section><section><p>the laws</p><div class="wit-content"><section><p>the above defining code described Functor as a pair of functions; what is missing from it is the requirement that this function-pair is a homomorphism; that is what is left for the laws</p><div class="wit-content" /></section><section><p>a transformation is homomorphism between algebras iff for all operation of the algebra : (the operation-result of transformed values) = (transformation of the operation-result)</p><div class="wit-content" /></section><section><p>let us go through all the methods in our algebra [category] and investigate when homomorphism would hold</p><div class="wit-content"><section><p>for easier understanding : keep in mind that &#39;c&#39; and &#39;map&#39; are the 2 components of the same mapping</p><div class="wit-content" /></section><section><p>the methods one-by-one :</p><div class="wit-content"><section><p>composition [of arrows]</p><div class="wit-content"><section><p>(map g &gt;&gt;&gt; map h) = map (g &gt;&gt;&gt; h)</p><div class="wit-content" /></section></div></section><section><p>objects of an arrow</p><div class="wit-content"><section><p>c (source f) = source (map f)</p><div class="wit-content"><section><p>this equality is true because :</p><div class="wit-content"><section><p>c (source f) = c (source (f : x -&gt; y)) = c x = source (_ : c x -&gt; c y) = source (map (f : x -&gt; y)) = source (map f)</p><div class="wit-content" /></section></div></section><section><p>hence we do not need to extend the laws regarding this method</p><div class="wit-content" /></section></div></section><section><p>analogously for the &#39;target&#39; operation</p><div class="wit-content" /></section></div></section><section><p>identity arrow of an object</p><div class="wit-content"><section><p>id (tf x) = map (id x)</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>summing up : the laws are [without showing the types] :</p><div class="wit-content"><section><p>map id = id</p><div class="wit-content" /></section><section><p>(map g &gt;&gt;&gt; map h) = map (g &gt;&gt;&gt; h)</p><div class="wit-content" /></section></div></section></div></section></span></body></html>