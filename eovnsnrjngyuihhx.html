<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>semigroup</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">information technology</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="oibaxnylzhpktgho.html">algebra</a></span><span class="wit-nav-item wit-nav-current-page">semigroup</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>same as a magma but has + 1 law: the binary operation is associative</p><div class="wit-content" /></section><section><p> i will use the name &quot;composition&quot; for this operation</p><div class="wit-content" /></section><section><p>in programming</p><div class="wit-content"><section><p>interface Semigroup t</p><div class="wit-content"><section><p>(⊕) : t -&gt; t -&gt; t</p><div class="wit-content"><section><p>-- associative</p><div class="wit-content" /></section></div></section></div></section><section><p>the law is written as comment; this is because the type system of most programming languages [including haskell] is not strong enough to conveniently express most of the laws [for example associativity]</p><div class="wit-content" /></section></div></section><section><p>some examples of semigroups</p><div class="wit-content"><section><p>i denote the examples with juxtaposition [separate the (collection of values) and the operation with only a space]</p><div class="wit-content" /></section><section><p></p><div class="wit-content"><section><p>numbers +</p><div class="wit-content" /></section><section><p>numbers *</p><div class="wit-content" /></section><section><p>numbers minimum</p><div class="wit-content" /></section><section><p>numbers maximum</p><div class="wit-content" /></section><section><p>lists (list concatenation)</p><div class="wit-content" /></section><section><p>endo-functions (function composition)</p><div class="wit-content"><section><p>f is endo-function iff exists t : (f : t -&gt; t)</p><div class="wit-content" /></section></div></section><section><p>sets union</p><div class="wit-content" /></section><section><p>sets intersection</p><div class="wit-content" /></section><section><p>propositions and</p><div class="wit-content" /></section><section><p>propositions or</p><div class="wit-content" /></section></div></section></div></section><section><p>the convenience of implicit semigroup inputs</p><div class="wit-content"><section><p>the associative composing operation makes us able to compose some values, for example the elements of a collection</p><div class="wit-content" /></section><section><p>recall the fold function:</p><div class="wit-content"><section><p>fold : i -&gt; (i -&gt; e -&gt; i) -&gt; Collection e -&gt; i</p><div class="wit-content" /></section></div></section><section><p>this form is general, the accumulating value has type [i] different from the element type of the collection [e]</p><div class="wit-content" /></section><section><p>in the special case when (i = e and a semigroup implementation of e exists)</p><div class="wit-content"><section><p>fold_semigroup : Semigroup e =&gt; e -&gt; Collection e -&gt; e</p><div class="wit-content" /></section><section><p>fold_semigroup i = fold i (⊕)</p><div class="wit-content" /></section><section><p>this version has one less inputs : the element combining function is missing; it is replaced by one more implicit input, a Semigroup implementation for e, which contains such combining function; this example implementation is just forwarding the call to the general fold function, explicitly forwarding the implicitly got combining function</p><div class="wit-content" /></section></div></section></div></section><section><p>creating new semigroups from existing ones</p><div class="wit-content"><section><p>composing via product type construction</p><div class="wit-content"><section><p>instance Semigroup (t1 t2) &lt;= (Semigroup t1, Semigroup t2) where</p><div class="wit-content" /></section><section><p>(x11, x12) ⊕ (x21, x22) = (x11 ⊕ x21, x21 ⊕ x22)</p><div class="wit-content" /></section><section><p>of course this works with any kind of product type [any tuples, vectors]</p><div class="wit-content" /></section></div></section><section><p>through non-existance</p><div class="wit-content"><section><p>instance Semigroup (Maybe x) &lt;= Semigroup x where</p><div class="wit-content" /></section><section><p>just x1 ⊕ just x2 = just (x1 ⊕ x2) _ -&gt; none</p><div class="wit-content" /></section></div></section></div></section></span></body></html>