<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>more about Lens</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="rmciseizvhdgclym.html">user interface</a></span><span class="wit-nav-item"><a href="oeyeaezscdudpssh.html">formal languages</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">software coding</a></span><span class="wit-nav-item"><a href="flktedmyhawaehus.html">abstractions from mathematics</a></span><span class="wit-nav-item"><a href="xmtpmaqybielrpxs.html">category theory</a></span><span class="wit-nav-item"><a href="ybwmxqdoenunvcsk.html">optics</a></span><span class="wit-nav-item"><a href="ndgkrnbojyputpec.html">introduction</a></span><span class="wit-nav-item"><a href="qgynnejyblmswscl.html">the concrete representation</a></span><span class="wit-nav-item wit-nav-current-page">more about Lens</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>a runtime performance improvement</p><div class="wit-content"><section><p>lens is lift, it can lift a function from the content level to the container level : </p><div class="wit-content" /></section><section><p>lift : Lens e c -&gt; (e -&gt; e) -&gt; (c -&gt; c)</p><div class="wit-content" /></section><section><p>lift lens f c = set lens (f (get lens c) c</p><div class="wit-content" /></section><section><p>the &#39;lift&#39; function uses both the &#39;get&#39; and &#39;set&#39; methods of Lens and it uses them separately; this can be wasteful, especially when the path between container and the focused element is long; this is the case for example when lens represents an element in an associative data structure at a fixed index</p><div class="wit-content" /></section><section><p>this problem can be easily eliminated by modifying the data structure representing lens to an equivalent one but which merges the 2 accessors</p><div class="wit-content" /></section><section><p>the data structure i used to introduce lens :</p><div class="wit-content"><section><p>let Lens e c = { get : c -&gt; e, set : e -&gt; c -&gt; c }</p><div class="wit-content" /></section></div></section><section><p>after flipping the input order in &#39;set&#39; :</p><div class="wit-content"><section><p>let Lens e c = { get : c -&gt; e, set : c -&gt; e -&gt; c }</p><div class="wit-content" /></section></div></section><section><p>now both data members are functions with common input type [&#39;c&#39;]; we can swap a product of 2 such functions to a function into product :</p><div class="wit-content"><section><p>let Lens e c = c -&gt; (e (e -&gt; c))</p><div class="wit-content" /></section></div></section><section><p>the lift function with the new lens representation is</p><div class="wit-content"><section><p>lift : Lens e c -&gt; (e -&gt; e) -&gt; (c -&gt; c)</p><div class="wit-content" /></section><section><p>lift lens f c_old = let r = lens c_old in (second r) (f (first r))</p><div class="wit-content" /></section><section><p>by sharing the output of the lens function [&#39;r&#39;] we avoid to reach the focused element twice</p><div class="wit-content" /></section></div></section></div></section><section><p>comparing to c#&#39;s properties</p><div class="wit-content"><section><p>if you are a c# programmer then the lens concept may remind you about what is known as &quot;properties&quot; in the c# language</p><div class="wit-content" /></section><section><p>generally in any imperative language one would write </p><div class="wit-content"><section><p>w.x.y = new_value</p><div class="wit-content" /></section></div></section><section><p>to set the value of a member 2 layers below an object</p><div class="wit-content" /></section><section><p>functional programmers would not do that to avoid state mutation, but instead they would use lens as follows :</p><div class="wit-content"><section><p>put (lens_x &lt;&lt;&lt; lens_y) new_value w</p><div class="wit-content" /></section><section><p>this syntactlcally looks longer, but conceptually has the same complexity as in imperative language</p><div class="wit-content" /></section></div></section><section><p>but optics are much better than language-level &quot;references&quot;</p><div class="wit-content"><section><p>they are first class</p><div class="wit-content"><section><p>lens is the reification of language level references; we can store them, get them as input of function, give them as output of function</p><div class="wit-content" /></section></div></section><section><p>they are functional</p><div class="wit-content" /></section><section><p>properties as in c# correspond to only lens; but lens is only one category of optics</p><div class="wit-content" /></section><section><p>optics are not constrained technically by the language; a c# property must be in the container class; with lens one can focus the element of a map - without having to modify the code of the map data structure</p><div class="wit-content" /></section><section><p>lens can merge the get and set methods to save execution time</p><div class="wit-content" /></section></div></section></div></section></span></body></html>