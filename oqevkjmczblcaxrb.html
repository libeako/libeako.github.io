<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>proposition as sum</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="nnsmzqwudqobukpt.html">fund</a></span><span class="wit-nav-item"><a href="aacixgsdjlspuizr.html">derivation system</a></span><span class="wit-nav-item"><a href="hoqxwlarqggqsrwp.html">type</a></span><span class="wit-nav-item"><a href="kdtdlfyrudrcnrrl.html">proposition as type</a></span><span class="wit-nav-item"><a href="cteoxhjanjufrioe.html">equality</a></span><span class="wit-nav-item wit-nav-current-page">proposition as sum</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>here i describe a representation of equality proposition as a sum type</p><div class="wit-content" /></section><section><p>EqS (t : Type) (a : t) (b : t) :=</p><div class="wit-content"><section><p>refl : EqS t a a</p><div class="wit-content" /></section></div></section><section><p>&quot;EqS&quot; is short of &quot;equality as sum type&quot;</p><div class="wit-content" /></section><section><p>&#39;refl&#39; is short for &quot;reflexivity&quot;; reflecting the fact that it constructs reflexive pairs among the equality as binary relation</p><div class="wit-content" /></section><section><p>converting to and from definitional equality</p><div class="wit-content"><section><p>from</p><div class="wit-content"><section><p>at conversion site this type is required:</p><div class="wit-content"><section><p>EqS a b</p><div class="wit-content" /></section></div></section><section><p>the constructor function produces a</p><div class="wit-content"><section><p>EqS a a</p><div class="wit-content" /></section></div></section><section><p>hence the constructor can be invoked iff a and b unifies, that is iff a = b</p><div class="wit-content"><section><p>this is why </p><div class="wit-content"><section><p>the existence of an instance of </p><div class="wit-content" /></section><section><p>EqS a b</p><div class="wit-content" /></section><section><p>is a proof of (a == b)</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>to - this is possible by pattern matching</p><div class="wit-content"><section><p>p : EqS t a b ... (case p of refl  {-- here the compiler learns --} -&gt; ... ) ...</p><div class="wit-content" /></section><section><p>the compiler learns that a and b are equal</p><div class="wit-content" /></section><section><p>because</p><div class="wit-content"><section><p>p will have 2 types</p><div class="wit-content"><section><p>EqS t a b</p><div class="wit-content"><section><p>from the declaration of p</p><div class="wit-content" /></section></div></section><section><p>EqS t a a</p><div class="wit-content"><section><p>from the pattern matching, where the only constructor of the sum type is supposed to have been used to create p</p><div class="wit-content" /></section></div></section></div></section><section><p>which [of course] must be the same</p><div class="wit-content" /></section></div></section></div></section></div></section></span></body></html>