<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>the derivation</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="nnsmzqwudqobukpt.html">fund</a></span><span class="wit-nav-item"><a href="hoqxwlarqggqsrwp.html">type</a></span><span class="wit-nav-item"><a href="kdtdlfyrudrcnrrl.html">programming and logic</a></span><span class="wit-nav-item wit-nav-current-page">the derivation</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>the strategy</p><div class="wit-content"><section><p>you may have already read</p><div class="wit-content" /></section><section><p><a href="gxrbghpwcjceccgu.html">my writing about the correspondence between programming and category theory</a></p><div class="wit-content" /></section><section><p>i will show the correspondence between category theory and logic</p><div class="wit-content" /></section><section><p>by the transitivity of correspondence we get the correspondence between programming and logic</p><div class="wit-content" /></section></div></section><section><p>propositions as types</p><div class="wit-content"><section><p>i start with the recap of correspondence between programming and category</p><div class="wit-content"><section><p>programming --- category theory</p><div class="wit-content" /></section><section><p>type --- object</p><div class="wit-content" /></section><section><p>function between types --- arrow between objects</p><div class="wit-content" /></section></div></section><section><p>i intend this to be a table, just the formatting is poor</p><div class="wit-content" /></section><section><p>so the plan is to extend this table with a new column, for logic</p><div class="wit-content"><section><p>programming --- category theory --- logic</p><div class="wit-content" /></section><section><p>type --- object --- ...</p><div class="wit-content" /></section><section><p>function between types --- arrow between objects --- ...</p><div class="wit-content" /></section></div></section><section><p>to find out what objects and arrows in a category correspond to from logic : we search for famous categories from logic; one such is the category of implications between logical statements</p><div class="wit-content"><section><p>programming --- category theory --- logic</p><div class="wit-content" /></section><section><p>type --- object --- statement</p><div class="wit-content" /></section><section><p>function between types --- arrow between objects --- implication between statements</p><div class="wit-content" /></section></div></section><section><p>immediately using the transitivity on what we have so far : we get that</p><div class="wit-content"><section><p>logical statements correspond to types in programming</p><div class="wit-content"><section><p>this is where the popular name &quot;propositions-as-types&quot; comes from for this correspondence</p><div class="wit-content" /></section></div></section><section><p>a multiplicity mismatch exists in this correspondence</p><div class="wit-content"><section><p>in logic : exactly 0 or 1 implications exist between 2 statements</p><div class="wit-content" /></section><section><p>in programming : multiple distinct functions may exist between 2 types</p><div class="wit-content" /></section><section><p>ups</p><div class="wit-content" /></section><section><p>a solution to this problem is to change our choice of implication as a correspondent of arrows in the category to proofs of the implication; multiple proofs may exist of an implication, hence this solves the multiplicity problem</p><div class="wit-content" /></section><section><p>the updated correspondence table so far</p><div class="wit-content"><section><p>programming --- category theory --- logic</p><div class="wit-content" /></section><section><p>type --- object --- statement</p><div class="wit-content" /></section><section><p>function between types --- arrow between objects --- proof of implication between statements</p><div class="wit-content" /></section></div></section></div></section></div></section></div></section><section><p>truth values</p><div class="wit-content"><section><p>what we have so far is a poor world of logic, we have only statements, implications and proofs; we miss fundamental notions of logic : the truth values; i will allow myself to treat the truth values as constant statements; we already have statements in our system, thus they will fit in well</p><div class="wit-content"><section><p>programming --- category theory --- logic</p><div class="wit-content" /></section><section><p>type --- object --- statement</p><div class="wit-content" /></section><section><p>function between types --- arrow between objects --- proof of implication between statements</p><div class="wit-content" /></section><section><p>... --- ... --- true</p><div class="wit-content" /></section><section><p>... --- ... --- false</p><div class="wit-content" /></section></div></section><section><p>following the main strategy : i seek corresponding things to these new logical things [the truth values] in category; these new things are statements, hence in category i seek objects; this plan seems hopeless at first : the objects in a category seem homogenous from our general perspective, how could we select from among them? the solution is to analyze the properties of the truth values inside the system of logic and translate those properties in the category; hence i analyze the properties of the truth values; how could we define these in our small system of logic developed so far? i can not use the truth values themselves in the definition, because they are what i am trying to define; so i can use only the rest of my small system of logic; what does that small system contain? statements, implications, proofs; the solution is in implication; remember : an implication m =&gt; n is true iff (n is true) or (m is false); so (truth is implicated by everything) and (false implicates everything); because our perspective on logic is general, the truth value are the only statements which have these properties; so these properties specify the false and true statements precisely</p><div class="wit-content"><section><p>programming --- category theory --- logic</p><div class="wit-content" /></section><section><p>type --- object --- statement</p><div class="wit-content" /></section><section><p>function between types --- arrow between objects --- proof of implication between statements</p><div class="wit-content" /></section><section><p>... --- object that has arrow from every object --- constant true</p><div class="wit-content" /></section><section><p>... --- object that has arrow into every object --- constant false</p><div class="wit-content" /></section></div></section><section><p>accordingly : the new things in category are</p><div class="wit-content"><section><p>object that has arrow from every object</p><div class="wit-content" /></section><section><p>object that has arrow into every object</p><div class="wit-content" /></section></div></section><section><p>the next subtask is to find correspondents to these in programming</p><div class="wit-content"><section><p>it is trivial</p><div class="wit-content"><section><p>type that has function from every type ---- object that has arrow from every object</p><div class="wit-content" /></section><section><p>type that has function into every type --- object that has arrow into every object</p><div class="wit-content" /></section></div></section><section><p>in these expressions the existence of functions mean mathematical existence; with other words : not that john doe has actually typed their code into the source of a concrete program, but rather [with his words] the implementability of such functions</p><div class="wit-content" /></section></div></section></div></section><section><p>habitation</p><div class="wit-content"><section><p>we can improve the intuition in these new things in programming</p><div class="wit-content" /></section><section><p>i will use a property of types named &quot;inhabited&quot;, it means the type has at least one element</p><div class="wit-content" /></section><section><p>if you find multiplicity mismatch in the correspondence here then do not worry about it, it does not cause problem</p><div class="wit-content" /></section><section><p>type that has function from every type</p><div class="wit-content"><section><p>including from inhabited types; such function must map the existing elements of the source type to some elements of such type; that is possible if such type is inhabited</p><div class="wit-content" /></section><section><p>if a type is inhabited then function to it from every other type exists</p><div class="wit-content" /></section><section><p>putting the 2 statements above together results in that these types are exactly the inhabited types</p><div class="wit-content" /></section></div></section><section><p>type that has function to every type</p><div class="wit-content"><section><p>including into empty types; such function must be empty [in the set theoretical sense]; an empty function&#39;s domain is empty</p><div class="wit-content" /></section><section><p>if a type is un-inhabited then function from it to every other type exists [the empty function]</p><div class="wit-content" /></section><section><p>putting the 2 statements above together results in that these types are exactly the un-inhabited types</p><div class="wit-content" /></section></div></section><section><p>with these more intuitive expressions the table so far is</p><div class="wit-content"><section><p>programming --- category theory --- logic</p><div class="wit-content" /></section><section><p>type --- object --- statement</p><div class="wit-content" /></section><section><p>function between types --- arrow between objects --- proof of implication between statements</p><div class="wit-content" /></section><section><p>inhabited type --- object that has arrow from every object --- true</p><div class="wit-content" /></section><section><p>empty type --- object that has arrow into every object --- false</p><div class="wit-content" /></section></div></section><section><p>from here let Empty be a fixed empty type</p><div class="wit-content" /></section></div></section></span></body></html>