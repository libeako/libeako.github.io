<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>swapping container layers</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">information technology</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="rmciseizvhdgclym.html">user interface</a></span><span class="wit-nav-item"><a href="oeyeaezscdudpssh.html">formal languages</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">software coding</a></span><span class="wit-nav-item wit-nav-current-page">swapping container layers</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>here i introduce an often occuring coding pattern; it is related to containers; by container i mean things like List, Array, Maybe, Either, ...</p><div class="wit-content" /></section><section><p>consider composite containers with 2 layers :</p><div class="wit-content"><section><p>x (y t)</p><div class="wit-content" /></section><section><p>where x and y are container types and t is an unknown type of the elements they store</p><div class="wit-content" /></section></div></section><section><p>the main message of this section : one often wants to swap the 2 layers of such composite containers :</p><div class="wit-content"><section><p>swap : x (y t) -&gt; y (x t)</p><div class="wit-content" /></section></div></section><section><p>a concrete example :</p><div class="wit-content"><section><p>suppose</p><div class="wit-content"><section><p>y = Maybe x = List</p><div class="wit-content" /></section></div></section><section><p>then</p><div class="wit-content"><section><p>swap : List (Maybe t) -&gt; Maybe (List t)</p><div class="wit-content" /></section></div></section><section><p>such a function is what we need for example when the Maybe is used instead of thrown-and-caught exception : the swap function transforms a list of potentially not existing results to a potentially not existing List of results; Maybe is adequate to represent only the most primitive exception but one can trivially upgrade it to the Either type; one also is likely to want to have such swap function for container types other than List; with such swap functions in hand one can comfortably replace the usage of null values and exceptions with the simple type-safe solution of propagating the exceptional value through the function call stack</p><div class="wit-content" /></section></div></section><section><p>the implementation of these swap functions are usually trivial</p><div class="wit-content" /></section><section><p>if you did not yet know about this idea then i recommend you to keep your eyes open for the possibilities of using them and you will likely find plenty [especially if you use functional programming] and these swap functions will ease your coding work substantially</p><div class="wit-content" /></section><section><p>to increase your appetite : here are some more examples</p><div class="wit-content"><section><p>you may become surprised how many things are containers [at least in an abstract sense]</p><div class="wit-content" /></section><section><p>function</p><div class="wit-content"><section><p>swap : x (r -&gt; t) -&gt; (r -&gt; x t)</p><div class="wit-content" /></section><section><p>where the y = r -&gt; t function is a container of its output</p><div class="wit-content" /></section><section><p>this swap function can be used to push dependencies outward</p><div class="wit-content" /></section></div></section><section><p>parser</p><div class="wit-content"><section><p>swap : Date (Parser Int) -&gt; Parser (Date Int)</p><div class="wit-content" /></section><section><p>where Date is a 3-element container and Parser is the container of the value that it reads</p><div class="wit-content" /></section><section><p>this swap function produces a parser of Date from a parser of integer</p><div class="wit-content" /></section></div></section></div></section><section><p>naming</p><div class="wit-content"><section><p>one may want to prefer the name &quot;transpose&quot;, as motivated by the transpose operation on matrixes</p><div class="wit-content" /></section><section><p>haskell uses &quot;sequence&quot;</p><div class="wit-content" /></section></div></section><section><p>the number of swap functions</p><div class="wit-content"><section><p>one problem with these swap functions is that it is boring to write them; in case of m different x container types and n different y container types : one may need to implement asymptotically m*n swap functions</p><div class="wit-content" /></section><section><p>in programming languages with type function polymorphism this can be decreased to just 1</p><div class="wit-content"><section><p><a href="eyfagqcuwwajcnmt.html">link to &#39;type function polymorphism&#39;</a></p><div class="wit-content" /></section></div></section><section><p>alternatives</p><div class="wit-content"><section><p><a href="http://hackage.haskell.org/package/distributive">via distributive functor</a></p><div class="wit-content" /></section><section><p>via representable functor</p><div class="wit-content"><section><p>transpose :: (Representable f, Representable g) =&gt; f (g x) -&gt; g (f x)</p><div class="wit-content" /></section><section><p>see</p><div class="wit-content"><section><p><a href="mkybecwcndywdoos.html">representable functor</a></p><div class="wit-content" /></section></div></section></div></section><section><p>via Traversable and Applicative</p><div class="wit-content"><section><p>sequence : Traversable x, Applicative y =&gt; x (y t) -&gt; y (x t)</p><div class="wit-content" /></section></div></section></div></section><section><p>then one only needs to write the implementations of the interfaces (Representable or (Traversable and Applicative)) for its container types; this brings down the asymptotic amount of coding work to m+n</p><div class="wit-content" /></section><section><p>this is a nice example of how type function polymorphism is important in keeping the amount of code low</p><div class="wit-content" /></section></div></section></span></body></html>