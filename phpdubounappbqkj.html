<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>recurse-in-types</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="nnsmzqwudqobukpt.html">fund</a></span><span class="wit-nav-item"><a href="hoqxwlarqggqsrwp.html">type</a></span><span class="wit-nav-item wit-nav-current-page">recurse-in-types</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>this topic builds on </p><div class="wit-content"><section><p><a href="zdxruzhjrevtjynt.html">the propositions as types correspondence</a></p><div class="wit-content" /></section></div></section><section><p>recursion is dangerous, it can lead to accidental (inconsistency in logic) and (non-termination in computing); this is true for recursion in types too, but fortunately some constraints on (recursion in types) save us from these dangers</p><div class="wit-content" /></section><section><p>the problem</p><div class="wit-content"><section><p>in logic</p><div class="wit-content"><section><p>a proposition P is equivalent to the proposition &#39;P is true&#39;; hence if we define P recursively as &#39;P := P is false&#39; then &#39;P is true = P is false&#39;, which is contradiction, hence our logic must not allow such recursions</p><div class="wit-content" /></section></div></section><section><p>in type theory</p><div class="wit-content"><section><p>the previously examined &#39;P := P is false&#39; logical proposition would be represented in type theory as </p><div class="wit-content" /></section><section><p>P := P -&gt; Empty</p><div class="wit-content"><section><p>where &#39;Empty&#39; is an empty type</p><div class="wit-content" /></section></div></section><section><p>alternatively with datatype definition:</p><div class="wit-content"><section><p>datatype P = make-P (P -&gt; Empty)</p><div class="wit-content" /></section><section><p>with full constructor type syntax:</p><div class="wit-content"><section><p>datatype P where</p><div class="wit-content"><section><p>make-P : (P -&gt; Empty) -&gt; P</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>the existence of such a function should be suspicious from the start; it would be a method to construct a P from the proof that P is empty</p><div class="wit-content" /></section><section><p>generally the existence of non-sensical types are okay, one just would not be able to make [&quot;implement&quot;] instances of them; but constructor functions are special, as they do not have to be implemented by the user, as they are provided [implemented] by the language [the compiler]</p><div class="wit-content" /></section><section><p>operationally a compiler can implement this constructor function too, of course</p><div class="wit-content" /></section><section><p>but it would be a logical mistake</p><div class="wit-content"><section><p>here is some code</p><div class="wit-content"><section><p>unwrap : P -&gt; (P -&gt; Empty) := \ P f -&gt; f</p><div class="wit-content" /></section><section><p>no : P -&gt; Empty := \ p -&gt; unwrap p p</p><div class="wit-content" /></section><section><p>f : Empty := no (make-P no)</p><div class="wit-content" /></section></div></section><section><p>this code proves that a value &#39;f&#39; can be created of an empty type; which though is false, which implies that our logic is inconsistent, which would be bad</p><div class="wit-content" /></section><section><p>the code may seem to type-check and hence it may seem that operationally it will happen - a value of an empty type will be created in run-time; but it will not happen; what will happen is that the code of &#39;f&#39; will run without termination</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>the solution</p><div class="wit-content"><section><p>is to not allow recursions that would lead to logical inconsistency or non-termination but still allow recursions for constructions of recursive data-structures</p><div class="wit-content" /></section><section><p>the general form of a constructor of a datatype is</p><div class="wit-content"><section><p>c : forall (p : P) . ((A p -&gt; T) -&gt; T)</p><div class="wit-content"><section><p>where</p><div class="wit-content"><section><p>P is the type of parameters</p><div class="wit-content" /></section><section><p>A is the type of arity</p><div class="wit-content"><section><p>the arity describes the structure of the collection of T-s to be used in the construction of a new T</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>any other form may be expressed with this form</p><div class="wit-content" /></section><section><p><a href="https://cs.stackexchange.com/questions/55646/strict-positivity">Andrej Bauer wrote about this an awesome little post on cs.stackexchange</a></p><div class="wit-content" /></section></div></section><section><p>the condition is that the arity may not refer to the type getting defined</p><div class="wit-content" /></section></div></section></span></body></html>