<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>functor = content + context</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="oibaxnylzhpktgho.html">algebra</a></span><span class="wit-nav-item"><a href="cabjryjnnstdjmvb.html">monoid</a></span><span class="wit-nav-item"><a href="edsabrzmtmhnwgml.html">category</a></span><span class="wit-nav-item"><a href="yboclzmzvuwqxcdt.html">functor</a></span><span class="wit-nav-item"><a href="dkrtqrqtctaagtrx.html">functor in software coding</a></span><span class="wit-nav-item wit-nav-current-page">functor = content + context</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>functor is like collection, but more general</p><div class="wit-content" /></section><section><p>the &quot;content&quot; of the functor is everything that is dependent on the type parameter of the functor</p><div class="wit-content" /></section><section><p>the &quot;context&quot; is the complementer of the content [that is : everything that is not content]</p><div class="wit-content" /></section><section><p>the context is</p><div class="wit-content"><section><p>in the case of List : the elements are multiple and their order is stored</p><div class="wit-content" /></section><section><p>in the case of Maybe : possible non-existance</p><div class="wit-content" /></section><section><p>in case of function : dependency [on the input of the function]</p><div class="wit-content" /></section></div></section><section><p>&#39;map&#39; replaces all the content with the got function and does not change the context</p><div class="wit-content"><section><p>informal proof</p><div class="wit-content"><section><p>this is a consequence of parametricity and the functor laws</p><div class="wit-content" /></section><section><p>let us assume the signature</p><div class="wit-content"><section><p>map : (h : x -&gt; y) -&gt; (c x -&gt; c y)</p><div class="wit-content" /></section></div></section><section><p>a helper theorem : map behaves uniformly for all h</p><div class="wit-content"><section><p>proof</p><div class="wit-content"><section><p>parametricity prevents it from distinguishing based on the type of h</p><div class="wit-content" /></section><section><p>the programming language does not provide a way to look into the implementation of h; a function can be examined only by its behavior, that is only by its output for each possible input; but h is parametric in its output type, so map can not examine the output values of h, again because of parametricity</p><div class="wit-content" /></section></div></section></div></section><section><p>theorem : map replaces all the element values (v : x) with (h v)</p><div class="wit-content"><section><p>proof</p><div class="wit-content"><section><p>in the special case (not (x = y))</p><div class="wit-content"><section><p>map replaces an (c x) by an (c y)</p><div class="wit-content" /></section><section><p>thus map replaces the element values from type x to type y</p><div class="wit-content" /></section><section><p>because map does not know anything about y [because of parametricity]: it can create value of it only by invoking h</p><div class="wit-content" /></section></div></section><section><p>because of the behavior of map being uniform : map always does this, in case (x = y) too</p><div class="wit-content" /></section></div></section></div></section><section><p>theorem : map does not change the context</p><div class="wit-content"><section><p>proof</p><div class="wit-content"><section><p>in the special case (h = id)</p><div class="wit-content"><section><p>map h = map id = id</p><div class="wit-content" /></section><section><p>map does not change the context</p><div class="wit-content" /></section></div></section><section><p>because of the behavior of map being uniform : map never changes the context</p><div class="wit-content" /></section></div></section></div></section></div></section></div></section><section><p>&#39;map&#39; is about the content, hence the type function &#39;c&#39; is about the context</p><div class="wit-content" /></section><section><p>since the content can be replaced : it is the context that really characterizes a functor</p><div class="wit-content" /></section><section><p>parametricity makes the second law admissible</p><div class="wit-content"><section><p>observe that in the previous derivation i did not use the second law  [(map g &gt;&gt;&gt; map h) = map (g &gt;&gt;&gt; h)]; still i managed to completely characterize what (map f) does [changes the content by f, does not alter the context]; i was able to do this with the assumption of parametricity; from this characterization the second law follows</p><div class="wit-content" /></section></div></section></span></body></html>