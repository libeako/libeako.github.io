<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>polymorphic optics</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">coding</a></span><span class="wit-nav-item"><a href="flktedmyhawaehus.html">abstractions from mathematics</a></span><span class="wit-nav-item"><a href="xmtpmaqybielrpxs.html">category theory</a></span><span class="wit-nav-item"><a href="ybwmxqdoenunvcsk.html">optics</a></span><span class="wit-nav-item"><a href="ndgkrnbojyputpec.html">introduction</a></span><span class="wit-nav-item wit-nav-current-page">polymorphic optics</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>the generalization of lens</p><div class="wit-content"><section><p>a lens can be used to change a member of a product</p><div class="wit-content"><section><p>for example</p><div class="wit-content"><section><p>set : Lens y (x y) -&gt; y -&gt; (x y) -&gt; (x y) </p><div class="wit-content" /></section><section><p>set lens new_y old_pair = ...</p><div class="wit-content" /></section><section><p>y is changed in the pair to the new_y value</p><div class="wit-content" /></section></div></section></div></section><section><p>so far i used a simple typing scheme : the new value of the content data had the same type as the old value; but for example in the case of tuples : it is possible to replace a member of it with a new value of any type; and this is true not only with tuples, an other class of such types are ones whose member types are parameters of the container, for example :</p><div class="wit-content" /></section><section><p>let KeyValuePair k v = { key : k, value : v }</p><div class="wit-content" /></section><section><p>with such types all around us the wish arises to extend the typing of the optics so that changing not only the values, but also the types be possible; one solution is to have more type parameters of the optic; instead of a single container and a single content type, it will have 2 of each : one for the old and one for the new version of it; that is 2 2 = 4 type parameters</p><div class="wit-content" /></section><section><p>short notations of &quot;old&quot; and &quot;new&quot;</p><div class="wit-content"><section><p>&quot;o&quot; = &quot;old&quot;, &quot;n&quot; = &quot;new&quot;</p><div class="wit-content" /></section></div></section><section><p>by the above described generalization the lens type becomes this : </p><div class="wit-content" /></section><section><p>let Lens eo en co cn = { get : co -&gt; eo, set : en -&gt; co -&gt; cn }</p><div class="wit-content" /></section><section><p>such generalization of optics makes them more polymorphic, hence their popular &quot;polymorphic optics&quot; name</p><div class="wit-content" /></section></div></section><section><p>generalizing the type of lens was intuitive; that is why i started with it; now let us move on to the other ones</p><div class="wit-content" /></section><section><p>the generalization of isomorphism</p><div class="wit-content"><section><p>just because we make the type more general, its structure should remain the same, that is : it still should consist of 2 conversion functions; but the type of the conversion function now should change; hint to understand : an old container is needed to get an old content, a new content is needed to get a new container</p><div class="wit-content" /></section><section><p>let Isomorphism eo en co cn = { get : co -&gt; eo, build : en -&gt; cn }</p><div class="wit-content" /></section></div></section><section><p>the laws</p><div class="wit-content"><section><p>how does this generalization effect the laws?</p><div class="wit-content" /></section><section><p>this new type of isomorphism looks strange and suspicious at first glance; isomorphism has a simple law : its 2 conversion functions must be inverses of each other, but with this new general typing the conversion functions do not even look composable; but note that when the law can be proposed [when the typing allows composition [when eo == en and co = cn]] is still a special case and we can require the law to hold at least then; that is better than nothing, but it still feels bad that in the other cases this data type seems to be out of control of the law; in such cases we usually turn to parametricity, hoping that it constrains the value set of the general type to sensible values; [if you do not understand this reasoning then do not be afraid, because i was very hand-wavy and i do not really understand it either; to achieve parametricity we would want to make the container and content types parameterized by the old-new choice</p><div class="wit-content"><section><p><a href="iuvbupavbjmhfrxj.html">link to &#39;parametric polymorphosm&#39;</a></p><div class="wit-content" /></section></div></section><section><p>let Lens e c  = forall o n . { get : c o -&gt; e o, set :  e n -&gt; c o -&gt; c n }</p><div class="wit-content" /></section><section><p>let Isomorphism e c = forall o n . { get : c o -&gt; e n, build : e o -&gt; c n }</p><div class="wit-content" /></section><section><p>this would be nice, but unfortunately the typesystems of some programming languages [including haskell] is not flexible enough to work with this</p><div class="wit-content"><section><p>because</p><div class="wit-content"><section><p>neither type families nor type synonyms can be applied partially [at least in Haskell]</p><div class="wit-content" /></section><section><p>newtype-ing introduces wrapping noise</p><div class="wit-content" /></section></div></section></div></section><section><p>perhaps this technical constraint of our programming languages will cease at some time in the future; but for now i choose to use and teach the theoretically suspicious, but in practise everywhere usable typing of optics, the one with 4 technically independent type variables; this is the path chosen by the most popular optics library [&quot;lens&quot;] in haskell and a major optics library in purescript [&quot;profunctor-lenses&quot;]</p><div class="wit-content" /></section><section><p>but please keep in mind that this independence between the type parameters is only technical; you probably should still constrain yourself to use it only for the cases which can be expressed by the theoretically nicer typing too; with other words : we fall back to use the practical typing because of technical necessity and not to hack with out-of-concept optics</p><div class="wit-content" /></section></div></section><section><p>the generalization of prism</p><div class="wit-content"><section><p>a first guess could be :</p><div class="wit-content" /></section><section><p>let Prism eo en co cn = { match : co -&gt; Maybe eo, build : en -&gt; cn }</p><div class="wit-content" /></section><section><p>but this is not complete; a prism must be able to lift a function from the content level to the container level; for that we can use the &#39;build&#39; function; but build works only based on the element; but what if the old container does not contain an element? then the new container is the old container; at least so it was in the simple typing; but now the type has to change; we need to be able to change the type of the container in the case too when it does not actually contain an element; such a case splitting is already present in the &#39;match&#39; function; however it is about the complementer case; the straightforward solution is to extend that case splitting with the other case : </p><div class="wit-content" /></section><section><p>let Prism eo en co cn = { match : co -&gt; Either cn eo, build : en -&gt; cn }</p><div class="wit-content" /></section><section><p>i replaced (Maybe eo) with (Either cn eo), introducing the new type of the container</p><div class="wit-content" /></section></div></section><section><p>the generalization of traversal</p><div class="wit-content"><section><p>is trivial</p><div class="wit-content" /></section><section><p>let Traversal eo en co cn = forall f . Applicative f =&gt; (eo -&gt; f en) -&gt; (co -&gt; f cn)</p><div class="wit-content" /></section></div></section><section><p>less bugs</p><div class="wit-content"><section><p>by this generalization [as with any towards parametric polymorphism] : we also gain defence against some bugs in the implementations of functions around optics [for example of the &#39;compose&#39; and &#39;lift&#39; functions], which gain even alone is worth the extra complexity in the typing [at least in an implementation layer]</p><div class="wit-content"><section><p><a href="ipmcnbqgopeplpis.html">link to &#39;parametric polymorphism&#39;</a></p><div class="wit-content" /></section></div></section></div></section></span></body></html>