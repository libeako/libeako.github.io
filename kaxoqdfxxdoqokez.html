<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>polymorphic optics</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">coding</a></span><span class="wit-nav-item"><a href="flktedmyhawaehus.html">abstractions from mathematics</a></span><span class="wit-nav-item"><a href="xmtpmaqybielrpxs.html">category theory</a></span><span class="wit-nav-item"><a href="ybwmxqdoenunvcsk.html">optics</a></span><span class="wit-nav-item"><a href="ndgkrnbojyputpec.html">introduction</a></span><span class="wit-nav-item wit-nav-current-page">polymorphic optics</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>optics can replace the focused data with a new one; the new one obviously can have a different value, but also a different type; this is the case, for example, with tuples as containers; new tuple can always be formed, regardless of the type of the new value of its components; to enables optics types for type changing: they need to have more type parameters [they need to be more &quot;type-polymorphic&quot; [hence the name &quot;polymorphic optics&quot;]]</p><div class="wit-content" /></section><section><p>the ideal solution is to introduce stage parameters (old and new)</p><div class="wit-content"><section><p>short versions of &quot;old&quot; and &quot;new&quot;: &quot;o&quot; = &quot;old&quot;, &quot;n&quot; = &quot;new&quot;</p><div class="wit-content" /></section><section><p>the more polymorhic versions of some of the optic categories</p><div class="wit-content"><section><p>let Lens e c  = forall o n . { get : c o -&gt; e o, set :  e n -&gt; c o -&gt; c n }</p><div class="wit-content" /></section><section><p>let Isomorphism e c = forall o n . { get : c o -&gt; e n, build : e o -&gt; c n }</p><div class="wit-content" /></section></div></section><section><p>the laws stay the same, we just express them with (o = n)</p><div class="wit-content" /></section></div></section><section><p>doubling the type parameters</p><div class="wit-content"><section><p>unfortunately the &#39;stage parameters&#39; solution is problematic in the practice of Haskell, because Haskell does not yet support partial application of  either type families or type synonyms and newtype-ing would introduce wrapping noise; hence a less ideal but more practical solution is used: we just double the normal type parameters [&quot;c&quot; = &quot;container&quot;, &quot;e&quot; = &quot;element&quot;], each of them will have 2 versions, corresponding to the 2 stages</p><div class="wit-content" /></section><section><p>examples</p><div class="wit-content"><section><p>Lens eo en co cn := { get : co -&gt; eo, set : en -&gt; co -&gt; cn }</p><div class="wit-content" /></section><section><p>Isomorphism eo en co cn := { get : co -&gt; eo, build : en -&gt; cn }</p><div class="wit-content" /></section><section><p>Prism eo en co cn _= { match : co -&gt; Maybe eo, build : en -&gt; cn }</p><div class="wit-content" /></section><section><p>Traversal eo en co cn := forall f . Applicative f =&gt; (eo -&gt; f en) -&gt; (co -&gt; f cn)</p><div class="wit-content" /></section></div></section></div></section></span></body></html>