<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>introduction</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="oibaxnylzhpktgho.html">algebra</a></span><span class="wit-nav-item"><a href="cabjryjnnstdjmvb.html">monoid</a></span><span class="wit-nav-item"><a href="edsabrzmtmhnwgml.html">category</a></span><span class="wit-nav-item"><a href="yboclzmzvuwqxcdt.html">functor</a></span><span class="wit-nav-item"><a href="kaxxmpbkqesnqecy.html">monoidal in programming</a></span><span class="wit-nav-item"><a href="mtcrpjujemznyvue.html">monad</a></span><span class="wit-nav-item wit-nav-current-page">introduction</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>monad is an interface of type functions; special version of monoidal</p><div class="wit-content"><section><p><a href="kaxxmpbkqesnqecy.html">link to &#39;monoidal&#39;</a></p><div class="wit-content" /></section></div></section><section><p>intuition</p><div class="wit-content"><section><p>you could have invented monads in programming; here is how :</p><div class="wit-content" /></section><section><p>kliesli composition</p><div class="wit-content"><section><p>in functional programming effects may not happen to the side, but has to be encompassed in the output value of the function</p><div class="wit-content"><section><p>if we want to load a function of type (x -&gt; y) with some additional effect then we need to change the type of the function to (x -&gt; c y), where c is a type function, creating a type whose values represent both the y as content and the additional effect as context</p><div class="wit-content" /></section><section><p>example</p><div class="wit-content"><section><p>Maybe is a type function that implements interface Monad; returning Maybe makes the function able to fail, which can be considered an effect; the (possible failure) effect is like (exceptions as known in imperative programming languages)</p><div class="wit-content" /></section></div></section></div></section><section><p>if a type function m implements interface Monad then the functions with type (x -&gt; m y) form a category</p><div class="wit-content" /></section><section><p>hence monads make it possible to compose programs from effectful functions in the same way as we do with normal functions</p><div class="wit-content"><section><p>the composition of (x -&gt; c y) functions is named &quot;kliesli&quot; composition and often denoted by &quot;&gt;=&gt;&quot;</p><div class="wit-content" /></section></div></section></div></section><section><p>functor</p><div class="wit-content"><section><p>effects are contexts of a functor, hence Monad must be a subtype of Functor</p><div class="wit-content" /></section></div></section><section><p>join</p><div class="wit-content"><section><p>monad makes this possible, but this is not exactly how monad is defined </p><div class="wit-content" /></section><section><p>i will introduce the exact definition by first trying to implement the kliesli composition</p><div class="wit-content" /></section><section><p>a monadic type contains some arbitrary data with a context that represents effect; thus a monadic type is a container; hence it is reasonable to assume that functor is a superclass of monad</p><div class="wit-content" /></section><section><p>using the functor property we can easily implement something close to the kliesli composition :</p><div class="wit-content"><section><p>kliesli_try_1 : (x -&gt; m y) -&gt; (y -&gt; m z) -&gt; (x -&gt; m (m z)) kliesli_try_1 f g = f &gt;&gt;&gt; map g </p><div class="wit-content" /></section></div></section><section><p>but this is not exactly klieli composition, because the result is in a 2 layer container</p><div class="wit-content" /></section><section><p>if we could collapse the 2 layers into 1 then we would be able to implement the kliesli composition exactly; and that is what the exact definition of monad requires, such a collapsing method; it is traditionally named &quot;join&quot; :</p><div class="wit-content"><section><p>join : m (m x) -&gt; m x </p><div class="wit-content" /></section></div></section><section><p>then the definition of the kliesli composition is :</p><div class="wit-content"><section><p>kliesli : (x -&gt; m y) -&gt; (y -&gt; m z) -&gt; (x -&gt; m z) kliesli f g = f &gt;&gt;&gt; map g &gt;&gt;&gt; join </p><div class="wit-content" /></section></div></section><section><p>associativity</p><div class="wit-content"><section><p>to make the previous argument simple for first time learners : i omitted something important : the kliesli composition must be associative; is our definition for it associative? not necessarily; but it is if we require that the join function is associative in the sense that it does not matter in which order we collapse adjacent layers of the container, formally :</p><div class="wit-content"><section><p>join &gt;&gt;&gt; join = (map join) &gt;&gt;&gt; join</p><div class="wit-content" /></section></div></section><section><p>and this is what the definition of monad requires, that the join method has this associativity property</p><div class="wit-content" /></section></div></section><section><p>pure</p><div class="wit-content"><section><p>associativity is not the only requirement for arrows in a category to have; an other one is the &quot;identity&quot; : there must be an arrow for each object from it to it, behaving neutrally with the arrow composition</p><div class="wit-content" /></section><section><p>the arrows in the category i am discussing here are the (x -&gt; m y) functions, hence the requirement is that there is a (x -&gt; m x) function; the traditional name of this method is &quot;pure&quot;</p><div class="wit-content"><section><p>pure : x -&gt; m x</p><div class="wit-content" /></section></div></section><section><p>hence the definition of monad requires this method</p><div class="wit-content" /></section><section><p>neutrality</p><div class="wit-content"><section><p>the neutral behavior of &#39;pure&#39; with composition is expressed by laws :</p><div class="wit-content"><section><p>kliesli f pure = f kliesli pure f = f</p><div class="wit-content" /></section></div></section><section><p>the neutrality [and the parametricity of the kliesli composition] imply that the effect in the result of &#39;pure&#39; is empty, that is &#39;pure&#39; returns a &quot;pure&quot; value - from this is the name &quot;pure&quot;</p><div class="wit-content" /></section></div></section></div></section><section><p>as you hopefully see: monad is a monoid in the layers of contexts, &#39;join&#39; being the composition method and &#39;pure&#39; being the empty method</p><div class="wit-content" /></section></div></section></div></section><section><p>the signature</p><div class="wit-content"><section><p>putting together all the conclusions gathered in the &quot;intuition&quot; part : the definition of monad is :</p><div class="wit-content" /></section><section><p>interface Functor m =&gt; Monad m where</p><div class="wit-content"><section><p>pure : x -&gt; m x &#9;</p><div class="wit-content" /></section><section><p>join : m (m x) -&gt; x</p><div class="wit-content" /></section></div></section><section><p>with the before mentioned laws [associativity of &#39;join&#39; and neutrality of &#39;pure&#39;]</p><div class="wit-content" /></section></div></section><section><p>in practice often a different definition is used, in which is a &quot;monad bind&quot; method instead of &#39;join&#39;; these 2 definitions are mathematically equivalent; the advantage of the definition with bind is assumed run-time efficiency [i assume], the advantage of the definition with join is elegance</p><div class="wit-content" /></section><section><p>other sources</p><div class="wit-content"><section><p>philip wadler wrote an introductory article about using monads in functional programming; the article contains many examples</p><div class="wit-content"><section><p><a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">Monads for functional programming</a></p><div class="wit-content" /></section></div></section><section><p><a href="https://wiki.haskell.org/Monad_laws">a haskell intro article to monad laws</a></p><div class="wit-content" /></section><section><p><a href="https://wiki.haskell.org/Typeclassopedia">at typeclassopedia</a></p><div class="wit-content" /></section></div></section><section><p>the signatures</p><div class="wit-content"><section><p>you probably should read the external sources about monad i referred to in this section; but if you did not then here are the signatures of the 2 alternative, equivalent monad definitions [without the laws] :</p><div class="wit-content" /></section><section><p>interface Monad m where</p><div class="wit-content"><section><p>pure : x -&gt; m x</p><div class="wit-content" /></section><section><p>(&gt;&gt;=) : m x -&gt; (x -&gt; m y) -&gt; m y</p><div class="wit-content" /></section></div></section><section><p>interface Monad m &lt;= Functor c where</p><div class="wit-content"><section><p>pure : x -&gt; m x</p><div class="wit-content" /></section><section><p>join : m (m x) -&gt; m x</p><div class="wit-content" /></section></div></section></div></section><section><p><a href="kqwejllsptnclmqz.html">monad-generic programs</a></p><div class="wit-content" /></section><section><p>no general method to extract content from a monad</p><div class="wit-content"><section><p>certain concrete monad type functions provide a method to extract content stored in them; a good example is the identity monad, which is just a simple wrapper around the pure content; but such feature is given by monads only individually; no general method exists to extract content from a monad [to see this : look at the methods of interface Monad; each return a monad]; thus if the concrete monad does not provide access to its data then nothing does; in such case one can perform computation on the data inside a monad [with the monadic bind function (&gt;&gt;=)] but will get the output in the same monad type; we can say : &quot;one can not escape from monad&quot;; this is an essential property; certain concrete monads represent a property of computation; a property of computation may be for example : possibility of performing input|output operation, possibility-to-fail; such computations must output their result in an appropriate monad, that marks the possible effect to be performed; but such properties are usually inherited, i mean : all the functions invoking these functions have these properties too; hence their output must also be in the same monad; with other words : once a produced value is in a monad representing an inherited property of computation : any value derived from it must also remain in that monad; non-escapabability from monads and static type checking guarantees this; with other words : this is a method to track computational properties by the static type system</p><div class="wit-content" /></section><section><p>in the section about functional programming i tought that among of the all 3 &quot;function-bugs&quot; side effects are the most interesting and i neglected the other 2; but now you may see that the other 2 [non-determinism, partiality] can be easily handled with monads</p><div class="wit-content"><section><p>even if we do not get rid of them completely : at least they can be tracked by the type system, which is good enough usually</p><div class="wit-content" /></section><section><p>we may for each of these 2 computational properties implement dedicated non-escapable container types with monad interface implementation</p><div class="wit-content" /></section><section><p>non-determinism may also be considered to be input; hence for example haskell uses the IO monad to wrap it</p><div class="wit-content" /></section><section><p>totality is currently not checked by current popular compilers; not even by the haskell compiler; this may change in the future and in this case a PossiblyDivergent monad may be used to mark results of partial computations</p><div class="wit-content" /></section><section><p>as a theoretical note : this method does not hurt the purity of our use of functional paradigm</p><div class="wit-content"><section><p>remember : a procedure is a real mathematical function if it always produces output and produces the same output for the same input in all circumstances</p><div class="wit-content" /></section><section><p>we can always achieve this by giving a fake equality function for these monads, that return true constantly; these equality tests are not be actually invoked anyway; then it theoretically holds that such values are always equal, hence the procedures producing them are functional</p><div class="wit-content" /></section></div></section></div></section></div></section></span></body></html>