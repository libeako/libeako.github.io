<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>generalized sum type</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="nnsmzqwudqobukpt.html">fund</a></span><span class="wit-nav-item"><a href="aacixgsdjlspuizr.html">derivation system</a></span><span class="wit-nav-item"><a href="hoqxwlarqggqsrwp.html">type</a></span><span class="wit-nav-item wit-nav-current-page">generalized sum type</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>introduction</p><div class="wit-content"><section><p>it is an intuitive, simple, but powerful type system feature; it has very good benefit/cost value</p><div class="wit-content" /></section><section><p>it is a generalization of sum types: it has inputs and its constructors may specify to return the exact arguments for those</p><div class="wit-content" /></section><section><p>usefulness</p><div class="wit-content"><section><p>...</p><div class="wit-content" /></section><section><p>it is practically indispensable for embedded languages</p><div class="wit-content" /></section></div></section><section><p><a href="https://en.wikibooks.org/wiki/Haskell/GADT">on the haskell wiki</a></p><div class="wit-content" /></section></div></section><section><p>parametricity in generalized sum types</p><div class="wit-content"><section><p><a href="qkpkvuxwtzdigyud.html">link to parametricity</a></p><div class="wit-content" /></section><section><p>data type definitions can take inputs, thus they are functions mathematically</p><div class="wit-content" /></section><section><p>sum is a special type construction method, in that it is the one and only that may have multiple constructors with different output types; this makes an input of a sum type definition to constrain the defined data type, different index value being mapped to differently structured outputs; with other wording: the output data type will different for different index values, as the set of its constructors will be different</p><div class="wit-content" /></section><section><p>the classical example is the Vector data type</p><div class="wit-content" /></section><section><p>example</p><div class="wit-content"><section><p>data Vector (e : Set) : Natural -&gt; Set where</p><div class="wit-content"><section><p>Nil : Vector e Zero</p><div class="wit-content" /></section><section><p>Cons : (implicit n : Natural) -&gt; e -&gt; Vector n e -&gt; Vector (Suc n) e</p><div class="wit-content" /></section></div></section><section><p>the &#39;Vector&#39; data type is a sum type; it has 2 inputs : (&#39;E&#39; - the element type of the vector), (a Natural - the size of the vector) </p><div class="wit-content" /></section><section><p>i differentiate the 2 kinds of input syntactically; they take place at different sides to the &quot;:&quot; in the header</p><div class="wit-content" /></section></div></section></div></section><section><p><a href="https://www.cs.ox.ac.uk/files/3060/gadtless.pdf">emulation with type-equality fields</a></p><div class="wit-content"><section><p>by Martin Sulzmann and Meng Wang</p><div class="wit-content" /></section></div></section></span></body></html>