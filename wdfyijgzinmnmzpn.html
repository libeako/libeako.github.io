<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>your journey</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">coding</a></span><span class="wit-nav-item wit-nav-current-page">your journey</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>some beginning part of this content is also available as</p><div class="wit-content"><section><p><a href="https://drive.google.com/drive/folders/1kiFr_OGXP6olNQjmShaPeCXiKhnA08Rp?usp=sharing">my free book</a></p><div class="wit-content" /></section><section><p>the book probably has better quality</p><div class="wit-content" /></section></div></section><section><p>this part of my site is for the average industrial programmer, who works all day, in an industrial language, like Java, C++, or any non-typed or imperative or object-oriented language; i want to show you much better methods and programming languages to code with</p><div class="wit-content" /></section><section><p>you can think of this content as a book, a walkthrough, an order of topics and references to guide and more importantly: motivate you through </p><div class="wit-content" /></section><section><p><a href="ruwyqtccsonzjloi.html">the same journey as i went</a></p><div class="wit-content" /></section><section><p>this walkthrough will cover the road from JavaScript to Idris</p><div class="wit-content" /></section><section><p>why are these knowledge so good?</p><div class="wit-content"><section><p>emotional advantages</p><div class="wit-content"><section><p>decreases frustration</p><div class="wit-content" /></section><section><p>increases fun</p><div class="wit-content" /></section></div></section><section><p>practical advantages</p><div class="wit-content"><section><p>hugely decrease the bug-prone nature of coding [&quot;correct by construction&quot;]</p><div class="wit-content" /></section><section><p>first implementation of a program is much faster </p><div class="wit-content" /></section><section><p>understandability, maintainability, refactorability are much easier</p><div class="wit-content" /></section><section><p>more modularity</p><div class="wit-content" /></section></div></section><section><p>they make the coding work about [3-10] more efficient compared to the average industrial practice</p><div class="wit-content" /></section><section><p>their destiny is to take over the coding world, because they are natural very useful</p><div class="wit-content" /></section><section><p>they fundamentally changes how coders think about the code and even about its task</p><div class="wit-content" /></section></div></section><section><p>the steps</p><div class="wit-content"><section><p><a href="ezrdpkjrokawnikj.html">the industry-academy gap</a></p><div class="wit-content"><section><p>history of programming methodologies</p><div class="wit-content"><section><p>both industrial and academic and their relation</p><div class="wit-content" /></section></div></section><section><p>why does the industry behind the academy by multiple decades?</p><div class="wit-content" /></section></div></section><section><p><a href="jaxbiyrfnbhaormb.html">some basic prog lang notions</a></p><div class="wit-content"><section><p>both concepts and syntax</p><div class="wit-content" /></section><section><p>i present this to prepare the audience to understand my later examples; but they are worth to know anyway because they are to overtake the programming world by popularity</p><div class="wit-content" /></section></div></section><section><p><a href="crulbcjvhzgpkjis.html">static typing</a></p><div class="wit-content"><section><p>i claim that dynamic type checking does not have legitimacy in a normal programming tasks; programming languages should be statically type checked</p><div class="wit-content" /></section></div></section><section><p><a href="ratihdffwublrlih.html">utilizing the type system</a></p><div class="wit-content"><section><p>it is not enough to have a good static type system, you should use it too</p><div class="wit-content"><section><p>some important examples:</p><div class="wit-content"><section><p>do not use null values; use a Maybe type instead</p><div class="wit-content" /></section><section><p>do not use exceptions; use a Result type instead</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p><a href="rqeeitsvmgrogdjp.html">functional programming</a></p><div class="wit-content"><section><p>this is an easy and beautiful topic; also probably the most bang for the buck in this course; [though not equally well but still] can be used in any programming language without preparation</p><div class="wit-content" /></section></div></section><section><p><a href="xkvczulejoaflnjf.html">structural polymorphism</a></p><div class="wit-content"><section><p>a feature in some programming languages [for example Haskell] that lets the programmer abstract over data types and traverse their shape</p><div class="wit-content" /></section></div></section><section><p>have a break</p><div class="wit-content"><section><p>i recommend you to have a time break here; spend some time coding functionally; get to the point where you get it, like it, feel its superiority; the rest of the journey is more advanced; more difficult to understand; for it to make sense, click in: it helps to have some practical experience with functional programming</p><div class="wit-content" /></section></div></section><section><p><a href="iuvbupavbjmhfrxj.html">type parametricity</a></p><div class="wit-content"><section><p>a coding paradigm of generality [by parametric type polymorphism], a simple, very cheap technique to improve software-correctness and source-readability</p><div class="wit-content" /></section></div></section><section><p><a href="flktedmyhawaehus.html">abstraction by mathematics</a></p><div class="wit-content"><section><p>&quot;design patterns&quot; done well</p><div class="wit-content" /></section><section><p>the super-power of compositionality, taken from the well-established mathematical field abstract algebra, especially category theory; i explain only the very basic, but very useful concepts: monoid, functor, applicative, monad</p><div class="wit-content" /></section></div></section><section><p><a href="kdtdlfyrudrcnrrl.html">proposition as type</a></p><div class="wit-content"><section><p>strong connection is between programming and logic - the &quot;proposition as type correspondence&quot;</p><div class="wit-content" /></section><section><p>this is a beautiful topic; the most interesting thing i ever learned in programming; it shows how programming and logic are the same thing at a certain level, via a surprisingly simple connection; this connection makes us able to use a single simple programming language to not only implement software but also:</p><div class="wit-content"><section><p>model its domain</p><div class="wit-content" /></section><section><p>state mathematical theorems about the domain</p><div class="wit-content" /></section><section><p>prove those theorems and have the compiler verify the proofs</p><div class="wit-content" /></section><section><p>specify the software and have the compiler verify the correctness of the implementation according to the specification</p><div class="wit-content" /></section></div></section></div></section><section><p><a href="qzfwvslnetipqgqu.html">increasing the strength of the type system</a></p><div class="wit-content"><section><p>parameterizing our types with more stuff: type functions, custom algebraic data types, runtime values [&quot;dependent typing&quot;]</p><div class="wit-content" /></section><section><p>the more our type system can express - the less repetition we need in the code and more properties of our programs we can ensure</p><div class="wit-content" /></section></div></section><section><p>a little more category theory</p><div class="wit-content"><section><p>some trivial knowledge, very good (usefulness / difficulty) value:</p><div class="wit-content" /></section><section><p><a href="qxijfmdcfenjblwc.html">isomorphism of objects</a></p><div class="wit-content" /></section><section><p><a href="yimhrxhreprkjkfk.html">duality</a></p><div class="wit-content" /></section><section><p><a href="fhdcexkhowvzxltx.html">contravariant functor</a></p><div class="wit-content" /></section><section><p><a href="evecfkoaaczzekya.html">profunctor</a></p><div class="wit-content" /></section></div></section><section><p><a href="ndgkrnbojyputpec.html">optics</a></p><div class="wit-content" /></section><section><p><a href="criytwacwdgeqemu.html">arithmetic of data types</a></p><div class="wit-content" /></section></div></section></span></body></html>