<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>pattern matching</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="nnsmzqwudqobukpt.html">fund</a></span><span class="wit-nav-item"><a href="znuvgowivqvqbdhr.html">language</a></span><span class="wit-nav-item"><a href="jaxbiyrfnbhaormb.html">general language</a></span><span class="wit-nav-item wit-nav-current-page">pattern matching</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>pattern matching matches the the structure of a data value to the structure of a &quot;pattern&quot;</p><div class="wit-content" /></section><section><p>pattern matching can be applied whereever a new name can be given [at name &quot;bind&quot; positions]; instead of a simple new name: a complex pattern can be given, containing multiple names perhaps</p><div class="wit-content" /></section><section><p>the pattern can be so simple as a single name, in which case the situation is a normal name binding</p><div class="wit-content" /></section><section><p>(sub-values in the matched value) are matched to (the names in the pattern), giving names by this to those sub-values</p><div class="wit-content" /></section><section><p>a simple example</p><div class="wit-content"><section><p>prelimiaries</p><div class="wit-content"><section><p>a pair data type</p><div class="wit-content"><section><p>Pair = (Man, Woman)</p><div class="wit-content" /></section></div></section><section><p>a value of the above data type</p><div class="wit-content"><section><p>a_pair = (adam, eva)</p><div class="wit-content" /></section></div></section></div></section><section><p>pattern matching on the value</p><div class="wit-content"><section><p>(xy, xx) = a_pair</p><div class="wit-content" /></section></div></section><section><p>explanation</p><div class="wit-content"><section><p>&quot;(xy, xx)&quot; is the pattern</p><div class="wit-content" /></section><section><p>&quot;xy&quot;, &quot;xx&quot; are new names to be bound to the sub-values of the matchedvalue</p><div class="wit-content"><section><p>&#39;xy&#39; binds to &#39;adam&#39;</p><div class="wit-content" /></section><section><p>&#39;xx&#39; binds to &#39;eva&#39;</p><div class="wit-content" /></section></div></section><section><p>it is equivalent to introducing these names one-by-one</p><div class="wit-content"><section><p>xy = fst a_pair</p><div class="wit-content" /></section><section><p>xx = snd a_pair</p><div class="wit-content" /></section></div></section></div></section><section><p>you probably already see advantages of pattern matching: it is often shorter, less repetitive, more readable, less error-prone</p><div class="wit-content" /></section></div></section><section><p>some people say pattern matching &quot;destruct&quot;s the value; this phrase may be slightly misguiding for novices; of course: the value as an object in memory does not get destroyed or modified by pattern matching</p><div class="wit-content" /></section><section><p>the &quot;_&quot; pattern matches anything</p><div class="wit-content" /></section><section><p>pattern matching can also be used for branching, by giving multiple patterns, of which exactly one matching pattern is selected during evalutation</p><div class="wit-content"><section><p>example</p><div class="wit-content"><section><p>the following example implements the well-known if-then-else function</p><div class="wit-content" /></section><section><p>if_then_else : Bool -&gt; t -&gt; t -&gt; t</p><div class="wit-content" /></section><section><p>if_then_else c a b =</p><div class="wit-content"><section><p>case c</p><div class="wit-content"><section><p>true  -&gt; a</p><div class="wit-content" /></section><section><p>false -&gt; b</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>the &#39;case&#39; keyword introduces the &quot;case expression&quot;; the value after the &#39;case&#39; keyword is pattern-matched on; the case-expression continues with the list of cases; each case has a (pattern -&gt; value) form; the value of the case expression is the value of the first case whose pattern manages to match</p><div class="wit-content" /></section><section><p>the compiler should check in compile time that at least one of the patterns will match in runtime, with other wording: that the pattern matching is &quot;exhaustive&quot;</p><div class="wit-content"><section><p>warning: the haskell compiler ghc does not check this by default, you have to turn it on with an argument to the compiler</p><div class="wit-content" /></section></div></section></div></section><section><p>point-free case</p><div class="wit-content"><section><p>for </p><div class="wit-content"><section><p>\ x -&gt; case x ...</p><div class="wit-content" /></section></div></section><section><p>we have a point-free syntax sugar:</p><div class="wit-content"><section><p>\ case ...</p><div class="wit-content" /></section></div></section></div></section><section><p>pattern matching can reach sub-values at any depth</p><div class="wit-content"><section><p>size : List e -&gt; Integer size =</p><div class="wit-content"><section><p>\case</p><div class="wit-content"><section><p>nil -&gt; 0</p><div class="wit-content" /></section><section><p>head :: tail -&gt; 1 + (size tail)</p><div class="wit-content" /></section></div></section></div></section><section><p>the following example implements a size function for Lists which takes a List of Maybes and counts only the existing elements</p><div class="wit-content" /></section><section><p>effective_size : List (Maybe a) -&gt; Int</p><div class="wit-content" /></section><section><p>effective_size =</p><div class="wit-content"><section><p>\case</p><div class="wit-content"><section><p>nil -&gt; 0</p><div class="wit-content" /></section><section><p>(just _) :: tail -&gt; 1 + (size tail)</p><div class="wit-content" /></section><section><p>none :: tail -&gt; size tail</p><div class="wit-content" /></section></div></section></div></section><section><p>in this example pattern matching reaches not only the elements of a List value, but also inside the Maybe structure in it</p><div class="wit-content" /></section></div></section><section><p>matching multiple values simultaniously is possible by building a tuple of those values and matching the tuple</p><div class="wit-content"><section><p>example</p><div class="wit-content"><section><p>unsure_sum : Maybe Int -&gt; Maybe Int -&gt; Maybe Int</p><div class="wit-content" /></section><section><p>unsure_sum a b =</p><div class="wit-content"><section><p>case (a, b)</p><div class="wit-content"><section><p>(just x, just y) =&gt; just (x + y)</p><div class="wit-content" /></section><section><p>_ =&gt; none</p><div class="wit-content" /></section></div></section></div></section></div></section></div></section><section><p>match on function input with branching</p><div class="wit-content"><section><p>some languages [for example haskell] provide syntax sugar to combine pattern matching on inputs of functions with branching</p><div class="wit-content" /></section><section><p>example</p><div class="wit-content"><section><p>unsure_sum : Maybe Int -&gt; Maybe Int -&gt; Maybe Int</p><div class="wit-content" /></section><section><p>unsure_sum</p><div class="wit-content"><section><p>| (just x) (just y) = just (x + y)</p><div class="wit-content" /></section><section><p>| _        _        = none</p><div class="wit-content" /></section></div></section><section><p>this could, of course, be done with a case-expression, but that would require us to first give names for the inputs</p><div class="wit-content" /></section></div></section></div></section></span></body></html>