<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>pattern matching</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">coding</a></span><span class="wit-nav-item"><a href="jaxbiyrfnbhaormb.html">some basic prog lang notions</a></span><span class="wit-nav-item wit-nav-current-page">pattern matching</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>- is a method to branch on the structure of a data value and give new names to parts of it; the structure of the value is matched to the structure of a &quot;pattern&quot;; (sub-values in the value) are matched to (the symbols in the pattern); by this giving names to those sub-values</p><div class="wit-content" /></section><section><p>some people say pattern matching &quot;destruct&quot;s the value; this phrase may be slightly misguiding for novices; of course : the value as an object in memory does not get destroyed or modified by pattern matching</p><div class="wit-content" /></section><section><p>a simple example</p><div class="wit-content"><section><p>a pair data type</p><div class="wit-content"><section><p>Pair = Man Woman</p><div class="wit-content" /></section></div></section><section><p>a value of the above data type</p><div class="wit-content"><section><p>a_pair = (adam, eva)</p><div class="wit-content" /></section></div></section><section><p>pattern matching on the value</p><div class="wit-content"><section><p>(xy, xx) = a_pair</p><div class="wit-content" /></section><section><p>here &quot;(xy, xx)&quot; is the pattern, in which &quot;xy&quot;, &quot;xx&quot; are the symbols that to be the names of the sub-values of the value; in this case they are the components of the pair</p><div class="wit-content" /></section><section><p>now</p><div class="wit-content"><section><p>&#39;xy&#39; denotes &#39;adam&#39;</p><div class="wit-content" /></section><section><p>&#39;xx&#39; denotes &#39;eva&#39;</p><div class="wit-content" /></section></div></section><section><p>it is equivalent to introducing these names one-by-one</p><div class="wit-content"><section><p>xy = get 1 a_pair</p><div class="wit-content" /></section><section><p>xx = get 2 a_pair</p><div class="wit-content" /></section></div></section><section><p>you probably already see advantages of pattern matching : it is often shorter, less repetitive, more readable, less error-prone</p><div class="wit-content" /></section></div></section></div></section><section><p>branching with pattern matching</p><div class="wit-content"><section><p>the following example implements the well-known if-then-else function</p><div class="wit-content" /></section><section><p>if_then_else : Bool -&gt; T -&gt; T -&gt; T</p><div class="wit-content" /></section><section><p>if_then_else c a b =</p><div class="wit-content"><section><p>case c</p><div class="wit-content"><section><p>true  -&gt; a</p><div class="wit-content" /></section><section><p>false -&gt; b</p><div class="wit-content" /></section></div></section></div></section><section><p>the &#39;case&#39; keyword introduces the &quot;case expression&quot;; the value after the &#39;case&#39; keyword is pattern-matched on; the case-expression continues with the list of cases; each case has a (pattern -&gt; value) form; the value of the case expression is the value of the first case whose pattern manages to match</p><div class="wit-content" /></section><section><p>the compiler should check in compile time that at least one of the patterns will match in runtime, with other wording: that the pattern matching is &quot;exhaustive&quot;</p><div class="wit-content"><section><p>warning: the haskell compiler ghc does not check this by default, you have to turn it on with an argument to the compiler</p><div class="wit-content" /></section></div></section></div></section><section><p>point-free case</p><div class="wit-content"><section><p>for &quot;\ x -&gt; case x ...&quot; we have a point-free syntax sugar: &quot;\ case ...&quot;</p><div class="wit-content" /></section></div></section><section><p>deep pattern matching</p><div class="wit-content"><section><p>pattern matching can reach sub-values at any depth</p><div class="wit-content" /></section><section><p>size : List e -&gt; Integer size =</p><div class="wit-content"><section><p>\case</p><div class="wit-content"><section><p>nil -&gt; 0</p><div class="wit-content" /></section><section><p>head :: tail -&gt; 1 + (size tail)</p><div class="wit-content" /></section></div></section></div></section><section><p>the following example implements a size function for Lists which takes a List of Maybes and counts only the existing elements</p><div class="wit-content" /></section><section><p>effective_size : List (Maybe a) -&gt; Int</p><div class="wit-content" /></section><section><p>effective_size =</p><div class="wit-content"><section><p>\case</p><div class="wit-content"><section><p>nil -&gt; 0</p><div class="wit-content" /></section><section><p>(just _) :: tail -&gt; 1 + (size tail)</p><div class="wit-content" /></section><section><p>none :: tail -&gt; size tail</p><div class="wit-content" /></section></div></section></div></section><section><p>in this example pattern matching reaches not only the elements of a List value, but also inside the Maybe structure in it</p><div class="wit-content" /></section></div></section><section><p>simultanious pattern matching</p><div class="wit-content"><section><p>matching multiple values simultaniously is possible by building a tuple of those values and matching the tuple; the following example hopefully demonstrates why sometimes this is useful</p><div class="wit-content" /></section><section><p>unsure_sum : Maybe Int -&gt; Maybe Int -&gt; Maybe Int</p><div class="wit-content" /></section><section><p>unsure_sum a b =</p><div class="wit-content"><section><p>case (a, b)</p><div class="wit-content"><section><p>(just x, just y) =&gt; just (x + y) _ =&gt; none</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>match on function input with branching</p><div class="wit-content"><section><p>some programming languages [for example haskell] provide a syntax sugar to combine pattern matching on inputs of functions with branching</p><div class="wit-content" /></section><section><p>unsure_sum : Maybe Int -&gt; Maybe Int -&gt; Maybe Int</p><div class="wit-content" /></section><section><p>unsure_sum</p><div class="wit-content"><section><p>| (just x) (just y) = just (x + y)</p><div class="wit-content" /></section><section><p>| _        _        = none</p><div class="wit-content" /></section></div></section><section><p>the purpose is to save us from having to name the inputs</p><div class="wit-content" /></section></div></section></span></body></html>