<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>classical logic</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="nnsmzqwudqobukpt.html">fund</a></span><span class="wit-nav-item"><a href="hssphyjgxuopzugc.html">programming</a></span><span class="wit-nav-item"><a href="kdtdlfyrudrcnrrl.html">programming and logic</a></span><span class="wit-nav-item"><a href="huktyxsxcfntvnbj.html">representing logical constructs</a></span><span class="wit-nav-item wit-nav-current-page">classical logic</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>the programming-logic correspondence gives us a proof method that consists of constructing witnesses; the analogue of this in mathematics is named &quot;constructive&quot; proving, and the logic it enables &quot;constructive logic&quot; [or &quot;intuitionistic logic&quot;]; &quot;classical logic&quot; contains more proving tools than constructive logic; it may be at least inconvenient to lack some tools; our proof method fundamentally implements constructive logic, but it would be nice if we still could use all the tools of classical logic in some way</p><div class="wit-content" /></section><section><p>the additional tools in &quot;classical logic&quot; :</p><div class="wit-content"><section><p>law of the excluded middle</p><div class="wit-content"><section><p>it says :</p><div class="wit-content"><section><p>forall S âˆŠ Statement : (S or (not S))</p><div class="wit-content" /></section><section><p>in natural language : for each statement : either the statement or its negation is true</p><div class="wit-content" /></section></div></section><section><p>it can not be proved</p><div class="wit-content"><section><p>hence it is an axiom of classical logic</p><div class="wit-content" /></section><section><p>the reason of non-provability in programming</p><div class="wit-content"><section><p>we represent conjunction [&quot;or&quot;] by sum type; proving a disjunction corresponds to constructing a witness of the corresponding sum type; constructing an instance of a sum type needs us to know which case of the sum type we are constructing; but in the generality of the law [the statement S is unknown] we may not know which case is true</p><div class="wit-content" /></section></div></section></div></section><section><p>a solution</p><div class="wit-content"><section><p>like in mathematics we accept the law as an axiom : we can make the programming language provide a value with type (rep (S or (not S))) : (lem : (S + (S -&gt; Empty))); but such a value does not exist, even if the programming language designer wants it; the solution to this contradiction is to pretend that it exists; the downside of pretending is that one can not compute with a value that does not exist; this drawback is not show-stopper because we want to use it only for proving, not for computation</p><div class="wit-content" /></section><section><p>in order to defend against accidental computing with non-existing values : it is enough to wrap it into a monad whose purpose is to indicate that the contained value can not be evaluated and the compiler knows that</p><div class="wit-content"><section><p>lem : CanNotBeEvaluated (S (S -&gt; Empty)))</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>double negation</p><div class="wit-content"><section><p>it enables proof by contradiction</p><div class="wit-content" /></section><section><p><a href="https://en.wikipedia.org/wiki/Double_negation">wikipedia article</a></p><div class="wit-content" /></section><section><p>the solution is the same as for the law of excluded middle</p><div class="wit-content" /></section></div></section></div></section></span></body></html>