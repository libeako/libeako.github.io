<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>object oriented programming</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">information technology</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="rmciseizvhdgclym.html">user interface</a></span><span class="wit-nav-item"><a href="oeyeaezscdudpssh.html">formal languages</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">software coding</a></span><span class="wit-nav-item"><a href="sltupaghfpuaijff.html">programming language</a></span><span class="wit-nav-item"><a href="sgdgrgstvwioqtwb.html">bad language features</a></span><span class="wit-nav-item wit-nav-current-page">object oriented programming</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>the year is 2018; object oriented programming is not alive and has not achieved any good till now; i know : this sounds surprising, seeing thw wide spread of OOP, but this section will explain </p><div class="wit-content" /></section><section><p>theoretical research about &quot;object oriented programming&quot; is not done currently in significant amount; the rest of this section deals with rather practical side</p><div class="wit-content" /></section><section><p>what is object oriented programming?</p><div class="wit-content"><section><p>to explain such bold claim that OOP is not alive : i should first define OOP; this task is more difficult than one might first think; its meaning is widely debated; when the meaning of a term is debated then a way out may be to turn back to the original meaning of the term; the term &quot;object oriented programming&quot; was coined by Alan Kay; the most informative text about his thinking about it that i found is &quot;OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things.&quot;; to me this sounds like the actor model : the program consists of actors, that are independent of each other but interact with each other; the interaction is done via &quot;messaging&quot;, which we now know as method invocation; at those early times OOP was thought about like the program consists of parts that are like cells in a body or individual animals in a complex living environment </p><div class="wit-content" /></section><section><p>state mutation</p><div class="wit-content"><section><p>it is important to see that Alan Kay thought about OOP as something that fundamentally involves mutable state; many people even till now think so; but state is perhaps the most &quot;evil&quot; thing in programming ; you may now defend OOP with the statement that functional programming is not to be applied for all programs; for example high efficiency programs may drop the functional methodology at certain places; but : note that these high efficiency programs are relatively rare, most programs are written at the application level, where functional programming is not only efficient enough but is even more efficient than imperative programming; and even in highly efficient programs : the highly optimized parts of it are small compared to the full size of the program; thus the scope of legitimately using imperative mutable state is very small; and even in that small scope : OOP is not good fit because some other aspects of it [dynamic memory allocation, late binding] is usually incompatible with high optimizability of runtime efficiency; thus we arrive to the conclusion that OOP does not have any place</p><div class="wit-content"><section><p><a href="rqeeitsvmgrogdjp.html">link to &#39;functional programming&#39;</a></p><div class="wit-content" /></section><section><p><a href="nmzlpnpnrsfmunrf.html">link to (runtime efficiency of functional programs)</a></p><div class="wit-content" /></section></div></section></div></section><section><p>anything else?</p><div class="wit-content"><section><p>but this is just one interpretation of &quot;object oriented programming&quot;; one &quot;modern&quot; view of it is that mutable state does not have to be considered a part of it; this view is strongly reflected by the scala programming language for example</p><div class="wit-content" /></section><section><p>an &quot;object&quot; is a value coupled with the memory part it is stored in; the only reason to distinguish between different objects with the same value is the possibility of mutation; hence with dropping mutation from our toolbox : we drop &quot;object&quot;s too; hence the name &quot;OOP&quot; looses its original meaning; hence &quot;functional OOP&quot; contains a striking contradiction at least as a name </p><div class="wit-content" /></section><section><p>but supposing the necessity to occasionally accept historical mistakes in terminology : this section continues to investigate the merit of functional OOP; what it is or at least what is widely thought it is?</p><div class="wit-content" /></section><section><p>in the following i use comparison to the haskell programming language which is considered to be not an object oriented language; thus i allow to myself to exclude from OOP any feature that is in haskell</p><div class="wit-content" /></section><section><p>an other fundamental component of OOP is late binding; at least Alan Kay thought so [&quot;extreme late-binding of all things&quot;]; and this view is reflected by the current mainstream OOP languages : everything depends on a special, implicit first input : a &quot;this&quot; or &quot;self&quot; object; i consider late binding a legitimate feature, but i think that making it a base of type interfacing was a programming language design mistake; this is nicely demonstrated by the contrast with the haskell solution of type interfacing [&quot;type classes&quot;] which builds on static dispatch by default; the static strategy gives vast improvement in runtime efficiency [because of inlining], type inference, most importantly: domain modeling capability [including nullary methods, conditional implementation, late implementation]</p><div class="wit-content"><section><p><a href="biuqwfqzzkpjuqob.html">link to (type classes)</a></p><div class="wit-content" /></section></div></section><section><p>if we would drop late binding too from the definition of OOP then what would remain of OOP? </p><div class="wit-content"><section><p>run-time type testing ? - even the OO culture considers it a dirty practise, to be avoided</p><div class="wit-content" /></section><section><p>methods inheritance between interfaces ? - not a significant feature</p><div class="wit-content" /></section><section><p>dynamic binding ? - haskell also has it, though with more code verbosity</p><div class="wit-content" /></section></div></section><section><p>i did find though one important thing that distinguishes OOP languages : they base their type interfacing on late binding; not only base, but constrain :  static methods may not be in OOP type interfaces; i fail to see any advantage that this constrain can give; type classes are much better</p><div class="wit-content"><section><p><a href="biuqwfqzzkpjuqob.html">link to (why type classes are better)</a></p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>main conclusion</p><div class="wit-content"><section><p>till here i came to the conclusion that OOP is mainly state mutation and unnecessary push of dynamic binding; the earlier ruins our software coding efficiency, the later makes type interfacing hardly usable; giving nothing significant in return that we would expect from a programming paradigm</p><div class="wit-content" /></section></div></section><section><p>shame on OO type interfacing</p><div class="wit-content"><section><p>oo wants to be a paradigm; but a paradigm should be generally applicable; oo interfacing is not generally applicable; it is too ugly and too weak; as you saw from the examples : not only it can not express such basic type interfaces as Equatable and Comparable in a natural way, but even if we accept its ugliness : so soon as wrapping our [now equatable or comparable] type by a Maybe or other container : the oo type interfacing can not follow us; and for interfaces with input-less methods, like the very important Monoid interface : it can not even start</p><div class="wit-content" /></section><section><p>one of the roots of the failure of oo is one of its foundational principle that method dispatch should be dynamic; in the world of type interfacing : this is corrected by type classes</p><div class="wit-content" /></section></div></section><section><p>why did OO spread ?</p><div class="wit-content"><section><p>if OOP would be so clearly bad then why did it spread so widely? because the languages that pushed it became popular; but those became popular not because of OOP but each for some unrelated reason; for example java, c# were backed by big companies, java additionally promised &quot;write once, run everywhere&quot;, c++ did not have a competitor</p><div class="wit-content" /></section></div></section><section><p>OO mania</p><div class="wit-content"><section><p>it is not only the languages, but culture too; so named &quot;OO design patterns&quot;, &quot;OO design&quot;, &quot;OO architecture&quot; flud the industrial software development world; i think that was a mistake</p><div class="wit-content" /></section><section><p>i am not familiar with the &quot;OO design patterns&quot;, but i want to show you that they are not valuable; hence i searched the web for OO design patterns and found</p><div class="wit-content" /></section><section><p><a href="https://www.oodesign.com/proxy-pattern.html">a website listing many of them</a></p><div class="wit-content" /></section><section><p>i worked through all of them, here are my quick impressions about them :</p><div class="wit-content" /></section><section><p>the list</p><div class="wit-content"><section><p>&quot;decorator&quot;</p><div class="wit-content"><section><p>= let us decrease the inheritance hierarchy, by replacing some inheritance with aggregation</p><div class="wit-content" /></section><section><p>but : realizing that a more basic language construct [product type] is more adequate than a more involved one [inheritance] is not a &quot;design pattern&quot;; because to apply the more involved language construct is not a task to be solved</p><div class="wit-content" /></section></div></section><section><p>&quot;flyweight&quot;</p><div class="wit-content"><section><p>= data reference :-) [&quot;pointer&quot; if you like]; yes : some people think it needs a different name and articles</p><div class="wit-content" /></section></div></section><section><p>&quot;factory&quot;</p><div class="wit-content"><section><p>= stream</p><div class="wit-content" /></section></div></section><section><p>&quot;composite&quot;</p><div class="wit-content"><section><p>= tree</p><div class="wit-content" /></section></div></section><section><p>&quot;strategy&quot;</p><div class="wit-content"><section><p>= second order function, which is just function with function input : (x -&gt; y) -&gt; r</p><div class="wit-content" /></section></div></section><section><p>&quot;command&quot;</p><div class="wit-content"><section><p>= special case of &quot;strategy&quot;, where the input function is an action</p><div class="wit-content" /></section></div></section><section><p>&quot;builder&quot;</p><div class="wit-content"><section><p>= special case of strategy, where the input function produces something instead of performing an action</p><div class="wit-content" /></section></div></section><section><p>&quot;singleton&quot;</p><div class="wit-content"><section><p>= lazy initialization + mutable global state</p><div class="wit-content" /></section></div></section><section><p>&quot;state&quot;</p><div class="wit-content"><section><p>= access control + mutable state</p><div class="wit-content" /></section></div></section><section><p>&quot;null object&quot;</p><div class="wit-content"><section><p><a href="cabjryjnnstdjmvb.html">monoid</a></p><div class="wit-content" /></section></div></section><section><p>&quot;template method&quot;</p><div class="wit-content"><section><p>= &quot;strategy&quot;</p><div class="wit-content" /></section></div></section><section><p>&quot;prototype&quot;</p><div class="wit-content"><section><p>= changing things slightly = optics</p><div class="wit-content" /></section></div></section><section><p>&quot;interpretation&quot;</p><div class="wit-content"><section><p>= denotational semantics</p><div class="wit-content" /></section><section><p>in this role sum types work better because in a language the constructs [the production rules] are usually not extensible</p><div class="wit-content" /></section></div></section><section><p>&quot;iterator&quot;</p><div class="wit-content"><section><p>= imperative traversable</p><div class="wit-content"><section><p><a href="http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/#iterator">see (Jeremy Gibbons and Bruno Oliveira : &quot;The essence of the Iterator pattern&quot;)</a></p><div class="wit-content" /></section></div></section><section><p>this is an example of the rare situation that the OO style is easier to understand, more intuitive</p><div class="wit-content" /></section></div></section><section><p>&quot;visitor&quot;</p><div class="wit-content"><section><p>the action performed by the &quot;iterator&quot;; &quot;iterator&quot; and &quot;visitor&quot; are 2 components of a single design pattern</p><div class="wit-content" /></section></div></section><section><p>&quot;memento&quot;</p><div class="wit-content"><section><p>= cloning, which is not needed with the absence of mutation</p><div class="wit-content" /></section></div></section><section><p>&quot;observer&quot;</p><div class="wit-content"><section><p>is an inherently OO solution; because it extends updating [an imperative thing] and designates a central object through which to drive the update; a perfect example for domain is user interface; i am not knowledgable in the domain of UI but i know that functional UI exist and its practitioners like it; at first thought it seems closest to the concept of traversal in functional programming; the OO version is more simple and intuitive</p><div class="wit-content" /></section></div></section><section><p>&quot;bridge&quot;</p><div class="wit-content"><section><p>i did not understand this one in the 10 minutes i was willing to spend on it</p><div class="wit-content" /></section></div></section><section><p>not OO specific</p><div class="wit-content"><section><p>&quot;resource pool&quot;</p><div class="wit-content" /></section><section><p>no real relation to  OO</p><div class="wit-content"><section><p>&quot;proxy&quot;</p><div class="wit-content"><section><p>= layering</p><div class="wit-content" /></section></div></section><section><p>&quot;mediator&quot;</p><div class="wit-content"><section><p>seems to be equivalent to a 2-input function</p><div class="wit-content" /></section></div></section><section><p>&quot;adapter&quot;</p><div class="wit-content" /></section><section><p>&quot;chain of responsibility&quot;</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>i hope i understood most of them correctly</p><div class="wit-content" /></section><section><p>note that for most of them at least one of the following statements is true</p><div class="wit-content"><section><p>involves mutable state; though in a few cases the functional equivalent is less intuitive : altogether the functional [controlled] state handling is almost always a better solution because of the enormous advantages of functional programming</p><div class="wit-content" /></section><section><p>just renames some very simple notion</p><div class="wit-content" /></section><section><p>unnecessarily overcomplicates some very simple notion with OO clothing</p><div class="wit-content" /></section><section><p>no real relation to OO [its categorization into &quot;OO design patter&quot; is incorrect]</p><div class="wit-content" /></section></div></section><section><p>how did this OO overusage evolve ?</p><div class="wit-content"><section><p>certain very popular OOP languges [java, c#] initially lacked essential language features [first class function, parametric type polymorphism, sum type] and by this they forced their users to use subtyping for all polymorphic problems; hence OOP became overused and people got used to overusing it</p><div class="wit-content" /></section></div></section></div></section><section><p>without OO</p><div class="wit-content"><section><p>can we do without OO? fortunately we already have enough practical experience to answer this question with confidence; in scala and haskell people are fine without OO; haskell does not provide OO and its users do not miss it; scala provides the most capabilities for OO among the popular industrial languages [variance, mixin inheritance, type members]; still : OO is fading from scala; the well-known scalaz library [whose authors are very knowledgable in both the technicalities of scala and in library level abstractions] chose to say goodby to OO; in both haskell and scalaz programmers rather use alternatives : the functional paradigm, higher order functions, parametric type polymorphism, type classes</p><div class="wit-content" /></section></div></section></span></body></html>