<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>object oriented programming</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">coding</a></span><span class="wit-nav-item"><a href="sltupaghfpuaijff.html">programming language</a></span><span class="wit-nav-item"><a href="sgdgrgstvwioqtwb.html">bad language features</a></span><span class="wit-nav-item wit-nav-current-page">object oriented programming</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>what is &quot;object oriented&quot; programming?</p><div class="wit-content"><section><p>first of all: a paradigm can not contain something that is not distinctive of other paradigms</p><div class="wit-content"><section><p>if a language feature is present in languages generally than that feature is not distinctive and hence can not be part of a programming paradigm, like OO</p><div class="wit-content" /></section></div></section><section><p>to define &quot;object oriented&quot; is difficult task; the meaning is widely debated; in such situation it is good to go to </p><div class="wit-content" /></section><section><p>objective criteria to interpret the term</p><div class="wit-content"><section><p>the meaning of the term</p><div class="wit-content"><section><p>an &quot;object&quot; is a value with an identity [usually identified by its storage location in memory]; the reason to distinguish between different objects with the same value is and only is the possibility of mutation; the functional paradigm does not have objects; hence &quot;object&quot; is equivalent to imperativeness</p><div class="wit-content" /></section></div></section><section><p>the original meaning of the author of the term</p><div class="wit-content"><section><p>the term &quot;object oriented&quot; was coined by Alan Kay; the most informative text about his thinking about it that i found is &quot;OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things.&quot;</p><div class="wit-content" /></section><section><p>my interpretation of Alan Kay&#39;s definition</p><div class="wit-content"><section><p>imperativeness</p><div class="wit-content"><section><p>he talks about state, which suggests [though does not surely imply] that he meant imperativeness</p><div class="wit-content" /></section><section><p>&quot;local retention and protection and hiding of state-process&quot; - i interpret this as just hiding of the representation of the data type of the state; but hiding anyhing is a simple natural feautre, practically all languages provide this feature; hence it is not a distinctive</p><div class="wit-content" /></section></div></section><section><p>&quot;late-binding&quot; means that the methods are dispatched dynamically</p><div class="wit-content" /></section></div></section></div></section><section><p>the practice of using the term</p><div class="wit-content"><section><p>let us identify OO languages and non-OO languages and see what is the differene between them</p><div class="wit-content" /></section><section><p>some of the languages most known as OO are Java, C#</p><div class="wit-content" /></section><section><p>the language most known as not-OO is Haskell</p><div class="wit-content" /></section><section><p>the difference between them mostly is imperativeness and the method dispatch being dynamic; Haskell is famous about being the opposite of these features</p><div class="wit-content" /></section></div></section></div></section><section><p>conclusion of the objective criteria: OO is imperativeness and the method dispatch being dynamic</p><div class="wit-content"><section><p>these 2 things are independent of each other</p><div class="wit-content"><section><p>this suggests either that my definition of OO is wrong or that OO is something wrong; i think my interpretation is good and OO is wrong</p><div class="wit-content" /></section></div></section></div></section><section><p>other opinions</p><div class="wit-content"><section><p>one modern interpretation of OO is that imperativeness does not have to be a part of it; this view is strongly shown by the Scala language, for example</p><div class="wit-content"><section><p>this is often referred to with the name &quot;functional OOP&quot;; but the name mainly contains &quot;object&quot;, which means imperativeness, hence this name is inconsistent</p><div class="wit-content" /></section></div></section><section><p>one opinion is that &quot;object&quot; means not imperativeness but &quot;message passing&quot;, but that must be wrong, because message passing of OO is just method invokation, which is part of all languages, not a distinctive feature</p><div class="wit-content" /></section><section><p>what else could OOP be? </p><div class="wit-content"><section><p>run-time type testing? - even the OO culture considers it a dirty practise, to be avoided</p><div class="wit-content" /></section><section><p>method implementation inheritance? - Haskell has it too</p><div class="wit-content" /></section><section><p>dynamic binding? - haskell also has it, though with more code verbosity</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>main conclusion</p><div class="wit-content"><section><p>till here i came to the conclusion that OOP is mainly state mutation and unnecessary push of dynamic binding; the earlier ruins our software coding efficiency, the later makes type interfacing hardly usable; giving nothing significant in return that we would expect from a programming paradigm</p><div class="wit-content" /></section></div></section><section><p>OO is wrong</p><div class="wit-content"><section><p>to see why we need to decompose OO into its 2 components</p><div class="wit-content" /></section><section><p>imperative programming</p><div class="wit-content"><section><p>may have some legitimacy in simple low level programming, but otherwise it is idiotic</p><div class="wit-content" /></section><section><p><a href="zxsbxwlppaypmpnn.html">link to &#39;functional programming&#39;</a></p><div class="wit-content" /></section></div></section><section><p><a href="ejqltwjmfjcvjpnf.html">dynamic method dispatch</a></p><div class="wit-content" /></section><section><p>in most languages both imperativeness and the method dispatch being dynamic are bad ideas, but these 2 features together form an unfortunate combination as this combination is wrong in all languages; imperativeness may be good for simple languages for high manual control over run-time efficiency; but for that dynamic dispatch is wrong, as it is slow</p><div class="wit-content" /></section></div></section><section><p>why did OO usage grow so big?</p><div class="wit-content"><section><p>because the languages that pushed it became popular; not because of OOP but each for some unrelated reason; for example Java and C# were backed by big companies, Java additionally promised &quot;write once, run everywhere&quot;, c++ did not have a competitor</p><div class="wit-content" /></section></div></section><section><p>OO mania</p><div class="wit-content"><section><p>it is not only the languages, but culture too; so named &quot;OO design patterns&quot;, &quot;OO design&quot;, &quot;OO architecture&quot; flud the industrial software development world</p><div class="wit-content" /></section><section><p><a href="rpkievmcwfnpmvlt.html">a lot of OO design patterns exist</a></p><div class="wit-content" /></section><section><p>how did this OO overusage happen?</p><div class="wit-content"><section><p>certain very popular OOP languges [java, c#] initially lacked essential language features [first class function, parametric type polymorphism, sum type] and by this they forced their users to use subtyping for all polymorphic problems; hence OOP became overused and people got used to overusing it</p><div class="wit-content" /></section></div></section></div></section><section><p>without OO</p><div class="wit-content"><section><p>can we do without OO? fortunately we already have enough practical experience to answer this question with confidence; Haskell does not provide OO and its users do not miss it at all</p><div class="wit-content" /></section></div></section></span></body></html>