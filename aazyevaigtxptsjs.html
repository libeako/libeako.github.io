<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>level of programming</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">coding</a></span><span class="wit-nav-item"><a href="sltupaghfpuaijff.html">programming language</a></span><span class="wit-nav-item wit-nav-current-page">level of programming</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>i mean &quot;level&quot; in the sense of this order: hardware, assembly programming language, C, Java, Haskell</p><div class="wit-content" /></section><section><p>i know about 2 kinds of levels</p><div class="wit-content"><section><p>conceptual - how we humans think about the program</p><div class="wit-content" /></section><section><p>technical - what is done automatically by the compiler and the run-time environment instead of the human coder</p><div class="wit-content" /></section></div></section><section><p>conceptual level</p><div class="wit-content"><section><p>imperative</p><div class="wit-content"><section><p>the program source is a list of instructions; specifies what the machine to do</p><div class="wit-content" /></section></div></section><section><p>functional</p><div class="wit-content"><section><p>the program source is a set of equations </p><div class="wit-content" /></section><section><p><a href="zxsbxwlppaypmpnn.html">see more</a></p><div class="wit-content" /></section></div></section><section><p>a functional program is not asymptotically slower than its imperative version</p><div class="wit-content" /></section><section><p>logic</p><div class="wit-content"><section><p>the program source is a set of logical statements about the input and output of the program</p><div class="wit-content" /></section><section><p>the logical program is often asymptotically less efficient than its functional version</p><div class="wit-content" /></section></div></section><section><p>informal text, compiled into program by artificial intelligence</p><div class="wit-content" /></section></div></section><section><p>technical level</p><div class="wit-content"><section><p>automation</p><div class="wit-content"><section><p>memory management</p><div class="wit-content"><section><p>in this section i clear some terminology that i feel are often used incorrectly</p><div class="wit-content" /></section><section><p>example of a language that does not have any automatism in memory management is c</p><div class="wit-content" /></section><section><p>garbage disposal</p><div class="wit-content"><section><p>&quot;disposal&quot; is a better word than &quot;collection&quot;</p><div class="wit-content"><section><p>collection is just a part of disposal, but we also want to reclaim the memory of the identified garbage</p><div class="wit-content" /></section><section><p>some garbage disposal systems are not stop-the-world, do not have a collecting phase</p><div class="wit-content"><section><p>for example: reference counting</p><div class="wit-content" /></section></div></section></div></section><section><p>c++ programming has partially automatic garbage disposal; by RAII, smart pointers; circular references are not discoverable with those though</p><div class="wit-content" /></section><section><p>java, haskell has fully automatic garbage disposal, including of circles</p><div class="wit-content" /></section></div></section><section><p>layout management</p><div class="wit-content"><section><p>whether an object contains an other [as in memory] or refers to it with a pointer</p><div class="wit-content"><section><p>the Haskell compiler does some of this</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p><a href="gvlvjsxsrqfqfght.html">evaluation order</a></p><div class="wit-content" /></section><section><p>maintaining thread pools, the programmer only needs to specify &quot;task&quot;s</p><div class="wit-content" /></section></div></section><section><p><a href="yjnweovfnkfncnhp.html">effect on runtime efficiency</a></p><div class="wit-content" /></section></div></section></span></body></html>