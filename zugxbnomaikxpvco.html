<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>makes laziness easy</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="rmciseizvhdgclym.html">user interface</a></span><span class="wit-nav-item"><a href="oeyeaezscdudpssh.html">formal languages</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">software coding</a></span><span class="wit-nav-item"><a href="ftkadhwzfhvfbwnk.html">correct by construction</a></span><span class="wit-nav-item"><a href="brqzviybtynlulwl.html">avoiding dangers</a></span><span class="wit-nav-item"><a href="zxsbxwlppaypmpnn.html">functional programming</a></span><span class="wit-nav-item"><a href="rqeeitsvmgrogdjp.html">introduction</a></span><span class="wit-nav-item"><a href="xaxqaihzanoadfll.html">advantages</a></span><span class="wit-nav-item wit-nav-current-page">makes laziness easy</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>lazy initialization of variables is used when the programmer can not or does not want to know when to compute the initial value and hence delegates this task to the run-time system, lets the control out of his hands</p><div class="wit-content" /></section><section><p>effects</p><div class="wit-content"><section><p>the order of side-effects is important, hence lazy evaluation in side-effect-ful environment is error-prone</p><div class="wit-content" /></section><section><p>in functional programming (because of absense of side-effects) evaluation may freely happen in any order [Church-Rosser theorem]; [non-side-] effects may still be in a functional program; the order of constituent effects in a complex effect is explicitly expressed in the calculated value that represents the complex effect</p><div class="wit-content"><section><p><a href="https://en.wikipedia.org/wiki/Church-Rosser_theorem">link to &#39;Church-Rosser theorem&#39;</a></p><div class="wit-content" /></section></div></section></div></section><section><p><a href="gvlvjsxsrqfqfght.html">automation</a></p><div class="wit-content" /></section></span></body></html>