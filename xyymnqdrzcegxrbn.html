<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>haskell</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">coding</a></span><span class="wit-nav-item"><a href="sltupaghfpuaijff.html">programming language</a></span><span class="wit-nav-item"><a href="ktzhlnzmvifgfkxo.html">concrete languages</a></span><span class="wit-nav-item wit-nav-current-page">haskell</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>Haskell is amazing</p><div class="wit-content"><section><p>it is free as free speach</p><div class="wit-content" /></section><section><p>it became the best teaching ground for coders</p><div class="wit-content" /></section><section><p>though it was created by the academy, it evolved in the practical side and now is a general purpose language suitable for industrial usage</p><div class="wit-content" /></section><section><p>it contributed much for research of many aspects of languages</p><div class="wit-content" /></section><section><p>Haskell is central in academic coding; one of its goals was to be a laboratory for language ideas; it served this goal very well</p><div class="wit-content"><section><p>here are just some main results:</p><div class="wit-content"><section><p>it proved that purely functional programming is not only suitable for practical software development, but that it is the right way to go for any high [like Java] level language</p><div class="wit-content" /></section><section><p>it proved that laziness by default is okay for practical software development</p><div class="wit-content" /></section><section><p>it is the first practical language to provide higher kinded types</p><div class="wit-content" /></section><section><p>it is the language that taught to the world how to do type interfacing [type-classes]</p><div class="wit-content" /></section></div></section><section><p>these features play together very well, and make Haskell an ideal environment for mathematical abstractions; this was used to translate some category theoretical knowledge into software coding; its concrete results, like functor, applicative, monad, traversable are now ubiquitous in everyday Haskell coding</p><div class="wit-content" /></section></div></section><section><p>despite its awesome performance in research, and its 30 years age: it stayed remarkably clean relatively to the amount of capabilities; i feel that Haskell is more simple, intuitive, sane than the industrial languages</p><div class="wit-content" /></section><section><p>beside the extraordinary success in the research side: it also beats the industrial languages [java, c# and all] in their territory, in suitability for practical sofware development</p><div class="wit-content" /></section></div></section><section><p>general learning source</p><div class="wit-content"><section><p>the Haskell wiki</p><div class="wit-content" /></section><section><p><a href="https://en.wikibooks.org/wiki/Haskell">wikibook</a></p><div class="wit-content" /></section><section><p>TypeClassopedia</p><div class="wit-content" /></section><section><p>StackOverflow</p><div class="wit-content" /></section></div></section><section><p>compiling</p><div class="wit-content"><section><p><a href="xgasjmlsnagvmvom.html">ghc</a></p><div class="wit-content" /></section></div></section><section><p>type system</p><div class="wit-content"><section><p>existentials</p><div class="wit-content"><section><p><a href="http://kseo.github.io/posts/2016-12-19-encoding-existentials.html">Kwan: Encoding existentials</a></p><div class="wit-content" /></section></div></section><section><p><a href="http://www.parsonsmatt.org/2017/04/26/basic_type_level_programming_in_haskell.html">Matt Parsons: Basic Type Level Programming in Haskell</a></p><div class="wit-content" /></section><section><p><a href="https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html">fixed sized vector</a></p><div class="wit-content" /></section><section><p>structural polymorphism</p><div class="wit-content"><section><p><a href="https://jeltsch.wordpress.com/2016/02/22/generic-programming-in-haskell/">a very nice article from Wolfgang Jeltsch</a></p><div class="wit-content" /></section></div></section><section><p>Richard Eisenberg, Peyton Jones: Levity Polymorphism</p><div class="wit-content"><section><p>i recommend this article to every Haskell programmer; it is about polymorphism with boxed types</p><div class="wit-content" /></section></div></section><section><p>type class</p><div class="wit-content"><section><p><a href="http://kseo.github.io/posts/2017-02-02-context-reduction.html">Kwang: Context reduction</a></p><div class="wit-content" /></section><section><p><a href="http://kseo.github.io/posts/2017-02-06-reified-dictionaries.html">Kwang: Reified dictionaries</a></p><div class="wit-content" /></section><section><p><a href="https://kseo.github.io/posts/2017-02-05-avoid-overlapping-instances-with-closed-type-families.html">Kwang: Avoid overlapping instances with closed type families</a></p><div class="wit-content" /></section></div></section><section><p>constraint kind</p><div class="wit-content"><section><p><a href="https://jeltsch.wordpress.com/2013/02/14/the-constraint-kind/">The Constraint kind - by Wolfgang Jeltsch </a></p><div class="wit-content" /></section><section><p><a href="https://kseo.github.io/posts/2017-01-13-constraint-kinds.html">Kwang: Constraint Kinds</a></p><div class="wit-content" /></section><section><p>abstractions on constrained categories</p><div class="wit-content"><section><p><a href="https://dorchard.wordpress.com/2011/10/18/subcategories-in-haskell-exofunctors/">Dominic Orchard: Subcategories &amp; “Exofunctors” in Haskell</a></p><div class="wit-content" /></section></div></section></div></section><section><p>inference</p><div class="wit-content"><section><p><a href="https://wiki.haskell.org/Simonpj/Talk:OutsideIn">OutsideIn - Modular type inference with local assumptions</a></p><div class="wit-content" /></section><section><p><a href="https://kcsongor.github.io/ambiguous-tags/">Preventing inference</a></p><div class="wit-content" /></section></div></section><section><p><a href="https://youtu.be/t0mhvd3-60Y">linear typing</a></p><div class="wit-content" /></section><section><p>singletons</p><div class="wit-content"><section><p><a href="https://blog.jle.im/entry/introduction-to-singletons-1.html">a tutorial from Justin Le</a></p><div class="wit-content" /></section></div></section></div></section><section><p>syntax</p><div class="wit-content"><section><p>extensions</p><div class="wit-content"><section><p>ApplicativeDo</p><div class="wit-content"><section><p>i recommend to generally avoid this extension</p><div class="wit-content" /></section><section><p>its usefulness is low</p><div class="wit-content" /></section><section><p>it has some problems</p><div class="wit-content"><section><p>its compile algorithm runs for n^3 time; i would not use it with n^2 time</p><div class="wit-content" /></section><section><p>it is easy to introduce infinite recursion by using do-notation in the implementation of fmap, (&lt;*&gt;)</p><div class="wit-content" /></section></div></section></div></section></div></section></div></section><section><p><a href="https://markkarpov.com/post/short-bs-and-text.html">text types</a></p><div class="wit-content" /></section><section><p><a href="http://mpickering.github.io/posts/2017-03-20-inlining-and-specialisation.html">&quot;Inlining and Specialisation&quot; by Matthew Pickering</a></p><div class="wit-content" /></section><section><p>base library</p><div class="wit-content"><section><p>fold</p><div class="wit-content"><section><p><a href="http://www.well-typed.com/blog/90/">Well-Typed: Fixing foldl</a></p><div class="wit-content" /></section></div></section><section><p><a href="http://kseo.github.io/posts/2014-02-03-data-typeable-and-data-dynamic-in-haskell.html">Kwang: Data.Typeable and Data.Dynamic in Haskell</a></p><div class="wit-content" /></section><section><p><a href="http://kseo.github.io/posts/2016-12-11-how-to-read-arrow-combinators.html">Kwang: How to read arrow combinators</a></p><div class="wit-content" /></section></div></section><section><p><a href="http://kseo.github.io/posts/2016-12-22-pattern-synonyms.html">Kwan: Pattern Synonyms</a></p><div class="wit-content" /></section><section><p>exceptions [thrown and caught]</p><div class="wit-content"><section><p><a href="https://www.tweag.io/posts/2020-04-16-exceptions-in-haskell.html">The three kinds of Haskell exceptions and how to use them</a></p><div class="wit-content" /></section><section><p>by Michael Snoyman</p><div class="wit-content"><section><p><a href="https://www.fpcomplete.com/blog/2018/04/async-exception-handling-haskell">writing</a></p><div class="wit-content" /></section><section><p><a href="https://youtu.be/T5y8sFmCFnA">video</a></p><div class="wit-content" /></section></div></section></div></section></span></body></html>