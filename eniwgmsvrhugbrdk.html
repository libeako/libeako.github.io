<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>causes</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">coding</a></span><span class="wit-nav-item"><a href="ezrdpkjrokawnikj.html">the industry-academy gap</a></span><span class="wit-nav-item wit-nav-current-page">causes</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>most of the used programming languages are wrongly [even idiotically] designed; the most notable exception is Haskell which shows a right direction; but the industry does not look at it, does not care about it; the gap between Haskell and the other [the stupid] languages grew very big</p><div class="wit-content" /></section><section><p>why did the gap grow?</p><div class="wit-content"><section><p>because the languages that derailed the coding industry from the right direction became popular; not because they were good but each for some other reason</p><div class="wit-content"><section><p>Java promised &quot;write once, run everywhere&quot;</p><div class="wit-content" /></section><section><p>Java and C# were backed by big companies</p><div class="wit-content" /></section><section><p>C++ did not have a competitor</p><div class="wit-content" /></section></div></section></div></section><section><p>why did the gap stay?</p><div class="wit-content"><section><p>the network effect</p><div class="wit-content"><section><p>for compatibility and reusability</p><div class="wit-content" /></section></div></section><section><p>the herd effect</p><div class="wit-content"><section><p>it always seems safer to go where the herd goes</p><div class="wit-content" /></section></div></section><section><p>the industry does not know that it could do much better, they do not even suspect that</p><div class="wit-content"><section><p>most of the problems in the industry are grown from the popular programming languages being wrongly designed</p><div class="wit-content" /></section><section><p>the industry</p><div class="wit-content"><section><p>Philip Wadler, a famous researcher: &quot;for many years people in industry have managed to pretty much ignore everything we do&quot;</p><div class="wit-content" /></section><section><p>the industry people do not know about the Haskell world and do not imagine that they can be of any good</p><div class="wit-content" /></section><section><p>i</p><div class="wit-content"><section><p>when i was a beginner coder: for several years i thought the following</p><div class="wit-content"><section><p>what the academy people do is only mental masturbation; they think about mathematical problems that interest them, but are not helpful in everyday coding practice</p><div class="wit-content" /></section><section><p>coding is mainly about fighting complexity and bugs, practise and not theory is what helps in that</p><div class="wit-content" /></section><section><p>coding is a very practical activity, hence may be known only by the people who do the practice, who are industrial coders, who do it full time, for many years; language researchers code very little</p><div class="wit-content" /></section><section><p>if some academy knowledge was good for anything then practitioners would know about it; after all: the whole globe would not let something useful in waste</p><div class="wit-content"><section><p>one problem with this is that if the portion of people thinking so is most of the people then the rest is too little to wake the majority up</p><div class="wit-content" /></section></div></section><section><p>math is important in algorithm design, but why would it be even just slightly useful in coding?</p><div class="wit-content" /></section></div></section><section><p>when i learned the basic results of the Haskell world: i realized to my amusement: all of these previous presumptions of me were wrong</p><div class="wit-content" /></section><section><p>i guess most industrial people make these same thought mistakes that i did</p><div class="wit-content" /></section></div></section><section><p>the language users [&quot;coders&quot;]</p><div class="wit-content"><section><p>according to my observation of how coders usually choose programming language and programming methodology:</p><div class="wit-content" /></section><section><p>they learn technologies that are demanded in the industry, to make money</p><div class="wit-content" /></section><section><p>mostly they do not look further than where they get a job, to learn good but rare technologies, because they are loaded with other tasks to do</p><div class="wit-content"><section><p>this is correct behaviour by them, it would be horrendously inefficient if ordinary coders had to learn programming theory, language design and such</p><div class="wit-content" /></section></div></section></div></section><section><p>the industry language designers</p><div class="wit-content"><section><p>are the ones who make the mistake; it is their fault that their products [the languages] are bad; the industry langauge designers are </p><div class="wit-content"><section><p>very amature, despite having been doing this kind of work for decades, despite most of the coding world using their products</p><div class="wit-content" /></section><section><p>professional idiots</p><div class="wit-content"><section><p>they are idiots in their professions</p><div class="wit-content" /></section><section><p>they are professionals in being idiots</p><div class="wit-content"><section><p>as they still manage to convince most of the world to use their idiotic languages</p><div class="wit-content" /></section></div></section></div></section><section><p>these people should leave, in shame and be replaced by people who know that the proper [high level] language are like Haskell and Lean</p><div class="wit-content" /></section></div></section></div></section><section><p>busieness managers</p><div class="wit-content"><section><p>are the ones who could change the language designers; they are the bosses of the language designers; but they do not know about the problem; they look at the users of the languages and see mostly satisfaction, no screaming problem; they should hear screaming, somebody should scream at them to wake them up</p><div class="wit-content" /></section></div></section></div></section><section><p>the Haskell world</p><div class="wit-content"><section><p>does not scream; they just share their results, tell that they like these results, but do not push the results onto the industry; they do not initiate discussions, let alone debates about the mistakes in the industry language designs</p><div class="wit-content"><section><p>one cause of this is that the academy and the Haskell world are too polite to tell the dark truth about the popular languages</p><div class="wit-content"><section><p>this is partly because the industry is mainly controlled in the West, where overly politeness is almost necessary to get along in any company politically; i, for example, was banned forever from r/functional-programming, because i wrote that the other [than Haskell] languages are &quot;stupid&quot; and insisted that i was correct to write that; but without saying that out so: the business managers will not know that; they will continue to think that the popular languages are mostly okay; it is not possible to raise attention to the severity of the problem without being honest about the severity of the problem; phrasing the message with politely distorted words will stop the real message from spreading</p><div class="wit-content" /></section></div></section></div></section></div></section></div></section></div></section></span></body></html>