<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>monad</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="oibaxnylzhpktgho.html">algebra</a></span><span class="wit-nav-item"><a href="nfoegqpcgzhctwbv.html">magma</a></span><span class="wit-nav-item"><a href="eovnsnrjngyuihhx.html">semigroup</a></span><span class="wit-nav-item"><a href="cabjryjnnstdjmvb.html">monoid</a></span><span class="wit-nav-item"><a href="edsabrzmtmhnwgml.html">category</a></span><span class="wit-nav-item"><a href="yboclzmzvuwqxcdt.html">functor</a></span><span class="wit-nav-item"><a href="kaxxmpbkqesnqecy.html">monoidal</a></span><span class="wit-nav-item wit-nav-current-page">monad</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>monad in the function category is an interface of type functions</p><div class="wit-content" /></section><section><p>intuition</p><div class="wit-content"><section><p>you could have invented monads in programming; here is how:</p><div class="wit-content" /></section><section><p>kliesli composition</p><div class="wit-content"><section><p>in functional programming effects may not happen to the side, but has to be covered by the output type of the function; if we want to load a function of type (x -&gt; y) with some additional effect then we need to change the type of the function to (x -&gt; c y), where c is a type function, creating a type whose values represent both the y as content and the additional effect as context</p><div class="wit-content" /></section><section><p>these types of functions are said to be the &quot;Kliesli&quot; (&quot;functions&quot; or &quot;arrows&quot;)</p><div class="wit-content"><section><p>newtype Kliesli c x y = Kliesli {x -&gt; c y}</p><div class="wit-content" /></section></div></section><section><p>to be able to work with effects of type c it is necessary that (Kliesli c) is a category; this is also a sufficient condition, because any algorithm building block type [function application, tuple formation, ...] is derivable from function composition</p><div class="wit-content" /></section><section><p>one of the possible monad definitions is that c is a monad iff (Kliesli c) is a category</p><div class="wit-content"><section><p>interface Monad c &lt;= Category (Kliesli c) where</p><div class="wit-content" /></section></div></section><section><p>to be able to work with monad without the Kliesli wrapper we can define it as</p><div class="wit-content"><section><p>interface Monad c where</p><div class="wit-content"><section><p>pure : e -&gt; c e</p><div class="wit-content" /></section><section><p>(&gt;=&gt;) : (x -&gt; c y) -&gt; (y -&gt; c z) -&gt; (x -&gt; c z)</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>functor provides only very basic functionality, hence we expect it to be provided by monad too; monad does provide functor, indeed, good excercise for you to check</p><div class="wit-content" /></section><section><p>join</p><div class="wit-content"><section><p>an approach to an other definition of monad is to start from functor and try to implement the kliesli composition</p><div class="wit-content" /></section><section><p>using the functor property we can easily implement something close to the kliesli composition:</p><div class="wit-content"><section><p>kliesli_try_1 : Functor m =&gt; (x -&gt; m y) -&gt; (y -&gt; m z) -&gt; (x -&gt; m (m z))</p><div class="wit-content" /></section><section><p>kliesli_try_1 f g = f &gt;&gt;&gt; map g </p><div class="wit-content" /></section></div></section><section><p>but this is not exactly klieli composition, because the result is in a 2-layer container</p><div class="wit-content" /></section><section><p>if we could collapse the 2 layers into 1 then we would be able to implement the kliesli composition exactly; and that is what one definition of monad requires, such a collapsing method; it is traditionally named &quot;join&quot;:</p><div class="wit-content"><section><p>interface Monad m &lt;= Functor m where</p><div class="wit-content"><section><p>join : m (m x) -&gt; m x</p><div class="wit-content"><section><p>law: must be associative</p><div class="wit-content" /></section></div></section><section><p>pure : e -&gt; c e</p><div class="wit-content"><section><p>law: must be neutral in join</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>this definition of monad makes it easily appearant how monad is a special monoid, on the layers of contexts</p><div class="wit-content" /></section><section><p>then the kliesli composition is</p><div class="wit-content"><section><p>kliesli : Monad m =&gt; (x -&gt; m y) -&gt; (y -&gt; m z) -&gt; (x -&gt; m z)</p><div class="wit-content" /></section><section><p>kliesli f g = f &gt;&gt;&gt; map g &gt;&gt;&gt; join </p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>in practice often a different definition of monad is used, in which a &quot;monad bind&quot; method is instead of &#39;join&#39;</p><div class="wit-content"><section><p>without the laws:</p><div class="wit-content" /></section><section><p>interface Monad m where</p><div class="wit-content"><section><p>pure : x -&gt; m x</p><div class="wit-content" /></section><section><p>(&gt;&gt;=) : m x -&gt; (x -&gt; m y) -&gt; m y</p><div class="wit-content" /></section></div></section><section><p>the advantage of the definition with bind is assumed run-time efficiency [i assume], the advantage of the other 2 is elegance</p><div class="wit-content" /></section></div></section><section><p>other sources</p><div class="wit-content"><section><p>Philip Wadler wrote an introductory article about using monads in functional programming; the article contains many examples</p><div class="wit-content"><section><p><a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">Monads for functional programming</a></p><div class="wit-content" /></section></div></section><section><p><a href="https://wiki.haskell.org/Monad_laws">a Haskell intro article to monad laws</a></p><div class="wit-content" /></section><section><p><a href="https://wiki.haskell.org/Typeclassopedia">at typeclassopedia</a></p><div class="wit-content" /></section></div></section><section><p>example for using monad</p><div class="wit-content"><section><p>loop</p><div class="wit-content"><section><p>a simple loop</p><div class="wit-content"><section><p>loop : (s -&gt; bool) -&gt; (s -&gt; s) -&gt; (s -&gt; s)</p><div class="wit-content" /></section><section><p>loop cond iter actual =</p><div class="wit-content"><section><p>if (cond actual)</p><div class="wit-content"><section><p>then loop iter cond (iter actual)</p><div class="wit-content" /></section><section><p>else actual</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>a monadic version [the iteration may have effect] </p><div class="wit-content"><section><p>loop : Monad m =&gt; (s -&gt; bool) -&gt; (s -&gt; m s) -&gt; (s -&gt; m s)</p><div class="wit-content" /></section><section><p>loop cond iter actual =</p><div class="wit-content"><section><p>if (cond actual)</p><div class="wit-content"><section><p>then loop iter cond =&lt;&lt; iter actual</p><div class="wit-content" /></section><section><p>else pure actual</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>analysis</p><div class="wit-content"><section><p>notice that the monadic version has the same structure, just the building blocks [function application, lifting a value to the monad level] of it are different</p><div class="wit-content" /></section></div></section></div></section></div></section></span></body></html>