<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>homomorphism</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="oibaxnylzhpktgho.html">algebra</a></span><span class="wit-nav-item wit-nav-current-page">homomorphism</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>homomorphism is a function between the value sets of 2 algebras of the same variety, so that the structural properties of that variety are kept</p><div class="wit-content" /></section><section><p>such functions are often named &quot;mapping&quot;s</p><div class="wit-content"><section><p>though &quot;mapping&quot; is sometimes also used for functions which are not necessarily homomorphisms</p><div class="wit-content" /></section></div></section><section><p>example</p><div class="wit-content"><section><p>to understand this example, you need to know :</p><div class="wit-content"><section><p><a href="cabjryjnnstdjmvb.html">monoid</a></p><div class="wit-content" /></section></div></section><section><p>size : List e -&gt; Integer</p><div class="wit-content" /></section><section><p>the size function is a homomorphism from (the monoid of lists with list concatenation) to (the monoid of integers with addition), because</p><div class="wit-content"><section><p>it maps (the empty element of the list monoid [the empty list]) to (the empty element of the integer monoid [0])</p><div class="wit-content" /></section><section><p>it maps (the concatenation of 2 lists) to (the addition of the sizes of those lists)</p><div class="wit-content" /></section></div></section></div></section><section><p>only the structure of the variety is to be kept</p><div class="wit-content"><section><p>note that the size homomorphism does not preserve all the structure of lists; for example the order of the elements of the lists is lost; this is okay; a homomorphism needs to preserve only the structure which is specified by the algebra variety, in this case : the properties that make the collection of lists a monoid; the structure of an individual list is the internal structure of that list, that is of a value of the algebra; a homomorphism needs to preserve only the structure between the values [the structure of the algebra variety] and not the structure inside the individual values of the algebra</p><div class="wit-content" /></section></div></section><section><p>any-time transition</p><div class="wit-content"><section><p>a homomorphism is like a one-way travel between 2 worlds [algebras] which possibly contain different elements, but same [algebraic] structure between the elements</p><div class="wit-content" /></section><section><p>the nice thing about homomoprhisms is that one can make the move [the travel between the worlds] any time during an algorithm that uses only the methods of the algebra</p><div class="wit-content" /></section><section><p>imagine we have this algorithm</p><div class="wit-content"><section><p>have some value of the source algebra</p><div class="wit-content" /></section><section><p>compute with them using the methods of the algebra</p><div class="wit-content" /></section><section><p>move</p><div class="wit-content"><section><p>that is : transform the resultant values into the other algebra with the homomorphism</p><div class="wit-content" /></section></div></section><section><p>compute with the transformed values in the target algebra</p><div class="wit-content" /></section></div></section><section><p>the move could be at the beginning of the algorithm, or at the end, or anywhere; with other words : it does not matter in which algebra we perform the methods of the algebra</p><div class="wit-content" /></section><section><p>this can be used in justifying optimizing program transformations</p><div class="wit-content"><section><p>the (size : List e -&gt; Integer) function is a good example </p><div class="wit-content"><section><p>if we are interested only in the size of the concatenation of some lists then we better sum the sizes of the individual lists then concatenate the lists and count its elements, because integer addition is cheaper than list concatenation</p><div class="wit-content" /></section></div></section></div></section><section><p>the homomorphism property does not enable us to go back, from the target world to the source world</p><div class="wit-content" /></section></div></section><section><p>isomorphism</p><div class="wit-content"><section><p>makes it possible to go back</p><div class="wit-content" /></section><section><p>it is an invertible function between values of algebras which preserves the algebraic structure in both directions [that is : both it and its inverse are homomorphisms]</p><div class="wit-content" /></section><section><p>the algebraic layers of 2 isomorphic worlds [algebras] contain the same information, mathematically they are &quot;equivalent&quot;; the difference between such algebras is only in the individual values of them, which is insignificant from the algebraic view-point</p><div class="wit-content" /></section></div></section></span></body></html>