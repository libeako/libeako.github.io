<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>structural polymorphism</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">information technology</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="rmciseizvhdgclym.html">user interface</a></span><span class="wit-nav-item"><a href="oeyeaezscdudpssh.html">formal languages</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">software coding</a></span><span class="wit-nav-item"><a href="ftkadhwzfhvfbwnk.html">correct by construction</a></span><span class="wit-nav-item"><a href="jyulqiuyobsytqwf.html">static type checking</a></span><span class="wit-nav-item wit-nav-current-page">structural polymorphism</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>this is abstraction of values over types according to the data structures of the types</p><div class="wit-content" /></section><section><p>example</p><div class="wit-content"><section><p>think about the equality test function (==) : t -&gt; t -&gt; bool; what is the natural, sensible implementation of it? for built-in types it is trivial and supplied by the language semantics; what about composite types? for product types it is natural and common to define the equality test as the conjunction of all the equality tests on the members of the product type, that is : the corresponding data members are compared and the overall equality is true iff all the members are equal; for sum types it is natural and common to define the equality so that to be true their case must equal and then the data stored in it must equal; thus we give a natural and common definition of all types, which are constructed from built-in types composed by the product and sum type construction</p><div class="wit-content" /></section></div></section><section><p>generally</p><div class="wit-content"><section><p>we can define a value abstract over multiple of types in the following way</p><div class="wit-content"><section><p>define it on some ground types</p><div class="wit-content" /></section><section><p>define it for a subset of data structure constructions</p><div class="wit-content"><section><p>product, sum, function type constructions</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>more examples</p><div class="wit-content"><section><p>equality test</p><div class="wit-content" /></section><section><p>comparison by ordering</p><div class="wit-content" /></section><section><p>serialization</p><div class="wit-content" /></section><section><p>functorial map</p><div class="wit-content" /></section><section><p>fold</p><div class="wit-content" /></section></div></section><section><p>terminology</p><div class="wit-content"><section><p>this method has multiple names in use [&quot;generic&quot;, &quot;polytypic&quot;], but none of them seems good for me</p><div class="wit-content" /></section><section><p><a href="fcatpqbmpylblkny.html">&quot;polymorphic&quot; &lt;-&gt; &quot;polytypic&quot;</a></p><div class="wit-content" /></section></div></section><section><p>haskell</p><div class="wit-content"><section><p>haskell provides tool for such generic definitions; but its implementation is cheap in the sense that the evaluation of such generic values often comes with [asymptotically constant] calculational overhead</p><div class="wit-content" /></section></div></section><section><p>other sources</p><div class="wit-content"><section><p>a first tuturial</p><div class="wit-content"><section><p><a href="https://jeltsch.wordpress.com/2016/02/22/generic-programming-in-haskell/">Generic programming in Haskell - by Wolfgang Jeltsch</a></p><div class="wit-content" /></section></div></section></div></section></span></body></html>