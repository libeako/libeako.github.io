<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>yoneda lemma</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="oibaxnylzhpktgho.html">algebra</a></span><span class="wit-nav-item"><a href="nfoegqpcgzhctwbv.html">magma</a></span><span class="wit-nav-item"><a href="eovnsnrjngyuihhx.html">semigroup</a></span><span class="wit-nav-item"><a href="cabjryjnnstdjmvb.html">monoid</a></span><span class="wit-nav-item"><a href="edsabrzmtmhnwgml.html">category</a></span><span class="wit-nav-item"><a href="yboclzmzvuwqxcdt.html">functor</a></span><span class="wit-nav-item wit-nav-current-page">yoneda lemma</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>intuition</p><div class="wit-content"><section><p>it is well known that all things are isomorphic with a thing that can turn any continuation to the result of the continuation</p><div class="wit-content" /></section><section><p>with formalism</p><div class="wit-content"><section><p>x ≅ λ (r : Type) -&gt; (x -&gt; r) -&gt; r</p><div class="wit-content" /></section></div></section><section><p>you can easily find the functions that map from one side to the other; that gives you an intuitive justification of the isomorphism; but proving that they are inverses of each other is difficult because it needs a free theorem</p><div class="wit-content"><section><p><a href="ejqpvlbcoexibqku.html">link to &#39;free theorems&#39;</a></p><div class="wit-content" /></section></div></section><section><p>you can find the proof including the free theorem in the article (Philip Wadler : Theorems for free!)</p><div class="wit-content" /></section></div></section><section><p>the general form of the yoneda lemma</p><div class="wit-content"><section><p>adds a functor &quot;F&quot;</p><div class="wit-content" /></section><section><p>F x ≅ λ (r : Type) -&gt; (x -&gt; r) -&gt; F r</p><div class="wit-content" /></section><section><p>the previously shown concrete version can be recovered from this general version by F := the identity functor</p><div class="wit-content" /></section><section><p>the proof of this theorem in its full category-theoretic generality is easy and available in almost all category-theory introductory books</p><div class="wit-content"><section><p><a href="yupvqrvgexyesprr.html">link to &#39;categrory theory: sources to learn from&#39;</a></p><div class="wit-content" /></section></div></section></div></section><section><p>&quot;the yoneda functor&quot;</p><div class="wit-content"><section><p>is a popular name for the right side of the yoneda isomorhism as expressed above</p><div class="wit-content" /></section><section><p>in haskell can be expressed like this</p><div class="wit-content"><section><p>newtype Yoneda f c = forall r . (c -&gt; r) -&gt; f r</p><div class="wit-content" /></section></div></section></div></section><section><p>the dual</p><div class="wit-content"><section><p>2 possibilities of dualizing the yoneda lemma are interesting :</p><div class="wit-content" /></section><section><p>for contravariant functor</p><div class="wit-content"><section><p>this is a very simple possibility of dualizing</p><div class="wit-content" /></section><section><p>F x ≅ λ (r : Type) -&gt; (r -&gt; x) -&gt; F r</p><div class="wit-content" /></section><section><p>here F is contravariant</p><div class="wit-content" /></section></div></section><section><p>an other possibility</p><div class="wit-content"><section><p>Coyoneda f x := f c (c -&gt; x)</p><div class="wit-content" /></section><section><p>notice that the type variable c is existentially qualified here</p><div class="wit-content" /></section><section><p>the conyoneda functor is the free functor</p><div class="wit-content" /></section><section><p>additional source</p><div class="wit-content"><section><p><a href="https://stackoverflow.com/a/24006085/112298">by J. Abrahamson</a></p><div class="wit-content" /></section><section><p><a href="http://alpmestan.com/posts/2017-08-17-coyoneda-fmap-fusion.html">From Hask Till Dawn : Coyoneda and fmap fusion</a></p><div class="wit-content" /></section></div></section></div></section></div></section></span></body></html>