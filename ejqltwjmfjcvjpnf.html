<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>dynamic method dispatch in static typing</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="abtagofukashimen.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="mhwolwyjddvhovlc.html">software</a></span><span class="wit-nav-item"><a href="pudclkcfncxvedwk.html">coding</a></span><span class="wit-nav-item"><a href="sltupaghfpuaijff.html">programming language</a></span><span class="wit-nav-item"><a href="sgdgrgstvwioqtwb.html">bad language features</a></span><span class="wit-nav-item wit-nav-current-page">dynamic method dispatch in static typing</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>interfaces contain methods; these methods are not concrete functions, but rather function families, containing different concrete functions for different types that implement the interface; the coder invokes a method, but the underlying system needs to find the concrete function to be invoked: [should &quot;dispatch&quot; the call to a concrete function]; the question arises: when to determine which concrete function should get the call [when to perform the dispatch]? in compile time [&quot;statically&quot;] or in run time [&quot;dynamically&quot;]?</p><div class="wit-content" /></section><section><p>in dynamically typed languages: the only possible answer is dynamically, as no type information is available in compile time</p><div class="wit-content" /></section><section><p>in statically typed languages: static dispatch is possible and dynamic dispatch is idiotic, because it has only negatives, very big ones; this part explaines those negatives</p><div class="wit-content" /></section><section><p>despite being idiotic: dynamic dispatch is chosen for almost all statically typed programming languages by their designers; also: users of such languages [who are almost all software coders in the statically typed world] feel fine with this decision, they do not see why it is bad, they think it is a perfectly legitimate design decision, that it is how it should be</p><div class="wit-content" /></section><section><p>the most notable exception is the Haskell language, which is well known for having chosen static dispatch</p><div class="wit-content" /></section><section><p>i recommend to you to learn</p><div class="wit-content"><section><p><a href="biuqwfqzzkpjuqob.html">the static dispatch world</a></p><div class="wit-content" /></section><section><p>before reading this</p><div class="wit-content" /></section></div></section><section><p>haskell-like languages do not provide dedicated support for dynamic dispatch</p><div class="wit-content"><section><p>they provide other language features [existential types] with which dynamic dispatch can be implemented at library level, with only slightly more verbosity than in the dynamically dispatching languages</p><div class="wit-content" /></section><section><p>dynamic dispatch is needed only very rarely</p><div class="wit-content"><section><p>this may surprise you, if you are used to dynamically dispatching languages, like Java and C#, which even forced the coder to use dynamic dispatch machinery, even when simpler but not provided tools [like sum types or higher order functions] would suffice; when a coder gets to use a well-designed language, like Haskell then the coder quickly sees that dynamic dispatch is needed only very rarely</p><div class="wit-content" /></section></div></section></div></section><section><p>the design of the dynamic dispatch mechanism</p><div class="wit-content"><section><p>the idea to perform the dispatch in run time may have come from the dynamically typed languages, but most language designers wanted to push it into statically typed languages too; this decision was idiotic, but it happened</p><div class="wit-content" /></section><section><p>dynamic dispatch queries the run-time type of the actual inputs of the invoked method to find the corresponding concrete function to invoke; the type of which inputs? so far as i know: the original idea in the dynamically typed languages was to use all the inputs for this</p><div class="wit-content" /></section><section><p>but that can not be used in statically typed languages</p><div class="wit-content"><section><p>what happens when we do not have a method implementation matching the types of the actual inputs? run-time execution failure; that is okay for dynamically typed langauges, as the possibility of run-time type-mismatch is normal for them anyway; but in a statically typed language it is not acceptable</p><div class="wit-content" /></section></div></section><section><p>but some people did insist to try to fuse the 2 things: dynamic dispatch and static typing</p><div class="wit-content" /></section><section><p>they had to ensure at compile time that dispatches be always successful; their idea was: restrict the dispatching to only 1 of the inputs</p><div class="wit-content"><section><p>which one sould that input be? for the sake of simplicity and uniformity: they decided that it should be the first one always</p><div class="wit-content" /></section><section><p>the dispatching input can be implicit</p><div class="wit-content"><section><p>because</p><div class="wit-content"><section><p>we do not need to know its type in compile time, as core of the idea is to defer that to run-time</p><div class="wit-content" /></section><section><p>it always exists</p><div class="wit-content" /></section></div></section><section><p>we can fix its name to &quot;this&quot; or &quot;self&quot; in the language specification</p><div class="wit-content" /></section></div></section><section><p>it is important to see that this solution was not a conceptual goal but a compromise; thus was the now popular [&quot;Java-like&quot;] version of dynamic dispatch born; as a child of the forced marriage of static typing and dynamic dispatch; crippled from birth</p><div class="wit-content" /></section></div></section></div></section><section><p>the negatives of dynamic dispatch</p><div class="wit-content"><section><p>the dispatch being delayed to run-time disables inlining, which is a crucial optimization</p><div class="wit-content"><section><p>some people claim that some of these dynamically dispatching languages [Java, .Net] solve this run-time efficiency problem in the execution engine; but that is far from the truth; all that is in the execution engine is the prediction of which concrete function will get the dispatch, based on previous dispatch results, and then inlining that function; this is close to being so fast as a compile time inlined invokation but works only if the dispatch result is the same for a long sequence of calls, which happens only in the simple cases</p><div class="wit-content" /></section></div></section><section><p>coding problems</p><div class="wit-content"><section><p>dynamic dispatch can not properly represent interface methods with multiple inputs with the same role</p><div class="wit-content"><section><p>example</p><div class="wit-content"><section><p>the Equatable interface in C#:</p><div class="wit-content"><section><p>interface IEquatable&lt;T&gt; { bool Equals (T other); }</p><div class="wit-content" /></section><section><p>in this code the 2 inputs of the &#39;Equals&#39; method are written differently syntactically; this suggests that the roles of the 2 inputs are differnt; that is a false suggestion; conclusion: dynamic dispatch can not properly express even one of the most simple and fundamental interfaces</p><div class="wit-content" /></section><section><p>in a Haskellish language</p><div class="wit-content"><section><p>interface Equatable t</p><div class="wit-content"><section><p>(==) : t -&gt; t -&gt; bool</p><div class="wit-content" /></section><section><p>this code perfectly mirrors the concept that it ought to rerpresent, including that the roles of the methods are the same</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>the story is similar with the also important &#39;Comparable&#39; interface</p><div class="wit-content" /></section></div></section></div></section><section><p>dynamic dispatch requires a run-time input with proper type</p><div class="wit-content"><section><p>some methods of some interface concepts do not have any input</p><div class="wit-content"><section><p>a trivial but useful example</p><div class="wit-content"><section><p>interface HasDefault t</p><div class="wit-content"><section><p>default : t</p><div class="wit-content" /></section></div></section></div></section><section><p>associating types to types</p><div class="wit-content" /></section></div></section><section><p>having some input does not make the method run-time dispatchable, because the input may be totally independent from the type that is to implement the interface; this is the case for example with some methods of the very important Applicative and Monad interfaces</p><div class="wit-content" /></section></div></section><section><p> conditionality of implementation is not possible with dynamic dispatch</p><div class="wit-content"><section><p>it is very common that we need to modify a type slightly, for example by wrapping it into a container [Maybe, Either, List, newtype wrappers, ...] type; for example just a function sometimes not being able to return successful result requires us to wrap its output into a Maybe</p><div class="wit-content" /></section><section><p>hence it is important that our type interface solution does not brake down when we try to make the container type to inherit the interfaces of their element types</p><div class="wit-content" /></section><section><p>this is easily okay with static typing, by conditioning the instance</p><div class="wit-content"><section><p>example</p><div class="wit-content"><section><p>equatability of Maybe</p><div class="wit-content"><section><p>instance Equatable (Maybe e) &lt;= Equatable e where</p><div class="wit-content"><section><p>Just x == Just y = x == y</p><div class="wit-content" /></section><section><p>Nothing == Nothing = True</p><div class="wit-content" /></section><section><p>_ = False</p><div class="wit-content" /></section></div></section><section><p>the instance is for (Maybe e) and the condition is about e</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>but languages with dynamic dispatch do not provide such capability; i guess because it would be too complex for them</p><div class="wit-content" /></section></div></section><section><p>dynamic dispatch requires the instance declaration at the site of the type</p><div class="wit-content"><section><p>if the coder does not have access to the code of a type then he can not modify which interfaces that type implements; can not, for example, implement an instance for a new interface and old type; in statically dispatching languages one can define a new interface and implement instances of that new interface for any old type, in the same module</p><div class="wit-content" /></section></div></section><section><p>dynamic dispatch requires that the instance is for a single type</p><div class="wit-content"><section><p>statically dispatching languages can allow multi-type interfaces, where the interface is not for a single type but for a combination of multiple types</p><div class="wit-content" /></section></div></section></div></section></div></section></span></body></html>