<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html><head><meta http-equiv="Content-Type" content="text/xhtml; charset=UTF-8" /><link rel="stylesheet" href="style.css" /><title>monoid</title></head><body><nav><p class="wit-nav-core"><span class="wit-nav-item"><a href="egynetwykdwaqemv.html">libeako</a></span><span class="wit-nav-item"><a href="npjvhykimwqkdzrj.html">topics</a></span><span class="wit-nav-item"><a href="sdduleiokczzemoa.html">info</a></span><span class="wit-nav-item"><a href="larizujwcjygozye.html">math</a></span><span class="wit-nav-item"><a href="oibaxnylzhpktgho.html">algebra</a></span><span class="wit-nav-item wit-nav-current-page">monoid</span></p></nav><hr class="wit-navigation-separator" /><span class="wit-page_main_part"><section><p>is a special semigroup</p><div class="wit-content"><section><p><a href="eovnsnrjngyuihhx.html">see semigroup</a></p><div class="wit-content" /></section><section><p>has 1 more operation, a 0-ary one</p><div class="wit-content"><section><p>it points out a value; the operation and the value it points out has the same name; but multiple names are in use</p><div class="wit-content"><section><p></p><div class="wit-content"><section><p>&quot;empty&quot;</p><div class="wit-content" /></section><section><p>&quot;neutral&quot;</p><div class="wit-content" /></section><section><p>&quot;identity&quot;</p><div class="wit-content" /></section></div></section><section><p>choice of them is decided mostly by personal flavor or the topic of discourse; in category theory almost everyone names it with &quot;identity&quot;; i do not like &quot;identity&quot;, because i associate it with something very different, like identifier, identity of a person</p><div class="wit-content" /></section></div></section></div></section><section><p>has 1 more law, which describes that the empty value behaves neutrally with the composition function from both sides</p><div class="wit-content"><section><p>for-all x</p><div class="wit-content"><section><p>empty ∙ x = x</p><div class="wit-content" /></section><section><p>x ∙ empty = x</p><div class="wit-content" /></section></div></section></div></section></div></section><section><p>in programming</p><div class="wit-content"><section><p>interface Monoid t &lt;= Semigroup t</p><div class="wit-content"><section><p>empty : t -- behaves neutrally in the Semigroup&#39;s composition function</p><div class="wit-content" /></section></div></section><section><p>Monoid inherits the composing function (∙) from Semigroup</p><div class="wit-content" /></section></div></section><section><p>examples</p><div class="wit-content"><section><p>i denote the examples with juxtaposition [separate the members of the monoid instance with only a space], the empty value is in the middle in the triple</p><div class="wit-content" /></section><section><p></p><div class="wit-content"><section><p>numbers 0 +</p><div class="wit-content" /></section><section><p>numbers 1 *</p><div class="wit-content" /></section><section><p>lists (empty list) (list concatenation)</p><div class="wit-content" /></section><section><p>endo-functions (identity function) (function composition)</p><div class="wit-content" /></section><section><p>sets (the empty set) union</p><div class="wit-content" /></section><section><p>sets (the total set) intersection</p><div class="wit-content"><section><p>iff a total set exists</p><div class="wit-content" /></section></div></section><section><p>propositions true and</p><div class="wit-content" /></section><section><p>propositions false or</p><div class="wit-content" /></section></div></section><section><p>note that not all instances of Semigroup can be extended to Monoid; for example numbers with (min or max); this is expected, as Monoid contains more information [capability] [an additional empty operation], hence is more difficult to implement</p><div class="wit-content" /></section></div></section><section><p>list is the &quot;free&quot; monoid</p><div class="wit-content"><section><p>among the instances of monoid one is very important: list</p><div class="wit-content" /></section><section><p>instance Monoid (List e) where</p><div class="wit-content"><section><p>empty = List.empty</p><div class="wit-content" /></section><section><p>(⊕) = List.concatenate</p><div class="wit-content" /></section></div></section><section><p>why?</p><div class="wit-content"><section><p>it is the so called &quot;free&quot; monoid; by &quot;free&quot; mathematicians mean that it does not have any other algebraic property than monoid has; no more abstract equalities are true for it; thus: the set of algebraic equalities true for lists with the List.empty and List.concatenate methods is exactly the set of algebraic equalitons of monoids; in this sense the list data structure is mathematically equivalent to the monoid algebra</p><div class="wit-content" /></section></div></section></div></section><section><p>convenience of implicit monoid inputs</p><div class="wit-content"><section><p>monoid makes us able to compose any number of values, for example the elements of a collection</p><div class="wit-content" /></section><section><p>the story is almost like with semigroup, but because monoid specifies an empty value too, it makes us able to drop the initial value input of the fold function too</p><div class="wit-content" /></section><section><p>fold_monoid : Monoid e =&gt; Collection e -&gt; e fold_monoid = fold_semigroup empty</p><div class="wit-content" /></section></div></section><section><p>creating new monoids from old ones</p><div class="wit-content"><section><p>composing via product type construction</p><div class="wit-content"><section><p>instance Monoid (t1 t2) &lt;= (Monoid t1, Monoid t2) where</p><div class="wit-content"><section><p>empty = (empty x1, empty x2)</p><div class="wit-content" /></section></div></section><section><p>of course this works with any kind of product type [any tuples, vectors]</p><div class="wit-content" /></section></div></section></div></section><section><p>usefulness</p><div class="wit-content"><section><p>if we have a monoid implementation of a type t then we can compose any number of values of t, without knowing anything additional about t</p><div class="wit-content"><section><p>this is not possible with semigroup, because it can not do this with an empty collection of values</p><div class="wit-content" /></section></div></section><section><p>the additional neutral element requirement is usually naturally fulfilled, but it is very useful</p><div class="wit-content" /></section><section><p>monoids are ubiquitous in both math and programming, in both theory and practice</p><div class="wit-content" /></section><section><p>in software coding</p><div class="wit-content"><section><p>the most fundamental structure of programs is the list; imperative programs are lists of instructions and functional programs are compositions of lists of functions</p><div class="wit-content" /></section><section><p>a lot of abstractions in software coding are monoidically composable; people even consciously try to design their abstractions to be monoidically composable; some important examples of monoidically composable things are Semigroup, Monoid, Applicative, Monad, Optics</p><div class="wit-content" /></section></div></section><section><p><a href="edsabrzmtmhnwgml.html">category</a></p><div class="wit-content" /></section></div></section></span></body></html>